<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3d-DNA的使用及juicebox调整挂载到染色体水平 ｜ HiC辅助基因组组装（二）</title>
    <url>/2021/07/18/3d-DNA/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><div class="note orange no-icon flat"><p>之前的文章中有介绍过，HiC常用的几款软件的原理内容。可以<a href="https://lxz9.com/2021/04/03/HiC/">点击链接访问了解一下</a><br>在这里不做赘述。</p>
</div>

<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="3d-DNA"><a href="#3d-DNA" class="headerlink" title="3d-DNA"></a>3d-DNA</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> https://hub.fastgit.org/aidenlab/3d-dna.git</span><br><span class="line">$ <span class="built_in">cd</span> 3d-dna</span><br><span class="line">$ chmod 755 run-asm-pipeline.sh</span><br><span class="line">$ chmod 755 run-asm-pipeline-post-review.sh</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"><span class="comment">#github安装(2021年7月18日-目前的最新版本)</span></span><br><span class="line">$ wget https://github.com/aidenlab/3d-dna/archive/refs/tags/201008.tar.gz</span><br><span class="line">$ tar zxvf 201008.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Juicer"><a href="#Juicer" class="headerlink" title="Juicer"></a>Juicer</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theaidenlab/juicer.git</span><br><span class="line"><span class="built_in">cd</span> juicer</span><br><span class="line">ln -s CPU scripts</span><br><span class="line"><span class="built_in">cd</span> scripts/common</span><br><span class="line">wget https://hicfiles.tc4ga.com/public/juicer/juicer_tools.1.9.9_jcuda.0.8.jar</span><br><span class="line">ln -s juicer_tools.1.9.9_jcuda.0.8.jar  juicer_tools.jar</span><br></pre></td></tr></table></figure>
<h2 id="要求环境"><a href="#要求环境" class="headerlink" title="要求环境"></a>要求环境</h2><blockquote>
<p>LastZ (version 1.03.73 released 20150708) – for diploid mode only<br>Java version &gt;=1.7<br>Bash &gt;=4<br>GNU Awk &gt;=4.0.2<br>GNU coreutils sort &gt;=8.11</p>
</blockquote>
<h1 id="3d-DNA使用"><a href="#3d-DNA使用" class="headerlink" title="3d-DNA使用"></a>3d-DNA使用</h1><h2 id="为基因组建索引"><a href="#为基因组建索引" class="headerlink" title="为基因组建索引"></a>为基因组建索引</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bwa index genome.fa</span><br></pre></td></tr></table></figure>
<h2 id="根据基因组构建创建可能的酶切位点文件"><a href="#根据基因组构建创建可能的酶切位点文件" class="headerlink" title="根据基因组构建创建可能的酶切位点文件"></a>根据基因组构建创建可能的酶切位点文件</h2><p><strong>需要使用到<code>juicer/misc/generate_site_positions.py </code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python /home/lixingze/software/juicer/misc/generate_site_positions.py </span><br><span class="line">Usage: /home/lixingze/software/juicer/misc/generate_site_positions.py &lt;restriction enzyme&gt; &lt;genome&gt; [location]</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;restriction enzyme&gt; 选择对应的限制性内切酶</span></span><br><span class="line"><span class="comment"># &lt;genome&gt; 基因组序列文件</span></span><br><span class="line">eg:</span><br><span class="line">python /home/lixingze/software/juicer/misc/generate_site_positions.py  DpnII genome genome.fa</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="运行如下命令-获取每条contig的长度"><a href="#运行如下命令-获取每条contig的长度" class="headerlink" title="运行如下命令, 获取每条contig的长度"></a>运行如下命令, 获取每条contig的长度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;print $1, $NF&#125;&#x27;</span> genome_DpnII.txt &gt; genome.chrom.sizes</span><br></pre></td></tr></table></figure>

<h2 id="运行juicer"><a href="#运行juicer" class="headerlink" title="运行juicer"></a>运行juicer</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /home/lixingze/software/juicer/scripts/juicer.sh -h</span><br><span class="line">Usage: juicer.sh [-g genomeID] [-d topDir] [-s site] [-a about]</span><br><span class="line">                 [-S stage] [-p chrom.sizes path] [-y restriction site file]</span><br><span class="line">                 [-z reference genome file] [-D Juicer scripts directory]</span><br><span class="line">                 [-b ligation] [-t threads] [-h] [-f] [-j]</span><br><span class="line"><span class="comment"># -g: 自定义名称</span></span><br><span class="line"><span class="comment"># -s: 酶切类型, HindIII(AAGCTAGCTT), MboI(GATCGATC) , DpnII(GATCGATC), NcoI(CCATGCATGG),具体是什么酶切类型可以咨询测序公司</span></span><br><span class="line"><span class="comment"># -z : 参考基因组文件</span></span><br><span class="line"><span class="comment"># -y: 限制性酶切位点文件位置</span></span><br><span class="line"><span class="comment"># -p: 染色体大小文件</span></span><br><span class="line"><span class="comment"># -C: 将原来的文件进行拆分，必须是4的倍数，默认是90000000, 即22.5M reads</span></span><br><span class="line"><span class="comment"># -S: 和任务重运行有关，从中途的某一步开始,&quot;merge&quot;, &quot;dedup&quot;, &quot;final&quot;, &quot;postproc&quot; 或 &quot;early&quot;</span></span><br><span class="line"><span class="comment"># -d: Hi-C 数据的存放目录</span></span><br><span class="line"><span class="comment"># -D: juicer的位置目录，我本人在/home/lixingze/software/juicer/</span></span><br><span class="line"><span class="comment"># -t: 线程数</span></span><br><span class="line"><span class="comment"># 必选项 -z -p -y</span></span><br></pre></td></tr></table></figure>
<p><strong>个人运行示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash /home/lixingze/software/juicer/scripts/juicer.sh  -d /home/lixingze/data/HiC/05.3d-DNA-3cell/hic -D /home/lixingze/software/juicer/ -z ./genome.fa -y ./genome_DpnII.txt -p ./genome.chrom.sizes -s DpnII -t 70</span><br></pre></td></tr></table></figure>
<p>输出的结果文件在aligned目录下，其中<code>merged_nodups.txt</code>就是下一步3D-DNA的输入文件之一。</p>
<h2 id="运行3d-dna"><a href="#运行3d-dna" class="headerlink" title="运行3d-dna"></a>运行3d-dna</h2><p><strong><em>在3d-dna目录下有个<code>run-asm-pipeline.sh</code>脚本，使用此脚本</em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USAGE: ./run-asm-pipeline.sh [options] &lt;path_to_input_fasta&gt; &lt;path_to_input_mnd&gt;</span><br><span class="line"><span class="comment"># &lt;path_to_input_fasta&gt;  输入参考基因组序列文件</span></span><br><span class="line"><span class="comment"># &lt;path_to_input_mnd&gt;  输入之前分析得到的merged_nodups.txt</span></span><br><span class="line"><span class="comment"># -m haploid/diploid  以特定模式运行，单倍体或二倍体（默认为单倍体）</span></span><br><span class="line"><span class="comment"># -i input_size  指定阈值输入Contigs/scaffolds大小（默认值为15000）。小于输入值的Contigs/scaffolds将被忽略。</span></span><br><span class="line"><span class="comment"># -r 2  指定错误联接更正的迭代轮数（默认值为2）。</span></span><br><span class="line"><span class="comment"># -s stage 快进到以后的组装步骤，可以进行polish, split, seal, merge, finalize</span></span><br></pre></td></tr></table></figure>
<p><strong>个人运行示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup bash /home/lixingze/software/3d-dna/run-asm-pipeline.sh -r 2 genome.fa /home/lixingze/data/HiC/05.3d-DNA-3cell/hic/aligned/merged_nodups.txt &amp;&gt; 3d.log &amp;</span><br></pre></td></tr></table></figure>
<p>推荐使用 genome.0.hic文件以及 genome.0.assembly文件进行后续操作</p>
<h1 id="juicebox调整3d-DNA输出的结果"><a href="#juicebox调整3d-DNA输出的结果" class="headerlink" title="juicebox调整3d-DNA输出的结果"></a>juicebox调整3d-DNA输出的结果</h1><p>这个调整过程需要细心耐心以及相关背景知识。</p>
<ol>
<li><p>aidenlab提供了在线的juicebox<br><a href="http://aidenlab.org/juicebox/">http://aidenlab.org/juicebox/</a></p>
</li>
<li><p>本地juicebox调整（推荐下载）<br><a href="https://github.com/aidenlab/juicebox/wiki/Download">https://github.com/aidenlab/juicebox/wiki/Download</a></p>
</li>
</ol>
<p>网上有相关操作视频</p>
<p>调整完成之后将其保存为genome.review.assembly<br>如果是未发表的基因组，建议将染色体从大到小进行排列。</p>
<h1 id="再次运行3d-DNA"><a href="#再次运行3d-DNA" class="headerlink" title="再次运行3d-DNA"></a>再次运行3d-DNA</h1><blockquote>
<p>这次使用<code>run-asm-pipeline-post-review.sh</code>脚本，用于在Juicebox Assembly Tools模块（由review.Assembly文件表示）中进行审阅，将程序集（由之前对齐的Hi-C reads和Juicer pipeline生成的）最终确定为染色体长度的fasta序列。该脚本将生成一个输出fasta文件、最终装配Hi-C map的assembly文件和一些补充注释文件，便于在Juicebox中查看结果。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USAGE: ./run-asm-pipeline-post-review.sh [options] -r &lt;review.assembly&gt; &lt;path_to_input_fasta&gt; &lt;path_to_input_mnd&gt;</span><br><span class="line"><span class="comment"># &lt;review.assembly&gt; 输入juicebox调整之后得到的genome.rawchrom.assembly</span></span><br><span class="line"><span class="comment"># &lt;path_to_input_fasta&gt; 输入参考基因组序列文件</span></span><br><span class="line"><span class="comment"># &lt;path_to_input_mnd&gt; 之前得到的merged_nodups.txt</span></span><br><span class="line"><span class="comment"># -r 查看“.assembly”文件的路径。</span></span><br><span class="line">可选参数</span><br><span class="line"><span class="comment"># -i input_size 指定阈值输入Contigs/scaffolds（默认值为15000）。小于输入阈值的Contigs/scaffolds的将被忽略。应与运行原始脚本时使用的相同。</span></span><br><span class="line"><span class="comment"># -g gap_size 要在最终染色体长度支架中的支架序列之间添加的间隙大小（默认值为500）。</span></span><br><span class="line"><span class="comment"># --sort-output 选择按大小按降序排列染色体长度支架。</span></span><br></pre></td></tr></table></figure>
<p><strong>个人运行示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup bash ~/software/3d-dna/run-asm-pipeline-post-review.sh -r genome.rawchrom.assembly genome.fa hic/aligned/merged_nodups.txt &amp;&gt; 3d.log </span><br></pre></td></tr></table></figure>
<p>得出最终的染色体水平文件 genome.FINAL.fasta</p>
<h1 id="提升最后一步的速度"><a href="#提升最后一步的速度" class="headerlink" title="提升最后一步的速度"></a>提升最后一步的速度</h1><p>因为<code>run-asm-pipeline-post-review.sh</code>原始的速度太慢了。所以建议去修改一下源文件内容，大大提升最后一步的速度，可以<a href="https://hub.fastgit.org/aidenlab/3d-dna/pull/58">参考链接</a></p>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
      <tags>
        <tag>HiC</tag>
        <tag>教程</tag>
        <tag>ALLHIC</tag>
        <tag>HiC-Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>ALLHIC使用 ｜ HiC辅助基因组组装（三）</title>
    <url>/2021/08/05/ALLHIC/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tangerzhang/ALLHiC</span><br><span class="line"><span class="built_in">cd</span> ALLHiC</span><br><span class="line">chmod +x bin/*</span><br><span class="line">chmod +x scripts/*  </span><br><span class="line"><span class="built_in">export</span> PATH=/your/path/to/ALLHiC/scripts/:/your/path/to/ALLHiC/bin/:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<h2 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h2><ul>
<li>samtools v1.9+</li>
<li>bedtools</li>
<li>matplotlib v2.0+</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><div class="note pink no-icon flat"><p>ALLHIC官网提供了很详尽的内容，以及完整的pipeline，所以这里我主要是用来理清楚其整体思路，记录一下。<br>建议使用软件务必参照官网</p>
</div>

<a class="btn-beautify button--animated purple larger" href="https://github.com/tangerzhang/ALLHiC/wiki" title="官网链接手册"><i class="far fa-hand-point-right"></i><span>官网链接手册</span></a>




<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><a href="https://github.com/tangerzhang/ALLHiC">ALLHiC</a>一共分为五步:pruning, partition, rescue, optimization, building</p>
<ol>
<li><p><strong>prune</strong> 步骤去除了等位基因之间的联系，因此同源染色体更易于单独分离。</p>
</li>
<li><p><strong>partition</strong> 功能将修剪的bam文件作为输入，并根据Hi-C建议的链接对链接的contigs进行聚类，大概是沿着相同同源染色体在预设数量的分区中进行。</p>
</li>
<li><p><strong>rescue</strong> 功能从原始未修剪的bam文件中搜索分区步骤中不涉及的contigs，并根据Hi-C信号密度将它们分配给特定的群集。</p>
</li>
<li><p><strong>optimize</strong> 步骤采用每个分区，并优化所有contigs的顺序和方向。</p>
</li>
<li><p><strong>build</strong> 步骤通过连接contigs来重建每个染色体</p>
</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://z3.ax1x.com/2021/04/03/cuChJx.png" alt="ALLHiC">]</p>
<h2 id="Explanation-of-Prune"><a href="#Explanation-of-Prune" class="headerlink" title="Explanation of Prune"></a>Explanation of Prune</h2><ol>
<li><p>同源四倍体基因组的示意图。四个同源染色体显示为不同的颜色（分别为<font color="#0000FF">蓝色</font>，<font color="#FF8C00">橙色</font>，<font color="#008000">绿色</font>和<font color="#9400D3">紫色</font>）​​。染色体中的<font color="#FF0000">红色</font>区域表示具有高度相似性的序列。</p>
</li>
<li><p>检测自身四倍体基因组中的Hi-C信号。黑色虚线表示折叠区域和未折叠区域contigs之间的Hi-C信号。<font color="#FF69B4">粉色</font>虚线表示单体型Hi-C链接，<font color="#808080">灰色</font>虚线表示单体型Hi-C链接。在组装过程中，<font color="#FF0000">红色</font>区域会因高度的序列相似性而崩溃；同时，如果其他区域之间存在大量差异，则会将它们分为不同的contigs。由于塌陷区域与来自不同单倍型的contigs在物理上相关，因此将在塌陷区域与所有其他未塌陷的contigs之间检测到Hi-C信号。</p>
</li>
<li><p>传统的Hi-C脚手架方法将检测来自不同单倍型和折叠区域的contigs中的信号，并将所有序列聚在一起。</p>
</li>
<li><p>修剪Hi-C信号：1-去除等位基因区域之间的信号；2-仅在折叠区域和未折叠contigs之间保留最强的信号。</p>
</li>
<li><p>基于修剪的Hi-C信息进行分区。理想情况下，根据修剪结果将contigs分为不同的组。</p>
</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/04/03/cuCXFI.png" alt="Prune"></p>
<h1 id="运行ALLHIC"><a href="#运行ALLHIC" class="headerlink" title="运行ALLHIC"></a>运行ALLHIC</h1><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><ol>
<li>Contig 水平的基因组组装结果</li>
<li>Hi-C测序数据</li>
</ol>
<h2 id="将-Hi-C-reads-Map-到基因组草图"><a href="#将-Hi-C-reads-Map-到基因组草图" class="headerlink" title="将 Hi-C reads Map 到基因组草图"></a>将 Hi-C reads Map 到基因组草图</h2><blockquote>
<p>bwa index and samtools faidx 对基因组草图建立索引</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bwa index -a bwtsw draft.asm.fasta  </span><br><span class="line">samtools faidx draft.asm.fasta  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hi-C reads Aligning 到基因组草图上</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bwa aln -t 24 draft.asm.fasta reads_R1.fastq.gz &gt; sample_R1.sai  </span><br><span class="line">bwa aln -t 24 draft.asm.fasta reads_R2.fastq.gz &gt; sample_R2.sai  </span><br><span class="line">bwa sampe draft.asm.fasta sample_R1.sai sample_R2.sai reads_R1.fastq.gz reads_R2.fastq.gz &gt; sample.bwa_aln.sam  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>过滤SAM文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PreprocessSAMs.pl sample.bwa_aln.sam draft.asm.fasta MBOI</span><br><span class="line">(*)filterBAM_forHiC.pl sample.bwa_aln.REduced.paired_only.bam sample.clean.sam</span><br><span class="line">samtools view -bt draft.asm.fasta.fai sample.clean.sam &gt; sample.clean.bam</span><br><span class="line"></span><br><span class="line">*Tip: skip this step if you are using bwa mem for alignment</span><br></pre></td></tr></table></figure>
<h2 id="Prune-option"><a href="#Prune-option" class="headerlink" title="Prune(option)"></a>Prune(<em>option</em>)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  </span><br><span class="line"></span><br><span class="line">ALLHiC_prune -i Allele.ctg.table -b sample.clean.bam -r draft.asm.fasta  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里需要输入Allele.ctg.table文件，这个文件需要自己获取，参考<a href="https://github.com/tangerzhang/ALLHiC/wiki/ALLHiC:-identify-allelic-contigs">官方参考链接</a>; </p>
</blockquote>
<div class="note pink no-icon flat"><p>ALLHiC 依靠等位基因重叠群表 (Allele.ctg.table) 来去除嘈杂的 Hi-C 信号</p>
<p>Allele.ctg.table 的格式：<br>前两列是染色体 ID 和参考基因组的位置。（如果您不使用参考基因​​组来生成 Allele.ctg.table，您可以将它们保留为 NA）<br>第 3 到第 N 列是我们确定的等位基因重叠群。修剪步骤将删除等位基因重叠群之间的 Hi-C 链接读数。</p>
</div>

<h3 id="方法一：基于-BLAST-结果鉴定等位基因重叠群"><a href="#方法一：基于-BLAST-结果鉴定等位基因重叠群" class="headerlink" title="方法一：基于 BLAST 结果鉴定等位基因重叠群"></a>方法一：基于 BLAST 结果鉴定等位基因重叠群</h3><div class="note pink no-icon flat"><p>将目标基因组中的 CDS Blast到相关参考的 CDS 文件<br>注意：请在运行 BLAST 之前修改 cds 名称。cds 名称应与 GFF3 中存在的基因名称相同</p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ blastn -query rice.cds -db Bd.cds -out rice_vs_Sb.blast.out -evalue 0.001 -outfmt 6 -num_threads 4 -num_alignments 1</span><br></pre></td></tr></table></figure>
<p>移除同一性 &lt; 60% 和覆盖率 &lt; 80% 的blast hits</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blastn_parse.pl -i rice_vs_Sb.blast.out -o Erice_vs_Sb.blast.out -q rice.cds-b 1 -c 0.6 -d 0.8 </span><br></pre></td></tr></table></figure>
<p>根据 BLAST 结果对等位基因进行分类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">classify.pl -i Eblast.out -p 2 -r Sbicolor_313_v3.1.gene -g rice.gff3   </span><br></pre></td></tr></table></figure>
<h3 id="方法二：基于-GMAP-的方法"><a href="#方法二：基于-GMAP-的方法" class="headerlink" title="方法二：基于 GMAP 的方法"></a>方法二：基于 GMAP 的方法</h3><div class="note pink no-icon flat"><p>来生成 Allele.ctg.table，它不需要的目标基因组的注释。<br>这个方法适合于大多数人，因为如果是De novo组装，一般做Hi-C辅助基因组组装时肯定没有进行基因预测没有gff以及cds、pep序列，所以就需要进行下面的操作。</p>
</div>

<p><a href="https://github.com/tangerzhang/ALLHiC/issues/16">详细命令请看以下链接</a></p>
<p>运行 gmap 得到一个 gff3 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gmap_build -D . -d DB target.genome</span><br><span class="line">gmap -D . -d DB -t 12 -f 2 -n $N reference.cds.fasta &gt; gmap.gff3</span><br></pre></td></tr></table></figure>
<div class="note orange no-icon flat"><p>注意：</p>
<ol>
<li>target.genome 是多倍体基因组组装的 contig 水平</li>
<li>$N 是你的目标基因组的倍性，例如 $N=4 如果它是四倍体</li>
<li>reference.cds.fasta 是编码序列二倍体基因组，可参考得到等位基因表</li>
</ol>
<ol start="2">
<li>生成 allelic.ctg.table</li>
</ol>
</div>

<p><code>perl gmap2AlleleTable.pl referenece.gff3</code></p>
<p>gmap2Alleletable.pl的脚本链接<a href="https://github.com/tangerzhang/ALLHiC/blob/master/scripts/gmap2AlleleTable.pl">点击此处</a></p>
<blockquote>
<p>gmap2Alleletable.pl内容如下</p>
</blockquote>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">die</span> <span class="string">&quot;Usage: perl $0 ref.gff3\n&quot;</span> <span class="keyword">if</span>(!<span class="keyword">defined</span> ($ARGV[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">my</span> $refGFF = $ARGV[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">open</span>(IN, <span class="string">&quot;grep &#x27;gene&#x27; gmap.gff3 |&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span><span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(&lt;IN&gt;)&#123;</span><br><span class="line">	<span class="keyword">chomp</span>;</span><br><span class="line">	<span class="keyword">my</span> @data = <span class="keyword">split</span>(<span class="regexp">/\s+/</span>,$_);</span><br><span class="line">	<span class="keyword">my</span> $gene = $1 <span class="keyword">if</span>(<span class="regexp">/Name=([^;\n]*)/</span>);</span><br><span class="line">	$infordb&#123;$gene&#125; .= $data[<span class="number">0</span>].<span class="string">&quot;	&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>(OUT, <span class="string">&quot;&gt; Allele.ctg.table&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span><span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">open</span>(IN, <span class="string">&quot;awk &#x27;\$3==\&quot;gene\&quot;&#x27; $refGFF |&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span><span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(&lt;IN&gt;)&#123;</span><br><span class="line">	<span class="keyword">chomp</span>;</span><br><span class="line">	<span class="keyword">my</span> @data = <span class="keyword">split</span>(<span class="regexp">/\s+/</span>,$_);</span><br><span class="line">	<span class="keyword">my</span> $gene = $1 <span class="keyword">if</span>(<span class="regexp">/Name=(\S+)/</span>);</span><br><span class="line">	   $gene =~ <span class="regexp">s/;.*//</span>g;</span><br><span class="line">	<span class="keyword">next</span> <span class="keyword">if</span>(!<span class="keyword">exists</span>($infordb&#123;$gene&#125;));</span><br><span class="line">	<span class="keyword">my</span> @tdb = <span class="keyword">split</span>(<span class="regexp">/\s+/</span>,$infordb&#123;$gene&#125;);</span><br><span class="line">	<span class="keyword">my</span> %tmpdb = ();</span><br><span class="line">	<span class="keyword">map</span> &#123;$tmpdb&#123;$_&#125;++&#125; @tdb;</span><br><span class="line">	<span class="keyword">print</span> OUT <span class="string">&quot;$data[0]	$data[3]	&quot;</span>;</span><br><span class="line">	<span class="keyword">map</span> &#123;<span class="keyword">print</span> OUT <span class="string">&quot;$_	&quot;</span>&#125; <span class="keyword">keys</span> %tmpdb;</span><br><span class="line">	<span class="keyword">print</span> OUT <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"><span class="keyword">close</span> OUT;</span><br></pre></td></tr></table></figure>
<h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><blockquote>
<p>ps :如果跳过了第四步，那么可以直接用第三步分析的结果sample.clean.bam</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  </span><br><span class="line"></span><br><span class="line">ALLHiC_partition -b prunning.bam -r draft.asm.fasta -e AAGCTT -k 16  </span><br><span class="line"></span><br><span class="line">Parameters: </span><br><span class="line">      -h : <span class="built_in">help</span> and usage.</span><br><span class="line">      -b : prunned bam (optional, default prunning.bam)</span><br><span class="line">      -r : draft.sam.fasta</span><br><span class="line">      -e : 酶切位点(HindIII: AAGCTT; MboI: GATC)</span><br><span class="line">      -k : 分组数量 根据HiC信号将不同的contig进行分组</span><br><span class="line">      -m : minimum number of restriction sites (default, 25)</span><br></pre></td></tr></table></figure>
<h2 id="Rescue"><a href="#Rescue" class="headerlink" title="Rescue"></a>Rescue</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果做了第四步，会生成 -c prunning.clusters.txt 以及 -i prunning.counts_AAGCTT.txt</span></span><br><span class="line">ALLHiC_rescue -b sample.clean.bam -r draft.asm.fasta -c prunning.clusters.txt -i prunning.counts_AAGCTT.txt</span><br></pre></td></tr></table></figure>
<h2 id="Optimize"><a href="#Optimize" class="headerlink" title="Optimize"></a>Optimize</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成.clm文件</span></span><br><span class="line">allhic extract sample.clean.bam draft.asm.fasta --RE AAGCTT  </span><br><span class="line"><span class="comment"># 优化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> group*.txt; <span class="keyword">do</span></span><br><span class="line">    allhic optimize <span class="variable">$i</span> sample.clean.clm</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALLHiC_build draft.asm.fasta  </span><br></pre></td></tr></table></figure>
<h2 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALLHiC_plot sample.clean.bam groups.agp chrn.list 500k pdf</span><br></pre></td></tr></table></figure>
<h1 id="作者问题回复"><a href="#作者问题回复" class="headerlink" title="作者问题回复"></a>作者问题回复</h1><ol>
<li>修剪步骤中折叠区域和嵌合重叠群之间有什么区别？<br>在多倍体基因组中，一些同源区域（即等位基因序列）高度相似。这些序列经常被组装成一个重叠群，因为组装者不能分离等位基因。这种区域是折叠区域。<br>另一方面，一些重叠群包含来自不同单倍型或非同源染色体的序列，可以将其视为chimeric contigs。ALLHiC 旨在最大限度地减少collapsed contigs的负面影响，我们的模拟数据显示 ALLHiC 能够tolerate ~20% 的collapsed contigs；然而，只有约 5% 的chimeric contigs.。</li>
</ol>
<ol start="2">
<li>如何确定哪些染色体组是同源的？<br><img src="https://z3.ax1x.com/2021/08/05/fe8ztI.jpg"></li>
</ol>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
      <tags>
        <tag>HiC</tag>
        <tag>教程</tag>
        <tag>ALLHIC</tag>
      </tags>
  </entry>
  <entry>
    <title>如何进行基因组注释</title>
    <url>/2021/02/08/Annoation/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font face="微软雅黑" color="#000080" size="5">定义</font></h1><p><strong>基因组注释</strong>：是利用生物信息学方法和工具，对基因组所有基因的生物学功能进行高通量注释，是当前<a href="https://baike.baidu.com/item/%E5%8A%9F%E8%83%BD%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/4148743">功能基因组学</a>研究的一个热点。<br><strong>基因组注释</strong>:即在一条DNA序列上，通过从头、同源、结构定义等多种方法，搜寻并定义基因组原件，得到其位置、序列、结构、功能等信息。</p>
<h1 id="基因组注释流程图"><a href="#基因组注释流程图" class="headerlink" title="基因组注释流程图"></a><font face="微软雅黑" color="#000080" size="5">基因组注释流程图</font></h1><p><img src="https://z3.ax1x.com/2021/02/08/yap09e.png" alt="基因组注释"></p>
<h1 id="基因组注释前期准备"><a href="#基因组注释前期准备" class="headerlink" title="基因组注释前期准备"></a><font face="微软雅黑" color="#000080" size="5">基因组注释前期准备</font></h1><div class="note blue no-icon flat"><p>物种拉丁名，例如:Orazy sativa，基因id:Osa000001<br>同源物种: 一般选5个左右物种，需要有注释的基因/蛋白序列，保证高组装和注释质量<br>转库组数据: RNAseq和lsoseq注释（用于结构注释中的转录辅助注释）(建议自测同样本的数据)</p>
</div>

<h1 id="基因组注释的分析内容"><a href="#基因组注释的分析内容" class="headerlink" title="基因组注释的分析内容"></a><font face="微软雅黑" color="#000080" size="5">基因组注释的分析内容</font></h1><p><img src="https://z3.ax1x.com/2021/02/08/yapatO.png" alt="yapatO.png">]</p>
<h2 id="重复注释"><a href="#重复注释" class="headerlink" title="重复注释"></a>重复注释</h2><p>重复序列广泛存在于真核生物基因组中，这些重复序列或集中成簇，或分散在基因之间。根据分布把重复序列分为散在重复序列和串联重复序列。<br>重复序列根据序列特征分为2类：串联重复（Tandem repeats）和散布重复（Dispersed repeats） </p>
<ol>
<li>RepeatMasker:基于Repbase(dna)/自建elibrary查询重复序列</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RepeatMasker -nolow -no_is -norna -parallel 2 -lib RepeatMasker.lib genome.fa</span><br><span class="line"><span class="comment">#-nohow:屏蔽低复杂简单重复; -no_is:跳过细菌插入元件检查; -norna:不掩盖小RNA(伪)基因;</span></span><br><span class="line"><span class="comment">#-parallel 并行使用的处理器数,可提升分析速度</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>RepeatProteinMask:基于 Repbase(pep)查询重复序列</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RepeatProteinMask -noLowSimple -pvalue 0.0001 genome.fa</span><br><span class="line"><span class="comment">#noLowSimple:关闭低复杂度和简单重复的屏蔽/注释; -pvalue:接受匹配的阈值</span></span><br><span class="line"><span class="comment">#注意点: genome.fa的D不能长于18个字符</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>TRF:元件的结构特征等来识别重复序列</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trf genome.fa 2 7 7 80 10 50 2000 -d -h</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>LTR-FINDER:基于重复序列特征</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Itr_finder -W 2 -C -s tRNAs.fa genome.fa</span><br><span class="line"><span class="comment">#-w 2 输出格式,2-table;  -C:检测中心粒,删除高重复区域</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>repeatmodeler:基于自身序列比对</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BuildDatabase -name mydb genome.fa</span><br><span class="line">RepeatModeler -database mydb -pa 6 &gt;run.out</span><br><span class="line"><span class="comment">#-name:创建 database的名称;</span></span><br><span class="line"><span class="comment">#-pa:共享内存处理器的数量程序,可提升分析速度</span></span><br></pre></td></tr></table></figure>
<table><tr><td bgcolor="yellow">每个软件都有很多参数,可-help/-h自行查看,参数的选择最好是参考已发表的文献</td></tr></table>

<h2 id="结构注释"><a href="#结构注释" class="headerlink" title="结构注释"></a>结构注释</h2><p><strong>结构注释</strong>:注释可以产生具有生物学功能的蛋白的基因。一般包括启动子，转录起始，5’UTR，起始密码子，外显子，内含子，终止密码子，3’UTR，poly-A等结构。</p>
<p><img src="https://z3.ax1x.com/2021/02/08/yapdhD.png" alt="yapdhD.png">]</p>
<h3 id="De-novo预测-屏蔽重复序列"><a href="#De-novo预测-屏蔽重复序列" class="headerlink" title="De novo预测(屏蔽重复序列)"></a>De novo预测(屏蔽重复序列)</h3><ol>
<li><p>Augustus(真核)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">augustus --species=XXX --AUGUSTUS CONFIG PATH= config --uniqueGeneld=<span class="literal">true</span> --nolnFrameStop=true--gff3=on --strand=both genome.mask.fa&gt; genome.mask.fa.out</span><br><span class="line"><span class="comment"># --uniqueGeneld=true:gene:命名 aseqname.gn;</span></span><br><span class="line"><span class="comment"># --nolnFrameStop=true:不带有终止密码子的转录本;</span></span><br><span class="line"><span class="comment"># --gff3=on:输出格式gff3</span></span><br></pre></td></tr></table></figure></li>
<li><p>GlimmerHMM(真核,预测的基因数目较多长度较短,一般用于植物)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">glimmerhmm.genome.mask.fa -d XXX- f -g genome.mask.fa.gff</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d 库de路径;</span></span><br><span class="line"><span class="comment"># -f:不要partial gene predictions;</span></span><br><span class="line"><span class="comment"># -g输出格式gff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Genscan(真核,其预测的内含子较大,一般用于动物)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genscan Humanlso.smat genome.mask.fa &gt; genome.mask.fa.genscan</span><br><span class="line"><span class="comment"># Humanlsc.smat:参数文件,软件自带</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>4.其他软件</p>
<blockquote>
<p>SNAP. GenelD GenemarkS<br> denovo的软件很多,两个软件就可以了,太多软件会增加较多的假阳性,一般在<br> Augustus, GlimmerHMM, Genscan中选择即可</p>
</blockquote>
<h3 id="Homolog注释"><a href="#Homolog注释" class="headerlink" title="Homolog注释"></a>Homolog注释</h3><p>利用近缘物种已知基因进行序列比对,找到同源序列。然后在同源序列的基础上,根据基因信号如剪切信号、基因起始和终止密码子对基因结构进行预测。<br>相对于从头预测的“大海捞针”,同源预测相当于先用一块磁铁在基因组大海中缩小了可能区域,然后从可能区域中鉴定基因结构。</p>
<blockquote>
<p>利用<strong>TBlastn</strong>将同源物种的蛋白比对回基因组,得到候选区域。<br>利用 EXonerate/ Genewise进行精确的蛋白-核酸比对,以得到剪接位点。<br>Exonerate解决了 GeneWisez存在的很多问题,并且速度快了1000倍,默认选择EXonerate分析</p>
</blockquote>
<h3 id="RNA-seq辅助注释"><a href="#RNA-seq辅助注释" class="headerlink" title="RNA-seq辅助注释"></a>RNA-seq辅助注释</h3><pre><code>tophat比对————&gt;cufflink转录本————&gt;TransDecoder</code></pre>
<ol>
<li>将RNAseq数据进行<font color="#FF0000">tophat</font>比对;</li>
<li>比对后的结果文件利用<font color="#FF0000">cufflink</font>构建转录本</li>
<li>使用<font color="#FF0000">TransDecoder</font>在构建的转录本上预测Open Reading Frame(ORF)。</li>
</ol>
<h3 id="Iso-seq-辅助注释"><a href="#Iso-seq-辅助注释" class="headerlink" title="Iso seq 辅助注释"></a>Iso seq 辅助注释</h3><pre><code>CD-HIT————&gt;gmap比对————&gt;TransDecoder</code></pre>
<ol>
<li>将物种的三代全长转录本用<font color="#0000FF">CD-HIT</font>进行去冗余;</li>
<li>将去冗余后的序列使用<font color="#0000FF">gmap</font>比对回基因组得到转录本位置;</li>
<li>使用<font color="#0000FF">TransDecoder</font>在构建的转录本上预测 Open Reading Frame(ORF).</li>
</ol>
<p>基因结构预测方法可信度排序</p>
<h3 id="MAKERE整合"><a href="#MAKERE整合" class="headerlink" title="MAKERE整合"></a>MAKERE整合</h3><p>在基因组注释上, MAKER算是一个很强大的分析流程,主要是进行 Denovo注释， Homolog注释,转录辅助注释三者的整合,保证最终注释基因集的可靠性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maker maker_exe.ctl maker_opts.ctl maker_bopts.ctl</span><br><span class="line"><span class="comment">#maker exe.ct:执行程序的路径</span></span><br><span class="line"><span class="comment">#maker_ boots.ctl: BLAST7和 Exonerate的过滤参数</span></span><br><span class="line"><span class="comment">#maker opts.ctl:其他信息,例如输入基因组文件,主要调整输入文件等( genome= ;est= ;protein= ;pred_gff= ;)</span></span><br></pre></td></tr></table></figure>
<h2 id="nCRNA注释"><a href="#nCRNA注释" class="headerlink" title="nCRNA注释"></a>nCRNA注释</h2><ul>
<li>rRNA(核糖体RNA)<br>与蛋白质结合形成核糖体,其功能是作为mn的支架,提供mRNA翻译成蛋白质的场所。</li>
<li>tRNA(转运RNA)<br>·携带氨基酸进入核糖体,使之在mRNA指导下合成蛋白质。</li>
<li>miRNA(miRNA)<br>·将mRNA降解或抑制其翻译,具有沉默基因的功能。</li>
<li>SnRNA(小核RNA)<br>·主要参与RNA前体的加工过程,是RNA剪切体的主要成分。</li>
</ul>
<h3 id="miRNA与snRNA注释"><a href="#miRNA与snRNA注释" class="headerlink" title="miRNA与snRNA注释"></a>miRNA与snRNA注释</h3><ul>
<li>采用Rfam和INFERNAL进行二级结构检测。</li>
<li><a href="ftp://ftp.sanger.ac.uk/pub/databases/Rfam">ftp://ftp.sanger.ac.uk/pub/databases/Rfam</a></li>
<li>blastn+cmsearch (INFERNAL程序)</li>
</ul>
<h3 id="rRNA注释"><a href="#rRNA注释" class="headerlink" title="rRNA注释"></a>rRNA注释</h3><ul>
<li>由于rRNA的结构保守程度非常高，因此采用与已有的全长rRNA进行blastn比对而获得。</li>
<li>blastn</li>
</ul>
<h3 id="tRNA注释"><a href="#tRNA注释" class="headerlink" title="tRNA注释"></a>tRNA注释</h3><ul>
<li>结构特点:三叶草型二级结构。</li>
<li>预测方法:针对二级结构进行检测。使用<font color="#0000FF">tRNAscan-SE</font></li>
</ul>
<h2 id="功能注释"><a href="#功能注释" class="headerlink" title="功能注释"></a>功能注释</h2><p><strong>功能注释</strong>:基因功能的注释依赖于上一步的基因结构预测，根据预测结果从基因组上提取翻译后的蛋白序列和主流的数据库进行blastp比对，完成功能注释。</p>
<div class="note purple no-icon flat"><p>常用数据库一共有以下几种:NR，KEGG, Uniprot (Swiss-Prot, TrEMBL)，InterPro,Go</p>
</div>


<ol>
<li>KEGG</li>
</ol>
<ul>
<li>生物学通路数据库(Gene,Pathway,Ligand).</li>
<li><a href="http://www.genome.jp/kegg/">http://www.genome.jp/kegg/</a></li>
<li>blastp</li>
</ul>
<ol start="2">
<li>SWISS-PROT和TrEMBL</li>
</ol>
<ul>
<li>UniProt (Universal Protein Resource)蛋白质序列数据库PIR、SWISS-PROT和TrEMBL统一起来，建立了一个蛋白质数据库。</li>
<li><a href="http://www.uniprot.org/">http://www.uniprot.org/</a></li>
<li>blastp</li>
</ul>
<ol start="3">
<li>Interpro</li>
</ol>
<ul>
<li>蛋白家族(protein families)、功能保守区域(domains)和功能位点(funtional sites)的数据库.</li>
<li><a href="http://www.ebi.ac.uk/interpro/">http://www.ebi.ac.uk/interpro/</a></li>
<li>InterProScan</li>
</ul>
<ol start="4">
<li>GO</li>
</ol>
<ul>
<li>基因功能注释数据库(GeneOntology)</li>
<li>三个层面Cellular Component、 Biological Process、  Molecular Function.</li>
<li><a href="http://www.geneontology.org/">http://www.geneontology.org/</a></li>
<li>InterProScan</li>
</ul>
<h2 id="基因组评估"><a href="#基因组评估" class="headerlink" title="基因组评估"></a>基因组评估</h2><ul>
<li>BUSCO评估</li>
</ul>
<blockquote>
<p>BUSCO是一款使用python语言编写的对转录组和基因组组装质量进行评估的软件。在相近的物种之间总有一些保守的序列，而BUSCO就是使用这些保守序列与组装的结果进行比对，鉴定组装的结果是否包含这些序列，包含单条、多条还是部分或者不包含等等情况来给出结果。<br>BUSCO软件根据OrthoDB数据库，构建了几个大的进化分支的单拷贝基因集。将其与该基因集进行比较，根据比对上的比例、完整性，来评价准确性和完整性。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p><strong>基因组注释</strong></p>
<p>重复注释————RepeatMask, RepeatProteinMask, TRF, LTR-FINDER,repeatmodeler;<br>结构注释————Denovo注释，同源注释，转录辅助注释;<br>ncRNA注释————tRNA，rRNA,miRNA,snRNA;<br>功能注释————NR， KEGG， InterPro,SWISS-PROT，TrEMBL，GO;<br>基因组评估————BUSCO</p>
</div>



<a class="btn-beautify button--animated red right larger" href="https://lxz9.com/" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>基因组注释</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>基因组注释</tag>
      </tags>
  </entry>
  <entry>
    <title>HiFi全基因组测序技术与实例｜HiFi基因组组装软件推荐</title>
    <url>/2021/02/01/HIFI/</url>
    <content><![CDATA[<h1 id="HIFI技术的简介"><a href="#HIFI技术的简介" class="headerlink" title="HIFI技术的简介"></a>HIFI技术的简介</h1><h2 id="HiFi-reads（High-fidelity-reads）"><a href="#HiFi-reads（High-fidelity-reads）" class="headerlink" title="HiFi reads（High fidelity reads）"></a>HiFi reads（High fidelity reads）</h2><ul>
<li>是Sequel II 三代测序平台推出的兼顾长读长和高准确度的测序序列，一般采用CCS（Circular Consensus Sequencing）模式测序。在这种测序模式下，酶读长一般大于插入片段长度，因此酶会绕着模板进行滚环测序，插入片段会被多次测序。单次测序中造成的随机测序错误，可以通过算法进行自我纠错校正，最终得到高准确度的HiFi reads。</li>
<li>要在单次测序中得到更多的HiFi reads往往需要平衡测序的酶读长和插入片段的长度，插入片段太长会导致酶无法进行滚环测序，插入片段太短又牺牲了三代长读长测序的优势。因此HiFi模式测序对酶试剂和建库过程的均一性要求较高。</li>
</ul>
<h1 id="HiFi建库流程"><a href="#HiFi建库流程" class="headerlink" title="HiFi建库流程"></a>HiFi建库流程</h1><h2 id="PacBio-SMRT测序原理"><a href="#PacBio-SMRT测序原理" class="headerlink" title="PacBio SMRT测序原理"></a>PacBio SMRT测序原理</h2><ul>
<li><font face="微软雅黑" color="#9400D3" size="3">聚合酶捕获文库DNA序列，锚定在零模波导孔底部</font></li>
<li><font face="微软雅黑" color="#9400D3" size="3">4种不同荧光标记的dNTP随机进入零模波导孔底部</font></li>
<li><font face="微软雅黑" color="#9400D3" size="3">荧光dNTP被激光照射，发出荧光，检测荧光</font></li>
<li><font face="微软雅黑" color="#9400D3" size="3">荧光dNTP与DNA模板的碱基匹配，在酶的作用下合成一个碱基</font></li>
<li><font face="微软雅黑" color="#9400D3" size="3">统计荧光信号存在时间长短，区分匹配碱基与游离碱基，获得DNA序列</font></li>
<li><font face="微软雅黑" color="#9400D3" size="3">酶反应过程中，一方面使链延伸，另一方面使dNTP上的荧光基团脱落</font></li>
<li><font face="微软雅黑" color="#9400D3" size="3">聚合反应持续进行，测序同时持续进行</font></li>
</ul>
<p>以下为图示：</p>
<div align="center">
<img src="https://z3.ax1x.com/2021/01/18/scSZv9.png" height="300px" alt="SMRT cell"><img src="https://s3.ax1x.com/2021/01/18/scSE34.png" height="300px" alt="SEQUEL II">  
</div>

<h2 id="SMRT测序的两种模式"><a href="#SMRT测序的两种模式" class="headerlink" title="SMRT测序的两种模式"></a>SMRT测序的两种模式</h2><p>SMRT测序目前有CLR模式与CCS模式，从图片可以看出CLR是提高了序列长度但是没有兼顾准确度，而CCS模式的话既兼顾了长读长又有很好的准确度，我们通常将准确度大于99%（Q20）的read称为<font color="#FF0000">HiFi read</font></p>
<p><img src="https://z3.ax1x.com/2021/01/31/yEB5WD.png" alt="SMRT测序两种模式"></p>
<p>下面是CCS模式的具体流程，简单口述一下：<br>将一对高质量的DNA序列两端加上接头，之后在加入引物以及DNA聚合酶，在此模式下可进行滚环测序，即一对DNA序列被重复测序了多次之后去掉接头和多余的错误得到subreads，最后经过纠错得到HiFi READ </p>
<p><img src="https://z3.ax1x.com/2021/01/31/yEB7yd.png" alt="通过环状共有序列（CCS）生成 HIFI READS"></p>
<h1 id="HiFI组装实例"><a href="#HiFI组装实例" class="headerlink" title="HiFI组装实例"></a>HiFI组装实例</h1><p>首先我们可以看一下HIFI的应用，可以看出HIFI测序技术的出现，使得一些复杂有难度的植物基因组也可以通过测序得出较好的结果，下面主要针对最近的这几篇文章的思路入手，了解一下用与HiFi READ基因组组装的一些软件以及组装的大致流程</p>
<p><img src="https://z3.ax1x.com/2021/01/31/yEBTQH.png"></p>
<h2 id="水稻、果蝇和人类的基因组组装"><a href="#水稻、果蝇和人类的基因组组装" class="headerlink" title="水稻、果蝇和人类的基因组组装"></a>水稻、果蝇和人类的基因组组装</h2><p>下面的话是使用HIFI READS 生成连续，完整和准确的 DE NOVO 组装，分别是水稻、果蝇和人类的基因组组装结果展示，可以看到准确度达到了Q50</p>
<p><img src="https://z3.ax1x.com/2021/01/31/yEB4JO.png"></p>
<h2 id="六倍体加州红杉基因组"><a href="#六倍体加州红杉基因组" class="headerlink" title="六倍体加州红杉基因组"></a>六倍体加州红杉基因组</h2><p>PacBio的科学家利用HiFi测序在两周内完成了基因组高达27Gb的六倍体加州红杉基因组的组装，与以前使用其他技术的针叶树组装相比，使用 PacBio HiFi de novo 组装的加州红杉（Sequoia sempervirens）在3个C  (Contiguity, Completeness, and Correctness) 的基因组组装质量方面实现了显着的性能改善。<br>第一列为PacBio HiFi组装结果只用了6天，相比而言第二列的ONT+short reads组装（也就是目前大多采用的三代+二代组装的策略）花费的时间减少了很多！由于加州红杉为裸子植物而BUSCO评价完整度的参考大多为被子植物所以这个评价的结果不算高也正常。</p>
<p><img src="https://z3.ax1x.com/2021/01/31/yEBoSe.png" alt="加州红杉"></p>
<h2 id="紫花苜蓿基因组组装"><a href="#紫花苜蓿基因组组装" class="headerlink" title="紫花苜蓿基因组组装"></a>紫花苜蓿基因组组装</h2><p><font color="#0000FF">Published: 19 May 2020</font><br>（1）使用Canu默认参数，利用CCS clean reads组装contigs。组装得到的Contig N50值为459kb，总长度为3.15GB。<br>（2）使用HiC-Pro将Hi-C reads与contigs 进行比对，产生比对BAM文件。<br>（3）使用注释的蒺藜苜蓿蛋白作为参考，完全基于同源的策略注释contigs。对138,729个同源基因进行了结构注释。用MCscan用于鉴定contigs和参考基因组之间的共线性。显示紫花苜蓿和蒺藜苜蓿之间的高共线性。<br>（4）使用内部脚本处理BAM文件，去除等位基因contigs之间的links。使用ALLHiC软件，提取、聚类和重排Contigs (Contigs syntenic与蒺藜苜蓿染色体一致)，得到原始的scaffolds。<br>（5）Juicebox用于以图形和交互方式微调组装的scaffolds。剪裁了40个总长度达1800Mb的scaffolds 。<br>（6） 基于组装的scaffold，通过Hi-C数据，每个unplaced contig被分配到互作最强的那些contig cluster里。<br>（7）使用ALLHiC对那些contig clusters再次进行重排和构建scaffold。<br>（8）使用Juicebox对scaffolds进行微调，并从scaffolds上去除不一致的contigs，产生最终的染色体基因组，其包含32条染色体(8个同源组，每个组中有4个等位基因染色体)，总长度为2738Mb，和419Mb未挂载到染色体水平的序列。</p>
<div align="center">
<img src="https://z3.ax1x.com/2021/01/18/scSuHx.md.png" height="300px"><img src="https://s3.ax1x.com/2021/01/18/scSVgJ.md.png" height="300px">  
</div>

<h1 id="全基因组测序的组装流程"><a href="#全基因组测序的组装流程" class="headerlink" title="全基因组测序的组装流程"></a>全基因组测序的组装流程</h1><p>pb-assembly：内容包含各个falcon的流程，支持CLR/HiFi的组装，适合各种基因组的组装。<br>pbgcpp：支持CLR组装的纠错，纠错的raw reads必须是subreads.bam<br>第三方软件：<br>HiFi large genome：主要有HiCanu, Hifiasm, 以及Peregrine<br>CLR large genome：主要有Canu, wtdbg2<br>Small genome：主要有Flye, Canu</p>
<p><font size="5">下面主要介绍一下HiFi基因组组装目前推荐的软件:</font></p>
<h2 id="Hicanu"><a href="#Hicanu" class="headerlink" title="Hicanu"></a>Hicanu</h2><p><font color="#0000FF">Genome Research ( IF 11.093 ) Pub Date : 2020-09-01</font></p>
<ul>
<li>PacBio HiFi Reads结合HiCanu能够生成迄今为止最准确，最完整的人类基因组装配体，对基因组连续性、准确性、单倍型检测以及应对复杂片段重复序列均有提升</li>
<li>HiCanu（Canu专门针对PacBio HiFi Reads优化了组装流程），通过均聚物压缩，基于overlap的纠错和false overlap过滤来充分利用HiFi reads的全部潜能</li>
<li>使用30X PacBio HiFi Reads通过HiCanu将人CHM13细胞系的基因组组装的ContigN50提升至77M，单碱基准确性超过99.999%（Q50），在组装的准确性和连续性这两个方面，PacBio HiFi Reads的组装结果都超过了最新的高覆盖度超长牛津纳米孔测序的结果。</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/01/31/yEBWo6.png"></p>
<h2 id="HiFiasm"><a href="#HiFiasm" class="headerlink" title="HiFiasm"></a>HiFiasm</h2><p><font color="#0000FF">Pub Date : 2020-08-03</font></p>
<h3 id="可识别单倍型的纠错"><a href="#可识别单倍型的纠错" class="headerlink" title="可识别单倍型的纠错"></a>可识别单倍型的纠错</h3><p>Hifiasm会将所有的hifi reads读取到内存中进行all-vs-all比对并进行纠错。基于reads间的overlap信息，如果read上有一个碱基与其他碱基不同，并有至少3条reads支持，则认为它是SNP并保留，否则认为是错误并进行纠正。</p>
<h3 id="组装图的构建"><a href="#组装图的构建" class="headerlink" title="组装图的构建"></a>组装图的构建</h3><p>在校正之后，大多数错误被去除，同时杂合变异信息被保留。基于这些信息，Hifiasm构建了以reads为顶点、重叠区为边的定相string-graph。</p>
<h3 id="组装序列的生成"><a href="#组装序列的生成" class="headerlink" title="组装序列的生成"></a>组装序列的生成</h3><p>如果没有其他数据，Hifiasm在输出序列时会任意选择每个气泡的一侧输出类似Falcon unzip和HiCanu的主要组装结果（primary contigs）。如果同时有父母本的测序数据，Hifiasm可以通过亲本特有的kmer在图上识别出来自父母本的序列，从而得到两套单倍体基因组。<br><font color="#FF0000">当然HiFiasm文章中也提到了：</font></p>
<ul>
<li>与其他基于图形的汇编程序不同，HiFiasm致力于保持所有单倍型的连续性。</li>
<li>HiCanu只试图保持一个亲本单倍型的连续性，并且经常破坏另一个单倍型的连续性，当分离亲本单倍型时，这些突变点将导致单倍型分解的碎片—HiCanu没有充分利用HiFi Reads </li>
<li>Hifiasm针对HiFi特点而开发，在hifi数据的组装表现上较同类软件更为突出，在多个基因组上表现出了更高的准确性和组装的连续性。</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/01/31/yEBhFK.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font face="微软雅黑" color="#FF0000" size="6">No genome too large for HiFi reads.</font></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Chen H ,  Zeng Y ,  Yang Y , et al. Allele-aware chromosome-level genome assembly and efficient transgene-free genome editing for the autotetraploid cultivated alfalfa[J]. Nature Communications, 2020, 11(1).<br>[2] Sequencing technologies — the next generation.[J]. Nature Reviews Genetics, 2010.<br>Korlach J ,  Bjornson K P ,  Chaudhuri B P , et al. Real-Time DNA Sequencing from Single Polymerase Molecules[J]. Methods in enzymology, 2010, 472:431-455.<br>[3] Cheng H, Concepcion G T, Feng X, et al. Haplotype-resolved de novo assembly with phased assembly graphs. arXiv 2020[J]. arXiv preprint arXiv:2008.01237, 2008.<br>[4] Nurk S, Walenz B P, Rhie A, et al. HiCanu: accurate assembly of segmental duplications, satellites, and allelic variants from high-fidelity long reads[J]. BioRxiv, 2020.<br>[5] Wenger A M, Peluso P, Rowell W J, et al. Highly-accurate long-read sequencing improves variant detection and assembly of a human genome. bioRxiv[J]. Preprint]. doi, 2019, 10: 519025.<br>[6] Lang D, Zhang S, Ren P, et al. Comparison of the two up-to-date sequencing technologies for genome assembly: HiFi reads of Pacbio Sequel II system and ultralong reads of Oxford Nanopore[J]. bioRxiv, 2020.<br>[7] Wenger A M, Peluso P, Rowell W J, et al. Accurate circular consensus long-read sequencing improves variant detection and assembly of a human genome[J]. Nature biotechnology, 2019, 37(10): 1155-1162.<br>[8] Sun X, Jiao C, Schwaninger H, et al. Phased diploid genome assemblies and pan-genomes provide insights into the genetic history of apple domestication[J]. Nature genetics, 2020, 52(12): 1423-1432.</p>
<a class="btn-beautify button--animated purple larger" href="https://lixingze.xyz" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>基因组组装</category>
      </categories>
      <tags>
        <tag>HiFi reads</tag>
        <tag>基因组组装 - HiFiasm - HiCanu</tag>
      </tags>
  </entry>
  <entry>
    <title>HiC-Pro的使用 ｜ HiC辅助基因组组装（一）</title>
    <url>/2021/07/18/HiC-Pro/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><div class="note pink no-icon flat"><p>之前的文章中有介绍过，HiC常用的几款软件的原理内容。可以<a href="https://lxz9.com/2021/04/03/HiC/">点击链接访问了解一下</a><br>在这里不做赘述。</p>
</div>

<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h2><p>建议使用目前最新的3.0.0版本（需要root权限）<br>安装方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建conda环境</span></span><br><span class="line">conda create -y -n hic-pro python=3.7 pysam bx-python numpy scipy samtools bowtie2 iced</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载HiC-Pro最新版本</span></span><br><span class="line">wget https://hub.fastgit.org/nservant/HiC-Pro/archive/refs/tags/v3.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxf v3.0.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> HiC-Pro-3.0.0/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h2><p>如果新版本不适应可以使用旧版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install -c davebx hicpro</span><br></pre></td></tr></table></figure>
<p>其他安装方法参考官方</p>
<h1 id="软件操作流程"><a href="#软件操作流程" class="headerlink" title="软件操作流程"></a>软件操作流程</h1><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><ol>
<li>将Hi-C数据放入对应以样品名命名的目录下。<br>(注意文件夹名、<em>_R1.fastq.gz.</em>_R2.fastq.gz)</li>
</ol>
<ol start="2">
<li>基因组组装结果文件<br>ln -s PATH=your_assembly.fasta genome.fa</li>
</ol>
<h2 id="必备文件1-基因组bowtie2索引"><a href="#必备文件1-基因组bowtie2索引" class="headerlink" title="必备文件1-基因组bowtie2索引"></a>必备文件1-基因组bowtie2索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bowtie2-build genome.fa genome</span><br></pre></td></tr></table></figure>
<h2 id="酶切片段文件"><a href="#酶切片段文件" class="headerlink" title="酶切片段文件"></a>酶切片段文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;HiC-Pro-3.0.0&#x2F;bin&#x2F;utils&#x2F;digest_genome.py genome.fa -r dpnii -o genome_dpnii.bed</span><br></pre></td></tr></table></figure>
<h2 id="基因组中序列大小文件"><a href="#基因组中序列大小文件" class="headerlink" title="基因组中序列大小文件"></a>基因组中序列大小文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">samtools faidx genome.fa</span><br><span class="line">awk &#39;&#123;print $1&quot;\t&quot; $2&#125;&#39; genome.fa.fai &gt;genome.sizes</span><br></pre></td></tr></table></figure>
<h2 id="运行hic-pro"><a href="#运行hic-pro" class="headerlink" title="运行hic-pro"></a>运行hic-pro</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HiC-Pro -c config-hicpro.txt -o analysis -i data</span><br></pre></td></tr></table></figure>
<h3 id="config-hicpro-txt-配置"><a href="#config-hicpro-txt-配置" class="headerlink" title="config-hicpro.txt 配置"></a>config-hicpro.txt 配置</h3><p>其中没有提到的建议使用默认数据操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## SYSTEM AND SCHEDULER - Start Editing Here !!</span></span><br><span class="line"></span><br><span class="line">N_CPU = 50  <span class="comment">#CPU线程数</span></span><br><span class="line">LOGFILE = hicpro.log  <span class="comment">#log文件名</span></span><br><span class="line"></span><br><span class="line">JOB_NAME = sample  <span class="comment">#任务名</span></span><br><span class="line">JOB_MEM = 100gb  <span class="comment">#占用内存</span></span><br><span class="line">JOB_WALLTIME = </span><br><span class="line">JOB_QUEUE = </span><br><span class="line">JOB_MAIL = </span><br><span class="line"></span><br><span class="line">PAIR1_EXT = _R1</span><br><span class="line">PAIR2_EXT = _R2</span><br><span class="line"></span><br><span class="line">BOWTIE2_IDX_PATH = /home/lixingze/XHS-Analysis/HiC-Pro/reads <span class="comment">#比对的reads文件目录</span></span><br><span class="line">BOWTIE2_GLOBAL_OPTIONS = --very-sensitive -L 30 --score-min L,-0.6,-0.2 --end-to-end --reorder</span><br><span class="line">BOWTIE2_LOCAL_OPTIONS =  --very-sensitive -L 20 --score-min L,-0.6,-0.2 --end-to-end --reorder</span><br><span class="line"></span><br><span class="line">GENOME_SIZE = /home/lixingze/XHS-Analysis/HiC-Pro/reads/genome.sizes <span class="comment">#genome.sizes的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Digestion Hi-C</span></span><br><span class="line"></span><br><span class="line">GENOME_FRAGMENT = /home/lixingze/XHS-Analysis/HiC-Pro/reads/genome_dpnii.bed <span class="comment">#绝对路径</span></span><br><span class="line">LIGATION_SITE = GATCGATC <span class="comment">#限制性内切酶，具体用的什么酶可以咨询测序公司，我这里用的dnp II</span></span><br><span class="line">MIN_FRAG_SIZE = 100</span><br><span class="line">MAX_FRAG_SIZE = 100000</span><br><span class="line">MIN_INSERT_SIZE = 100</span><br><span class="line">MAX_INSERT_SIZE = 1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Contact Maps</span></span><br><span class="line"></span><br><span class="line">BIN_SIZE = 20000 40000 150000 500000 1000000 <span class="comment">#根据自身需求设置 bin size</span></span><br><span class="line">MATRIX_FORMAT = upper</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="hic-result-matrix目录"><a href="#hic-result-matrix目录" class="headerlink" title="hic_result/matrix目录"></a>hic_result/matrix目录</h2><blockquote>
<p>data:存放validpair及其他无效数据文件matrix:存放不同分辨率矩阵文件,<br>分为raw和iced文件，raw:原始矩阵iced:ice校正后的矩阵后续分析使用，<br>可以使用HiCPlotter、HiCExplorer出图，或者进行三维基因组学中的部分分析。</p>
</blockquote>
<blockquote>
<p>pic:存放统计结果图片</p>
</blockquote>
<blockquote>
<p>stats:存放统计表</p>
</blockquote>
<h2 id="hic-result-data目录"><a href="#hic-result-data目录" class="headerlink" title="hic_result/data目录"></a>hic_result/data目录</h2><blockquote>
<p>allVaildPairs:合并后的valid pairs数据<br>DEPairs: Dangling end pairs数据<br>DumpPairs:实际片段长度和理论片段长度不同的数据REPairs:酶切片段重新连接的pairs<br>FiltPairs:基于min/max insert/fragment size过滤的pairsSCPairs:片段自连的pairs</p>
</blockquote>
<h2 id="hic-result-pic目录"><a href="#hic-result-pic目录" class="headerlink" title="hic_result/pic目录"></a>hic_result/pic目录</h2><blockquote>
<p>plotHiCContactRanges_Example1.pdf有效互作中各类型比例图</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/07/18/W8V1vn.png" alt="plotHiCContactRanges"></p>
<blockquote>
<p>plotHiCFragmentSize_Example1.pdf有效互作的片段大小分布图</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/07/18/W8VtET.png" alt="plotHiCFragmentSize"></p>
<blockquote>
<p>plotMappingPairing_Example1.pd合并后双端比对过滤结果图</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/07/18/W8VGD0.png" alt="plotMappingPairing">]</p>
<blockquote>
<p>plotHiCFragment_Example1.pdf有效数据过滤结果图</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/07/18/W8VJbV.png" alt="plotHiCFragment"></p>
<blockquote>
<p>plotMapping_Example1.pdf单端比对过滤结果图</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/07/18/W8V8uq.png" alt="plotMapping"></p>
<h1 id="HiC-Pro易报错的地方总结"><a href="#HiC-Pro易报错的地方总结" class="headerlink" title="HiC-Pro易报错的地方总结"></a>HiC-Pro易报错的地方总结</h1><ol>
<li>错误一</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exit: Error: Directory Hierarchy of rawdata &#39;&#x2F;home&#x2F;lixingze&#x2F;data&#x2F;HiC&#x2F;hicpro&#x2F;data&#39; is not correct. No &#39;.fastq(.gz)&#39; files detected</span><br></pre></td></tr></table></figure>
<p>整理reads目录结构<br>注意：这里在HiCPro的源码中只会读入指定目录的子目录的文件 ,所以将hic测序数据放在子目录下即可</p>
<ol start="2">
<li>错误二</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pairing of R1 and R2 tags ...</span><br><span class="line">Logs: logs&#x2F;fastq&#x2F;mergeSAM.log</span><br><span class="line">make: *** [&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;HiC-Pro-3.0.0&#x2F;bin&#x2F;..&#x2F;scripts&#x2F;&#x2F;Makefile:144: bowtie_pairing] Error 1</span><br></pre></td></tr></table></figure>
<p>原因可能是之前的bowtie2索引数据有问题造成的，重新跑一次。</p>
<ol start="3">
<li>总结</li>
</ol>
<p>不同的报错内容很大程度是个人和环境的原因，所以因人而异，不具有普适性</p>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
      <tags>
        <tag>HiC</tag>
        <tag>教程</tag>
        <tag>HiC-Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>Hi-C辅助基因组组装原理｜主流软件</title>
    <url>/2021/04/03/HiC/</url>
    <content><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a><font face="微软雅黑" color="#000080" size="5">导语</font></h1><ul>
<li><p>Hi-C是高通量染色体构象捕获（High-throughput Chromosome Conformation Capture, Hi-C）技术的简称，开发于2009年，最初用于捕获全基因组范围内所有的染色质内和染色质间的空间互作信息，目前已应用于基因表达的空间调控机制研究、构建染色体水平参考基因组、构建单体型图谱等。</p>
</li>
<li><p>Hi-C技术源于染色体构象捕获（Chromosome Conformation Capture, 3C）技术，利用高通量测序技术，结合生物信息分析方法，研究全基因组范围内整个染色质DNA在空间位置上的关系，获得高分辨率的染色质三维结构信息。Hi-C技术不仅可以研究染色体片段之间的相互作用，建立基因组折叠模型，还可以应用于基因组组装、单体型图谱构建、辅助宏基因组组装等，并可以与RNA-Seq、ChIP-Seq等数据进行联合分析，从基因调控网络和表观遗传网络来阐述生物体性状形成的相关机制。</p>
</li>
</ul>
<h1 id="3C，4C，5C以及HiC测序技术"><a href="#3C，4C，5C以及HiC测序技术" class="headerlink" title="3C，4C，5C以及HiC测序技术"></a><font face="微软雅黑" color="#000080" size="5">3C，4C，5C以及HiC测序技术</font></h1><p><img src="https://z3.ax1x.com/2021/04/03/cuCvfP.jpg" alt="3C，4C，5C"></p>
<h2 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h2><div class="note purple no-icon flat"><p>染色质构象捕获（3C）技术是用福尔马林瞬时固定细胞核染色质，用过量的限制性内切酶酶切消化染色质 - 蛋白质交联物，在 DNA 浓度极低而连接酶浓度极高的条件下用连接酶连接消化物，蛋白酶 K 消化交联物以释放出结合的蛋白质，用推测可能有互作的目的片段的引物进行普通PCR和定量PCR来确定是否存在相互作用。3C 技术假定物理上互作的 DNA 片段连接频率最高，以基因座特异性 PCR 来检测基因组中 DNA 片段之间的物理接触，最终以 PCR 产物的丰度来确定是否存在相互作用。</p>
</div>
<p><strong>3C，可以验证1个点与1个点的相互作用，每1对相互作用需要1对引物</strong></p>
<h2 id="4C"><a href="#4C" class="headerlink" title="4C"></a>4C</h2><div class="note purple no-icon flat"><p>4C 技术称环状染色质构象捕获 （circular chromosome conformation capture） 或芯片染色质构象捕获（chromosome conformation capture-on-chip），特点就是对于酶切下来的片段进行环化，然后用反向PCR从已知区域开始扩增出环状的部分。然后用芯片进行序列分析。此时做PCR，我们不需要知道序列两端的信息，只需要知道一段的信息。</p>
</div>
<p><strong>4C技术，可以验证1个点与多个点的相互作用，因为根据这1个点设计，关键步骤是成环。</strong></p>
<h2 id="5C"><a href="#5C" class="headerlink" title="5C"></a>5C</h2><div class="note purple no-icon flat"><p>若研究几百个染色质片段之间可能存在的相互作用，使用3C技术需要设计大量PCR引物来确定已知片段与假定片段的关系，通量较低，较难实现。因此，人们设计出3C碳拷贝（3C-carbon copy，5C）技术，这个技术是基于3C的基本原理，结合连接介导的扩增 （ligation-mediated amplification，LMA）来增加3C检测的通量。以3C酶切连接文库为模板 ，在3C引物端加上通用接头（例如T7、T3），例如在正向引物（bait）的5’端加上T7接头，在反向引物的3’端加上T3接头，若两个推测片段存在相互连接，由于连接酶介导的连接作用的性质，只有连接上的片段才有扩增。 这样，利用通用引物T7、T3进行PCR，而后将产物进行高通量测序即可实现高通量的3C实验。</p>
</div>

<h2 id="HiC"><a href="#HiC" class="headerlink" title="HiC"></a>HiC</h2><div class="note purple no-icon flat"><p>是在3C的基础上，在酶切后将缺口进行补平（dCTP 进行生物素标记），然后用连接酶进行连接，将样本进行超声破碎，随后用生物素亲和层析将片段沉淀（也就是抓下来带有生物素标记的片段），加上接头进行深度测序。</p>
</div>
<p><strong>Hi-C，获得all-to-all的互作关系</strong></p>
<ul>
<li>具体如下图介绍：<br><img src="https://z3.ax1x.com/2021/04/03/cuCfF1.png" alt="cuCfF1.png"></li>
</ul>
<h1 id="Hi-C辅助组装实验流程"><a href="#Hi-C辅助组装实验流程" class="headerlink" title="Hi-C辅助组装实验流程"></a>Hi-C辅助组装实验流程</h1><blockquote>
<p>利用甲醛对样本进行交联，质检合格后使用限制性内切酶（如MboI等）进行酶切，酶切片段经生物素标记、平末端连接、DNA纯化提取，超声打断后钓取含有生物素的片段，进行建库测序。</p>
</blockquote>
<blockquote>
<p>随后，对原始下机数据进行质控，并将质控截取后的Clean reads与参考基因组比对，获得用于互作分析的Valid reads。由于Hi-C文库的构建具有一定的复杂性，在实际的项目执行过程中，会先通过对小规模的测序数据进行评估，以检测所构建文库的质量。小数据评估合格后，启动大数据的上机测序，以保证测序数据的质量。</p>
</blockquote>
<h1 id="Hi-C技术的大致流程"><a href="#Hi-C技术的大致流程" class="headerlink" title="Hi-C技术的大致流程"></a>Hi-C技术的大致流程</h1><ol>
<li><p>通过甲醛交联固定，将细胞内由蛋白质介导的空间上邻近的染色质片段进行共价连接。</p>
</li>
<li><p>限制性内切酶进行酶切</p>
</li>
<li><p>使用生物素标记末端标记</p>
</li>
<li><p>将连接的DNA纯化后超声打断，并用生物素亲和层析，将生物素化的DNA片段分离，加上接头进行高通量测序</p>
</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/04/03/cuC2w9.png" alt="Hi-C技术的大致流程"></p>
<h1 id="Hi-C互作三大规律"><a href="#Hi-C互作三大规律" class="headerlink" title="Hi-C互作三大规律"></a>Hi-C互作三大规律</h1><p>1.染色体内互作富集<br>2.互作随距离衰减<br>3.局部互作平滑<br>可以通过以上三个规律来判断组装的好坏</p>
<p><img src="https://z3.ax1x.com/2021/04/03/cuP9Og.png" alt="Hi-C互作三大规律"></p>
<h1 id="Hi-C建库测序流程"><a href="#Hi-C建库测序流程" class="headerlink" title="Hi-C建库测序流程"></a>Hi-C建库测序流程</h1><p><img src="https://z3.ax1x.com/2021/04/03/cuCzSf.jpg" alt="Hi-C建库测序流程"></p>
<ol>
<li><p>DNA样品检测<br>(1) 琼脂糖凝胶电泳分析DNA降解程度以及是否有污染<br>(2) Nanodrop检测DNA的纯度（OD260/280比值）<br>(3) Qubit对DNA浓度进行精确定量</p>
</li>
<li><p>文库构建<br>检测合格的DNA样品通过Covaris超声波破碎仪随机打断，经末端修复、加A尾、加测序接头、纯化、PCR扩增等步骤完成整个文库制备。文库构建原理图如下:</p>
</li>
<li><p>库检<br>(1) Agilent 2100检测文库DNA片段的完整性及插入片段大小。<br>(2) QPCR及QPCR检测文库有效浓度。<br>检测合格后进行下一步上机测序。</p>
</li>
<li><p>上机测序<br>库检合格后，把不同文库按照有效浓度及目标下机数据量的需求pooling后进行Illumina测序。</p>
</li>
</ol>
<h1 id="Hi-C组装软件"><a href="#Hi-C组装软件" class="headerlink" title="Hi-C组装软件"></a>Hi-C组装软件</h1><p>在组装基因组时，使用二代或三代数据组装到contigs后，下一步就是将contig提升到染色体水平。利用HiC数据目前常见的组装软件有下面几个：</p>
<blockquote>
<p>HiRise: 2015年后的GitHub就不再更新<br>LACHESIS: 发表在NBT，2017年后不再更新<br>SALSA: 发表在BMC genomics, 仍在更新中<br>3D-DNA: 发表在science，仍在更新中<br>ALLHiC: 发表在Nature Plants, 用于解决植物多倍体组装问题<br>HiC-Pro：发表在FGenome Biology</p>
</blockquote>
<h2 id="LACHESIS"><a href="#LACHESIS" class="headerlink" title="LACHESIS"></a><a href="https://github.com/shendurelab/LACHESIS">LACHESIS</a></h2><div class="note pink no-icon flat"><p>LACHESIS的工作分为三个步骤：<br>第一步，将contigs或支架聚集到染色体组；<br>第二步，在每个染色体组内排列contigs或支架；<br>最后，分配相对位置</p>
</div>

<p><img src="https://z3.ax1x.com/2021/04/03/cuPp6S.png" alt="LACHESIS"></p>
<ol>
<li><p>输入包括一组来自草稿装配的contigs (or scaffolds) 和一组全基因组染色质相互作用数据，例如Hi-C links。</p>
</li>
<li><p>与不同染色体上的contigs相比，同一染色体上的contigs之间往往有更多的Hi-C links。LACHESIS利用这一点将contigs聚集成与个体染色体基本一致的群体。</p>
</li>
<li><p>在一条染色体内，近在咫尺的contigs往往比相距遥远的contigs有更多的联系。LACHESIS利用这一点来排列每个染色体组内的contigs。</p>
</li>
<li><p>最后，LACHESIS利用相邻contigs之间连接的精确位置来预测每个contigs的相对方向。</p>
</li>
</ol>
<div class="note pink no-icon flat"><p>LACHESIS的输入包括一组contigs or scaffolds以及一组全基因组染色质相互作用数据集<br>在第一步中，LACHESIS利用Hi­C数据集中染色体内接触平均比染色体间接触更可能的事实，利用层次聚集聚类对可能来自同一染色体的contigs进行分组。该聚类使用平均连锁度量，连锁定义为连接任何给定一对重叠的Hi-C读对的标准化密度。groups的最终数目是预先指定的，理想情况下设置为预期的染色体数目。</p>
<p>在第二步中，LACHESIS利用较高的Hi-C links，在每个染色体组内线性排列重叠序列。对于每个染色体组，用表示重叠的顶点和对应于重叠对之间偶合对之间的标准化Hi­C连锁密度构建一个图。</p>
<p>在第三步中，通过精确地计算Hi-C在每个contigs上的位置，确定contigs的方向。<br>For each chromosome group, a weighted, directed, acyclic graph is built representing all possible ways to orient the contigs, given the predicted order.</p>
</div>

<h2 id="HiC-Pro"><a href="#HiC-Pro" class="headerlink" title="HiC-Pro"></a>HiC-Pro</h2><p><a href="https://github.com/nservant/HiC-Pro">HiC-Pro</a>是一款高效的Hi-C数据分析软件，提供了从原始数据到归一化之后的HI-C图谱构建的完整功能，运行效率高，用法简便。<br>完整的pipeline如下图所示：</p>
<p><img src="https://z3.ax1x.com/2021/04/03/cuCRoR.png" alt="HiC-Pro"></p>
<div class="note orange no-icon flat"><p>与HiCUP一样，HiCPro也是将中R1与R2分开比对，再合并过滤酶切片段，获取valid pairs 红色方框标记的是数据预处理部分，包括序列比对和筛选valid pairs；预处理之后就是binning, 构建不同分辨率下的原始的交互矩阵contact map,  最后对原始的contact map进行归一化处理，得到校正后的contact map。</p>
</div>
<p>其具体上机使用方法可以参考<a href="http://blog.sciencenet.cn/blog-2970729-1182259.html">链接</a></p>
<h3 id="序列比对"><a href="#序列比对" class="headerlink" title="序列比对"></a>序列比对</h3><div class="note orange no-icon flat"><p>对首先使用end-to-end algorithm将R1和R2分别与基因组进行比对。对于Unmapped Reads可能是存在连接点的嵌合体reads, 也可能本身就是unmapping reads,在第一步中没有对齐的reads在连接位点被修剪，它们的5′端在基因组上被重新对齐。在这两个步骤之后的所有对齐读数都用于进一步分析。如A图所示</p>
</div>

<h3 id="筛选Valid-pairs"><a href="#筛选Valid-pairs" class="headerlink" title="筛选Valid pairs"></a>筛选Valid pairs</h3><div class="note orange no-icon flat"><p>比对时将R1和R2端分开单独考虑，但是二者其实来自于同一个fragment, 这一步的筛选其实是能够代表染色质交互的有效fragment，这样的fragment肯定是一个嵌合体序列，有来自交互作用的两个染色质区域的序列构成，只有来自嵌合体fragment的reads才被定义为valid pairs, 然后进行后续分析。如B图所示</p>
</div>

<p><img src="https://z3.ax1x.com/2021/04/03/cuCTyD.png" alt="HiC-Pro2"></p>
<h3 id="构建原始Hi-C图谱"><a href="#构建原始Hi-C图谱" class="headerlink" title="构建原始Hi-C图谱"></a>构建原始Hi-C图谱</h3><p>根据指定的分辨率，统计两个bin区域内valid  pairs的数目, 去除PCR重复之后，构建原始的交互矩阵。</p>
<h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><p>不同区域GC含量，mapping概率等系统误差都使得原始的交互矩阵不能够有效代表染色质交互信息， 所以需要进行归一化。采用了一种迭代校正的归一化算法对原始的交互矩阵进行归一化，矫正系统误差。</p>
<h2 id="ALLHiC"><a href="#ALLHiC" class="headerlink" title="ALLHiC"></a>ALLHiC</h2><p><a href="https://github.com/tangerzhang/ALLHiC">ALLHiC</a>一共分为五步:pruning, partition, rescue, optimization, building</p>
<ol>
<li><p><strong>prune</strong> 步骤去除了等位基因之间的联系，因此同源染色体更易于单独分离。</p>
</li>
<li><p><strong>partition</strong> 功能将修剪的bam文件作为输入，并根据Hi-C建议的链接对链接的contigs进行聚类，大概是沿着相同同源染色体在预设数量的分区中进行。</p>
</li>
<li><p><strong>rescue</strong> 功能从原始未修剪的bam文件中搜索分区步骤中不涉及的contigs，并根据Hi-C信号密度将它们分配给特定的群集。</p>
</li>
<li><p><strong>optimize</strong> 步骤采用每个分区，并优化所有contigs的顺序和方向。</p>
</li>
<li><p><strong>build</strong> 步骤通过连接contigs来重建每个染色体</p>
</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://z3.ax1x.com/2021/04/03/cuChJx.png" alt="ALLHiC">]</p>
<h3 id="Explanation-of-Prune"><a href="#Explanation-of-Prune" class="headerlink" title="Explanation of Prune"></a>Explanation of Prune</h3><ol>
<li><p>同源四倍体基因组的示意图。四个同源染色体显示为不同的颜色（分别为<font color="#0000FF">蓝色</font>，<font color="#FF8C00">橙色</font>，<font color="#008000">绿色</font>和<font color="#9400D3">紫色</font>）​​。染色体中的<font color="#FF0000">红色</font>区域表示具有高度相似性的序列。</p>
</li>
<li><p>检测自身四倍体基因组中的Hi-C信号。黑色虚线表示折叠区域和未折叠区域contigs之间的Hi-C信号。<font color="#FF69B4">粉色</font>虚线表示单体型Hi-C链接，<font color="#808080">灰色</font>虚线表示单体型Hi-C链接。在组装过程中，<font color="#FF0000">红色</font>区域会因高度的序列相似性而崩溃；同时，如果其他区域之间存在大量差异，则会将它们分为不同的contigs。由于塌陷区域与来自不同单倍型的contigs在物理上相关，因此将在塌陷区域与所有其他未塌陷的contigs之间检测到Hi-C信号。</p>
</li>
<li><p>传统的Hi-C脚手架方法将检测来自不同单倍型和折叠区域的contigs中的信号，并将所有序列聚在一起。</p>
</li>
<li><p>修剪Hi-C信号：1-去除等位基因区域之间的信号；2-仅在折叠区域和未折叠contigs之间保留最强的信号。</p>
</li>
<li><p>基于修剪的Hi-C信息进行分区。理想情况下，根据修剪结果将contigs分为不同的组。</p>
</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/04/03/cuCXFI.png" alt="Prune"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Burton, J., Adey, A., Patwardhan, R. et al. Chromosome-scale scaffolding of de novo genome assemblies based on chromatin interactions. Nat Biotechnol 31, 1119–1125 (2013).</p>
<p>[2] Servant N, Varoquaux N, Lajoie B R, et al. HiC-Pro: an optimized and flexible pipeline for Hi-C data processing[J]. Genome biology, 2015, 16(1): 1-11.</p>
<p>[3] Lieberman-Aiden E, Van Berkum N L, Williams L, et al. Comprehensive mapping of long-range interactions reveals folding principles of the human genome[J]. science, 2009, 326(5950): 289-293.</p>
<p>[4] Ghurye J, Rhie A, Walenz B P, et al. Integrating Hi-C links with assembly graphs for chromosome-scale assembly[J]. PLoS computational biology, 2019, 15(8): e1007273.</p>
<p>[5] Dudchenko O, Batra S S, Omer A D, et al. De novo assembly of the Aedes aegypti genome using Hi-C yields chromosome-length scaffolds[J]. Science, 2017, 356(6333): 92-95.</p>
<p>[6] Zhang X, Zhang S, Zhao Q, et al. Assembly of allele-aware, chromosomal-scale autopolyploid genomes based on Hi-C data[J]. Nature plants, 2019, 5(8): 833-845.</p>
<p>[7] Durand N C, Shamim M S, Machol I, et al. Juicer provides a one-click system for analyzing loop-resolution Hi-C experiments[J]. Cell systems, 2016, 3(1): 95-98.</p>
<p>[8] Wu S, Turner K M, Nguyen N, et al. Circular ecDNA promotes accessible chromatin and high oncogene expression[J]. Nature, 2019, 575(7784): 699-703.</p>
<p>[9] Oddes S, Zelig A, Kaplan N. Three invariant Hi-C interaction patterns: applications to genome assembly[J]. Methods, 2018, 142: 89-99.</p>
<p>[10] Zhang, J. Zhang, X. Tang, H. Zhang, Q. et al. Allele-defined genome of the autopolyploid sugarcane Saccharum spontaneum L. Nature Genetics, doi:10.1038/s41588-018-0237-2 (2018).</p>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>ALLHIC</tag>
        <tag>HiC-Pro</tag>
        <tag>Hi-C</tag>
        <tag>LACHESIS</tag>
      </tags>
  </entry>
  <entry>
    <title>JGI Phytozome 批量下载的几种方法</title>
    <url>/2021/08/05/JGI/</url>
    <content><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="登陆账号"><a href="#登陆账号" class="headerlink" title="登陆账号"></a>登陆账号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&#x27;https://signon.jgi.doe.gov/signon/create&#x27;</span> --data-urlencode <span class="string">&#x27;login=*****&#x27;</span> --data-urlencode <span class="string">&#x27;password=*****&#x27;</span> -c cookies &gt; /dev/null</span><br><span class="line"><span class="comment"># ****处修改为账号与密码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="下载所有文件的列表"><a href="#下载所有文件的列表" class="headerlink" title="下载所有文件的列表"></a>下载所有文件的列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &#39;https:&#x2F;&#x2F;genome.jgi.doe.gov&#x2F;portal&#x2F;ext-api&#x2F;downloads&#x2F;get-directory?organism&#x3D;PhytozomeV12&#39; -b cookies &gt; files.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;genome.jgi.doe.gov</span><br></pre></td></tr></table></figure>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><blockquote>
<p>files.xml文件里记录每个文件的大小、存放路径、md5、类型等<br>比如下面记录的是拟南芥的cds序列文件，其中的url=” “中的内容提取出来，”&amp;“替换为”&amp;”，前面加上网站<a href="https://genome.jgi.doe.gov,用curl下载(记得指定cookie文件)./">https://genome.jgi.doe.gov，用curl下载（记得指定cookie文件）。</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;file label=“PhytozomeV12” filename=“Athaliana_167_TAIR10.cds_primaryTranscriptOnly.fa.gz” size=“10 MB” sizeInBytes=“11041833” timestamp=“Wed Jan 08 16:38:08 PST 2014” url=<span class="string">&quot;/portal/ext-api/downloads/get_tape_file?blocking=true&amp;amp;url=/PhytozomeV12/download/_JAMO/585474407ded5e78cff8c47a/Athaliana_167_TAIR10.cds_primaryTranscriptOnly.fa.gz&quot;</span> project=<span class="string">&quot;&quot;</span> library=<span class="string">&quot;&quot;</span> md5=“6085fd39ad3327c727838f9da4f4b222” fileType=“Assembly” /&gt;</span><br></pre></td></tr></table></figure>
<div class="note purple no-icon flat"><p>下面是测试下载拟南芥的数据文件，对于批量下载来讲还是比较麻烦的，可以查看files.xml文件，<br>将这些curl 放到一个bash文件里也可以实现批量下载。</p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&#x27;https://genome.jgi.doe.gov/portal/ext-api/downloads/get_tape_file?blocking=true&amp;url=/PhytozomeV12/download/_JAMO/585474407ded5e78cff8c47a/Athaliana_167_TAIR10.cds_primaryTranscriptOnly.fa.gz&#x27;</span> -b cookies &gt; Athaliana_167_TAIR10.cds_primaryTranscriptOnly.fa.gz</span><br><span class="line"></span><br><span class="line">curl <span class="string">&#x27;https://genome.jgi.doe.gov/portal/ext-api/downloads/get_tape_file?blocking=true&amp;url=/PhytozomeV12/download/_JAMO/587b0adf7ded5e4229d885ab/Athaliana_447_TAIR10.fa.gz&#x27;</span> -b cookies &gt; Athaliana_447_TAIR10.fa.gz</span><br><span class="line"></span><br><span class="line">curl <span class="string">&#x27;https://genome.jgi.doe.gov/portal/ext-api/downloads/get_tape_file?blocking=true&amp;url=/PhytozomeV12/download/_JAMO/587b0ade7ded5e4229d885aa/Athaliana_447_Araport11.protein_primaryTranscriptOnly.fa.gz&#x27;</span> -b cookies &gt; Athaliana_447_Araport11.protein_primaryTranscriptOnly.fa.gz</span><br><span class="line"></span><br><span class="line">curl <span class="string">&#x27;https://genome.jgi.doe.gov/portal/ext-api/downloads/get_tape_file?blocking=true&amp;url=/PhytozomeV12/download/_JAMO/587b0ade7ded5e4229d885a8/Athaliana_447_Araport11.gene.gff3.gz&#x27;</span> -b cookies &gt; Athaliana_447_Araport11.gene.gff3.gz</span><br><span class="line"></span><br><span class="line">curl <span class="string">&#x27;https://genome.jgi.doe.gov/portal/ext-api/downloads/get_tape_file?blocking=true&amp;url=/PhytozomeV12/download/_JAMO/587b0adb7ded5e4229d885a1/Athaliana_447_Araport11.cds_primaryTranscriptOnly.fa.gz&#x27;</span> -b cookies &gt; Athaliana_447_Araport11.cds_primaryTranscriptOnly.fa.gz</span><br></pre></td></tr></table></figure>
<h1 id="方法二-Get-JGI-Genomes"><a href="#方法二-Get-JGI-Genomes" class="headerlink" title="方法二 | Get JGI Genomes"></a>方法二 | Get JGI Genomes</h1><div class="note purple no-icon flat"><p>该方法适合批量下载</p>
</div>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;hub.fastgit.org&#x2F;guyleonard&#x2F;get_jgi_genomes.git</span><br></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  get_jgi_genomes [-u &lt;username&gt; -p &lt;password&gt;] | [-c &lt;cookies&gt;] [-f | -a | -P 12 | -m 3] (-i) (-l) (-A) (-C) (-g) (-t) (-q)</span><br><span class="line"></span><br><span class="line">Required:</span><br><span class="line">	-u &lt;username&gt;</span><br><span class="line">	-p &lt;password&gt;</span><br><span class="line">or</span><br><span class="line">	-c &lt;cookie file&gt;</span><br><span class="line">Portal Choice:</span><br><span class="line">	-f Mycocosm aka fungi</span><br><span class="line">	-a Phycocosm aka algae</span><br><span class="line">	-P &lt;version&gt; PhytozomeV aka plants</span><br><span class="line">	-m &lt;version&gt; MetazomeV aka metazoans</span><br><span class="line">Portal File Options:</span><br><span class="line">	-A get assembly</span><br><span class="line">	-C get CDS</span><br><span class="line">	-g get GFF</span><br><span class="line">	-t get transcripts</span><br><span class="line">JGI Taxa ID:</span><br><span class="line">	-i &lt;id&gt; JGI ID of Genome Project</span><br><span class="line">Other:</span><br><span class="line">	-l list only, no downloads</span><br></pre></td></tr></table></figure>
<h2 id="下载示例"><a href="#下载示例" class="headerlink" title="下载示例"></a>下载示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录：</span></span><br><span class="line">./bin/get_jgi_genomes -u your.email@address.com -p password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录后从 Mycocosm 下载所有蛋白质文件的列表：</span></span><br><span class="line">./bin/get_jgi_genomes -c signon.cookie -f -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录后从 Phycocosm 下载所有 CDS 文件：</span></span><br><span class="line">./bin/get_jgi_genomes -c signon.cookie -a -C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录后从 Phytozome V12 下载所有程序集文件：</span></span><br><span class="line">./bin/get_jgi_genomes -c signon.cookie -P 12 -A</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="方法三-jgi-query"><a href="#方法三-jgi-query" class="headerlink" title="方法三 | jgi-query"></a>方法三 | jgi-query</h1><div class="note purple no-icon flat"><p>这是一个python写的脚本，感兴趣的可以查看使用信息，<a href="https://hub.fastgit.org/glarue/jgi-query">点击此处链接</a></p>
</div>

<h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;glarue&#x2F;jgi-query.git</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: jgi-query.py [-h] [-x [XML]] [-c] [-s] [-f] [-u] [-n RETRY_N]</span><br><span class="line">                    [-l logfile] [-r REGEX] [-a]</span><br><span class="line">                    [organism_abbreviation]</span><br><span class="line"></span><br><span class="line">This script will list and retrieve files from JGI using the curl API. It will</span><br><span class="line"><span class="built_in">return</span> a list of all files available <span class="keyword">for</span> download <span class="keyword">for</span> a given query organism.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  organism_abbreviation</span><br><span class="line">                        organism name formatted per JGI<span class="string">&#x27;s abbreviation. For</span></span><br><span class="line"><span class="string">                        example, &#x27;</span>Nematostella vectensis<span class="string">&#x27; is abbreviated by</span></span><br><span class="line"><span class="string">                        JGI as &#x27;</span>Nemve1<span class="string">&#x27;. The appropriate abbreviation may be</span></span><br><span class="line"><span class="string">                        found by searching for the organism on JGI; the name</span></span><br><span class="line"><span class="string">                        used in the URL of the &#x27;</span>Info<span class="string">&#x27; page for that organism</span></span><br><span class="line"><span class="string">                        is the correct abbreviation. The full URL may also be</span></span><br><span class="line"><span class="string">                        used for this argument (default: None)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">optional arguments:</span></span><br><span class="line"><span class="string">  -h, --help            show this help message and exit</span></span><br><span class="line"><span class="string">  -x [XML], --xml [XML]</span></span><br><span class="line"><span class="string">                        specify a local xml file for the query instead of</span></span><br><span class="line"><span class="string">                        retrieving a new copy from JGI (default: None)</span></span><br><span class="line"><span class="string">  -c, --configure       initiate configuration dialog to overwrite existing</span></span><br><span class="line"><span class="string">                        user/password configuration (default: False)</span></span><br><span class="line"><span class="string">  -s, --syntax_help</span></span><br><span class="line"><span class="string">  -f, --filter_files    filter organism results by config categories instead</span></span><br><span class="line"><span class="string">                        of reporting all files listed by JGI for the query</span></span><br><span class="line"><span class="string">                        (work in progress) (default: False)</span></span><br><span class="line"><span class="string">  -u, --usage           print verbose usage information and exit (default:</span></span><br><span class="line"><span class="string">                        False)</span></span><br><span class="line"><span class="string">  -n RETRY_N, --retry_n RETRY_N</span></span><br><span class="line"><span class="string">                        number of times to retry downloading files with errors</span></span><br><span class="line"><span class="string">                        (0 to skip such files) (default: 4)</span></span><br><span class="line"><span class="string">  -l logfile, --load_failed logfile</span></span><br><span class="line"><span class="string">                        retry downloading from URLs listed in log file</span></span><br><span class="line"><span class="string">                        (default: None)</span></span><br><span class="line"><span class="string">  -r REGEX, --regex REGEX</span></span><br><span class="line"><span class="string">                        Regex pattern to use to auto-select and download files</span></span><br><span class="line"><span class="string">                        (no interactive prompt) (default: None)</span></span><br><span class="line"><span class="string">  -a, --all             Auto-select and download all files for query (no</span></span><br><span class="line"><span class="string">                        interactive prompt) (default: False)</span></span><br></pre></td></tr></table></figure>

<h1 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h1><p><a href="https://github.com/liudab/phytozomedownloader">点击链接前往</a></p>
]]></content>
      <categories>
        <category>下载</category>
      </categories>
      <tags>
        <tag>Phytozome</tag>
        <tag>JGI</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>转录组分析流程｜TransDecoder预测转录本的开放阅读框（二）</title>
    <url>/2021/01/19/TransDecoder/</url>
    <content><![CDATA[<h1 id="使用TransDecoder预测CDS"><a href="#使用TransDecoder预测CDS" class="headerlink" title="使用TransDecoder预测CDS"></a>使用TransDecoder预测CDS</h1><p>TransDecoder按照其官网的说明，主要用于<strong>识别转录本序列中的潜在的编码区域</strong>，也就是<strong>预测CDS</strong>。转录本可以由RNA-Seq数据通过Trinity组装来的，也可以由RNA-Seq比对到参考基因组上构建的转录本。<br>最新版本的TransDecoder可在<a href="https://github.com/TransDecoder/TransDecoder/releases">此处</a>找到。</p>
<p>TransDecoder识别可能的编码区域是基于以下几个标准：</p>
<ol>
<li>a minimum length open reading frame (ORF) is found in a transcript sequence</li>
<li>a log-likelihood score similar to what is computed by the <a href="https://genome.cshlp.org/content/10/4/511.long">GeneID</a> software is &gt; 0</li>
<li>the above coding score is greatest when the ORF is scored in the 1st reading frame as compared to scores in the other 5 reading frames</li>
<li>if a candidate ORF is found fully encapsulated by the coordinates of another candidate ORF, the longer one is reported. However, a single transcript can report multiple ORFs (allowing for operons, chimeras, etc)</li>
<li>a PSSM is built/trained/used to refine the start codon prediction.</li>
<li>optional the putative peptide has a match to a Pfam domain above the noise cutoff score</li>
</ol>
<h2 id="Step-1-extract-the-long-open-reading-frames"><a href="#Step-1-extract-the-long-open-reading-frames" class="headerlink" title="Step 1: extract the long open reading frames"></a>Step 1: extract the long open reading frames</h2><p><code>TransDecoder.LongOrfs -t target_transcripts.fasta</code></p>
<blockquote>
<p>默认情况下，TransDecoder.LongOrfs将识别至少100个氨基酸长的ORF。您可以通过’-m’参数降低此值，但可以知道，使用更短的最小长度标准，误报ORF预测的比率会急剧增加。</p>
</blockquote>
<h2 id="Step-2-optional"><a href="#Step-2-optional" class="headerlink" title="Step 2: (optional)"></a>Step 2: (optional)</h2><p>通过blast或pfam搜索鉴定与已知蛋白具有同源性的ORF。<br>参考下面的将同源性搜索包括为ORF保留标准部分。</p>
<h2 id="Step-3-predict-the-likely-coding-regions"><a href="#Step-3-predict-the-likely-coding-regions" class="headerlink" title="Step 3: predict the likely coding regions"></a>Step 3: predict the likely coding regions</h2><p><code>TransDecoder.Predict -t target_transcripts.fasta [ homology options ]</code><br>最终的文件可以在当前目录找到，也就是后缀为.pep, .cds, .gff3和.bed的文件</p>
<p>一般来说，我们会使用TransDecoder对无参转录组的拼接结果序列预测其CDS，所以我们可以先将拼接序列用BLAST比对nr以及swissprot蛋白数据库，然后提取其比对上的同源序列的位置来识别CDS，最后再通过TransDecoder的第一步和第三步来预测那些未比对上的序列的CDS。</p>
<h1 id="以有参考基因组的转录结果GTF文件预测编码区域"><a href="#以有参考基因组的转录结果GTF文件预测编码区域" class="headerlink" title="以有参考基因组的转录结果GTF文件预测编码区域"></a>以有参考基因组的转录结果GTF文件预测编码区域</h1><p>此处的过程与上述过程相同，不同之处在于，我们必须首先生成一个与转录本序列相对应的fasta文件，最后，我们重新计算GFF3格式的基因组注释文件</p>
<ol>
<li><p>使用基因组和transcripts.gtf文件构建transcript fasta文件，如下所示：<br><code>util/gtf_genome_to_cdna_fasta.pl transcripts.gtf test.genome.fasta &gt; transcripts.fasta </code></p>
</li>
<li><p>接下来，将成绩单结构GTF文件转换为alignment-GFF3格式的文件（之所以这样做，是因为我们的进程对gff3而不是对gtf文件进行操作-没什么大的影响）。像这样将gtf转换为alignment-gff3：<br><code>util/gtf_to_alignment_gff3.pl transcripts.gtf &gt; transcripts.gff3</code></p>
</li>
<li><p>运行上述过程以生成最佳候选ORF预测：<br><code>TransDecoder.LongOrfs -t transcripts.fasta (optionally, identify peptides with homology to known proteins) TransDecoder.Predict -t transcripts.fasta [ homology options ]</code></p>
</li>
<li><p>最后，生成基于基因组的编码区域注释文件：<br><code>util/cdna_alignment_orf_to_genome_orf.pl \   transcripts.fasta.transdecoder.gff3 \   transcripts.gff3 \   transcripts.fasta &gt; transcripts.fasta.transdecoder.genome.gff3</code></p>
</li>
</ol>
<h1 id="输出文件说明"><a href="#输出文件说明" class="headerlink" title="输出文件说明"></a>输出文件说明</h1><p>创建了一个工作目录（例如transcripts.transdecoder_dir /）来运行和存储管道的中间部分，其中包含：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">longest_orfs.pep   : all ORFs meeting the minimum length criteria, regardless of coding potential.</span><br><span class="line">longest_orfs.gff3  : positions of all ORFs as found <span class="keyword">in</span> the target transcripts</span><br><span class="line">longest_orfs.cds   : the nucleotide coding sequence <span class="keyword">for</span> all detected ORFs</span><br><span class="line"></span><br><span class="line">longest_orfs.cds.top_500_longest   : the top 500 longest ORFs, used <span class="keyword">for</span> training a Markov model <span class="keyword">for</span> coding sequences.</span><br><span class="line"></span><br><span class="line">hexamer.scores                     : <span class="built_in">log</span> likelihood score <span class="keyword">for</span> each k-mer  (coding/random)</span><br><span class="line"></span><br><span class="line">longest_orfs.cds.scores            : the <span class="built_in">log</span> likelihood sum scores <span class="keyword">for</span> each ORF across each of the 6 reading frames</span><br><span class="line">longest_orfs.cds.scores.selected   : the accessions of the ORFs that were selected based on the scoring criteria (described at top)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">transcripts.fasta.transdecoder.pep : peptide sequences <span class="keyword">for</span> the final candidate ORFs; all shorter candidates within longer ORFs were removed.</span><br><span class="line">transcripts.fasta.transdecoder.cds  : nucleotide sequences <span class="keyword">for</span> coding regions of the final candidate ORFs</span><br><span class="line">transcripts.fasta.transdecoder.gff3 : positions within the target transcripts of the final selected ORFs</span><br><span class="line">transcripts.fasta.transdecoder.bed  : bed-formatted file describing ORF positions, best <span class="keyword">for</span> viewing using GenomeView or IGV.</span><br></pre></td></tr></table></figure>
<p>最终输出文件如下:</p>
<ul>
<li>  *.pep （是最终的候选ORF编码的蛋白序列）</li>
<li>  *.cds （最终预测的CDS序列）</li>
<li>  *.gff3 （是表示ORF的目标转录本的位置）</li>
<li>  *.bed （用于后期的IGV可视化，以BED格式存放ORF位置信息）</li>
</ul>
<h1 id="一键化脚本"><a href="#一键化脚本" class="headerlink" title="一键化脚本"></a>一键化脚本</h1><p>也有作者发布了脚本，只需要准备参考基因组的数据库位置信息以及相关软件即可自动进行分析，得出结果，非常方便快捷。<br>具体有需要脚本的后续可以留言～</p>
]]></content>
      <categories>
        <category>转录组分析</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>转录组组装</tag>
        <tag>软件</tag>
        <tag>TransDecoder</tag>
      </tags>
  </entry>
  <entry>
    <title>转录组分析流程｜数据处理与De novo组装（一）</title>
    <url>/2021/01/18/Trinity/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><a href="https://baike.baidu.com/item/%E8%BD%AC%E5%BD%95%E7%BB%84/9998410?fr=aladdin">转录组（transcriptome）</a>广义上指某一生理条件下，细胞内所有转录产物的集合，包括信使RNA、核糖体RNA、转运RNA及非编码RNA；狭义上指所有mRNA的集合。<br><a href="https://baike.baidu.com/item/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%B5%8B%E5%BA%8F/486410">RNA-Seq (RNA-sequencing)</a>也称为转录组测序，是最新发展起来的利用新一代测序技术进行转录组分析的技术，可以全面快速地获得特定细胞或组织在某一状态下几乎所有转录本的序列信息和表达信息，包括编码蛋白质的mRNA和各种非编码RNA，基因选择性剪接产生的不同转录本的表达丰度等。在分析转录本的结构和表达水平的同时，还发现未知转录本和稀有转录本，从而准确地分析基因表达差异、基因结构变异、筛选分子标记等生命科学的重要问题。</p>
<h1 id="组装软件及用法"><a href="#组装软件及用法" class="headerlink" title="组装软件及用法"></a>组装软件及用法</h1><h2 id="数据矫正"><a href="#数据矫正" class="headerlink" title="数据矫正"></a>数据矫正</h2><p>使用<code>rcorrector</code>软件对数据进行矫正,输入<code>run_rcorrector.pl</code>弹出使用说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ run_rcorrector.pl</span><br><span class="line">Usage: perl ./run_rcorrector.pl [OPTIONS]</span><br><span class="line">OPTIONS:</span><br><span class="line">Required parameters:</span><br><span class="line">	-s seq_files: comma separated files <span class="keyword">for</span> single-end data sets</span><br><span class="line">	-1 seq_files_left: comma separated files <span class="keyword">for</span> the first mate <span class="keyword">in</span> the paried-end data sets</span><br><span class="line">	-2 seq_files_right: comma separated files <span class="keyword">for</span> the second mate <span class="keyword">in</span> the paired-end data sets</span><br><span class="line">	-i seq_files_interleaved: comma sperated files <span class="keyword">for</span> interleaved paired-end data sets</span><br><span class="line">Other parameters:</span><br><span class="line">	-k kmer_length (&lt;=32, default: 23)</span><br><span class="line">	-od output_file_directory (default: ./)</span><br><span class="line">	-t number_of_threads (default: 1)</span><br><span class="line">	-maxcorK INT: the maximum number of correction within k-bp window (default: 4)</span><br><span class="line">	-wk FLOAT: the proportion of kmers that are used to estimate weak kmer count threshold, lower <span class="keyword">for</span> more divergent genome (default: 0.95)</span><br><span class="line">	-ek expected_number_of_kmers: does not affect the correctness of program but affect the memory usage (default: 100000000)</span><br><span class="line">	-stdout: output the corrected reads to stdout (default: not used)</span><br><span class="line">	-verbose: output some correction information to stdout (default: not used)</span><br><span class="line">	-stage INT: start from <span class="built_in">which</span> stage (default: 0)</span><br><span class="line">		0-start from begining(storing kmers <span class="keyword">in</span> bloom filter);</span><br><span class="line">		1-start from count kmers showed up <span class="keyword">in</span> bloom filter;</span><br><span class="line">		2-start from dumping kmer counts into a jf_dump file;</span><br><span class="line">		3-start from error correction.</span><br></pre></td></tr></table></figure>
<p>上面说的很详细，下面在介绍几个常用到的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-s seq_files:单端测序的文件选择-s命令</span><br><span class="line">-1 seq_files_left -2 seq_files_right:：双端测序的选择此命令输入左右两端测序的两个文件，目前大多为PE data</span><br><span class="line">-k 设置kmer值，也可以直接不选择按照默认参数</span><br><span class="line">-od 输出文件名称</span><br><span class="line">-t 所用线程数根据自己情况进行选择</span><br></pre></td></tr></table></figure>
<p>当然如果你只有一对数据的话可以单独进行操作，但是当你的转录组数据有很多时，这里推荐进行批量处理，具体的操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 文件名称 | while read f; do run_rcorrector.pl -t 12 -p $&#123;f&#125;&quot;_1.fq.gz&quot; $&#123;f&#125;&quot;_2.fq.gz&quot;; done</span><br></pre></td></tr></table></figure>
<p>cat+自己创建的文件名，如果你的序列为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ABC_1.fq.gz,ABC_2.fq.gz;</span><br><span class="line">BCD_1.fq.gz,BCD_2.fq.gz;</span><br><span class="line">CDE_1.fq.gz,CDE_2.fq.gz;</span><br></pre></td></tr></table></figure>
<p>其中文件的格式应该为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ABC</span><br><span class="line">BCD</span><br><span class="line">CDE</span><br></pre></td></tr></table></figure>
<p>这里如果你的数据是_1.fq.gz以及_2.fq.gz则不需要修改，但是如果后缀和这里不一致，就修改成你自己数据的名称后缀<br>（注意，处理的所有数据的后缀名应保持一致）<br>跑完之后会在原有的<code>*.fq.gz</code>生成<code> *.cor.fq.gz</code></p>
<h2 id="去接头和低质量序列"><a href="#去接头和低质量序列" class="headerlink" title="去接头和低质量序列"></a>去接头和低质量序列</h2><p>去接头一般是需要去除掉测序时多余的接头，这一步的话如果测序数据下来之后已经做过了就可以选择可做可不做，说一下具体操作步骤<br>这里用到的软件为<code>Trimmomatic</code><br><strong>软件安装方法：</strong><br>1、直接进入<a href="http://www.usadellab.org/cms/index.php?page=trimmomatic">Trimmomatic</a>官方下载<br>2、<code>conda install -c bioconda trimmomatic</code></p>
<p><strong>下载Illumina双端接头序列</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -L http://dib-training.ucdavis.edu.s3.amazonaws.com/mRNAseq-semi-2015-03-04/TruSeq2-PE.fa</span><br></pre></td></tr></table></figure>
<p>或者从官网下载的话自带有一般在adapter文件夹里 <code>~/Trimmomatic-0.39/adapters</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trimmomatic</span><br><span class="line">Usage: </span><br><span class="line">       PE [-version] [-threads &lt;threads&gt;] [-phred33|-phred64] [-trimlog &lt;trimLogFile&gt;] [-summary &lt;statsSummaryFile&gt;] [-quiet] [-validatePairs] [-basein &lt;inputBase&gt; | &lt;inputFile1&gt; &lt;inputFile2&gt;] [-baseout &lt;outputBase&gt; | &lt;outputFile1P&gt; &lt;outputFile1U&gt; &lt;outputFile2P&gt; &lt;outputFile2U&gt;] &lt;trimmer1&gt;...</span><br><span class="line">   or: </span><br><span class="line">       SE [-version] [-threads &lt;threads&gt;] [-phred33|-phred64] [-trimlog &lt;trimLogFile&gt;] [-summary &lt;statsSummaryFile&gt;] [-quiet] &lt;inputFile&gt; &lt;outputFile&gt; &lt;trimmer1&gt;...</span><br><span class="line">   or: </span><br><span class="line">       -version</span><br></pre></td></tr></table></figure>
<p>单端测序<br><code>trimmomatic SE -phred33 input.fq.gz output.fq.gz ILLUMINACLIP:TruSeq3-SE:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36</code><br>双端测序<br><code>trimmomatic PE -phred33 input_forward.fq.gz input_reverse.fq.gz output_forward_paired.fq.gz output_forward_unpaired.fq.gz output_reverse_paired.fq.gz output_reverse_unpaired.fq.gz ILLUMINACLIP:TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36</code><br>或者将<code>trimmomatic</code>改为<code>java -jar trimmomatic-0.35.jar</code>运行</p>
<blockquote>
<p>常用参数：<br>-threads 线程数<br>-trimlog 生成日志名，log文件较多建议不开启<br>-quiet 静默模式</p>
</blockquote>
<blockquote>
<p>修整步骤：<br>ILLUMINACLIP：从reads中剪切adapter和其他Illumina特定序列。<br>SLIDINGWINDOW：执行滑动窗口修剪，一旦窗口内的平均质量低于阈值，则切割。<br>LEADING：如果低于阈值质量，则在reads起始处剪切碱基<br>TRAILING：如果低于阈值质量，则在reads末尾处剪切碱基<br>CROP：将reads从末尾切割为指定长度<br>HEADCROP：从reads剪切后低于指定长度，则删除<br>MINLEN：如果reads低于指定长度，则删除<br>TOPHRED33：将质量得分转换为Phred-33<br>TOPHRED64：将质量得分转换为Phred-64</p>
</blockquote>
<p>若数据有很多对转录组，建议批量操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 文件名 | while read f; do time java -jar &#x2F;home&#x2F;你的路径&#x2F;software&#x2F;Trimmomatic-0.39&#x2F;trimmomatic-0.39.jar PE -threads 20 -phred33 $&#123;f&#125;&quot;_1.cor.fq.gz&quot; $&#123;f&#125;&quot;_2.cor.fq.gz&quot; $&#123;f&#125;&quot;_1.cor.p.fq.gz&quot; $&#123;f&#125;&quot;_1.cor.u.fq.gz&quot; $&#123;f&#125;&quot;_2.cor.p.fq.gz&quot; $&#123;f&#125;&quot;_2.cor.u.fq.gz&quot; ILLUMINACLIP:&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;Trimmomatic-0.39&#x2F;adapters&#x2F;TruSeq2-PE.fa:2:30:10 SLIDINGWINDOW:4:15 LEADING:5 TRAILING:4 MINLEN:80; done</span><br></pre></td></tr></table></figure>
<p><code>$&#123;f&#125;&quot;_1.cor.fq.gz&quot; $&#123;f&#125;&quot;_2.cor.fq.gz&quot; </code>为输入的文件<br><code>$&#123;f&#125;&quot;_1.cor.p.fq.gz&quot; $&#123;f&#125;&quot;_1.cor.u.fq.gz&quot; $&#123;f&#125;&quot;_2.cor.p.fq.gz&quot; $&#123;f&#125;&quot;_2.cor.u.fq.gz&quot; </code>为输出的文件<br>后缀一致，将名称放入文件中 <code>cat 文件</code> 即可,和上面形式一致。</p>
<h1 id="转录组De-novo组装"><a href="#转录组De-novo组装" class="headerlink" title="转录组De novo组装"></a>转录组De novo组装</h1><p>用<code>Trinity</code>进行转录组组装<br><img src="https://z3.ax1x.com/2021/01/24/sbRNvQ.png" alt="Trinity"></p>
<blockquote>
</blockquote>
<p><code>Trinity</code>包括三个模块，能处理大型的RNA数据<br>Inchworn: 将RNA-seq数据组装成单个转录本，通常是主要转录亚型的全长转录本<br>Chrysalis: 这一步将上一步得到contig进行聚类，对于每个聚类构建完整的德布罗意图(de Bruijin graph)每个转录本表示的是给定基因或者一组有着共同序列的基因的全部转录组成。 之后会根据图中不相交的点对全部短读数据进行拆分<br>Butterfly: 并行处理各个图(graph), 追踪每个图中的短读和配对短读的路径，最后报告可变剪切亚型的全长转录本，并且区分出旁系同源基因的转录本</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>1、<code>conda install -c bioconda trinity</code><br>2、<a href="https://github.com/trinityrnaseq/trinityrnaseq/">trinity官网</a><br>因为trinity需要的依赖包很多，这里建议用<code>conda</code>安装,目前最新版本为Trinity-v2.11.0</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>安装成功后输入<code>Trinity</code>弹出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Trinity</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">     ______  ____   ____  ____   ____  ______  __ __</span><br><span class="line">    |      ||    \ |    ||    \ |    ||      ||  |  |</span><br><span class="line">    |      ||  D  ) |  | |  _  | |  | |      ||  |  |</span><br><span class="line">    |_|  |_||    /  |  | |  |  | |  | |_|  |_||  ~  |</span><br><span class="line">      |  |  |    \  |  | |  |  | |  |   |  |  |___, |</span><br><span class="line">      |  |  |  .  \ |  | |  |  | |  |   |  |  |     |</span><br><span class="line">      |__|  |__|\_||____||__|__||____|  |__|  |____/</span><br><span class="line"></span><br><span class="line">    Trinity-v2.11.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Required:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --seqType &lt;string&gt;      :type of reads: (&#x27;fa&#x27; or &#x27;fq&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --max_memory &lt;string&gt;      :suggested max memory to use by Trinity where limiting can be enabled. (jellyfish, sorting, etc)</span></span><br><span class="line"><span class="comment">#                            provided in Gb of RAM, ie.  &#x27;--max_memory 10G&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  If paired reads:</span></span><br><span class="line"><span class="comment">#      --left  &lt;string&gt;    :left reads, one or more file names (separated by commas, no spaces)</span></span><br><span class="line"><span class="comment">#      --right &lt;string&gt;    :right reads, one or more file names (separated by commas, no spaces)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Or, if unpaired reads:</span></span><br><span class="line"><span class="comment">#      --single &lt;string&gt;   :single reads, one or more file names, comma-delimited (note, if single file contains pairs, can use flag: --run_as_paired )</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Or,</span></span><br><span class="line"><span class="comment">#      --samples_file &lt;string&gt;         tab-delimited text file indicating biological replicate relationships.</span></span><br><span class="line"><span class="comment">#                                   ex.</span></span><br><span class="line"><span class="comment">#                                        cond_A    cond_A_rep1    A_rep1_left.fq    A_rep1_right.fq</span></span><br><span class="line"><span class="comment">#                                        cond_A    cond_A_rep2    A_rep2_left.fq    A_rep2_right.fq</span></span><br><span class="line"><span class="comment">#                                        cond_B    cond_B_rep1    B_rep1_left.fq    B_rep1_right.fq</span></span><br><span class="line"><span class="comment">#                                        cond_B    cond_B_rep2    B_rep2_left.fq    B_rep2_right.fq</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                      # if single-end instead of paired-end, then leave the 4th column above empty.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">####################################</span></span><br><span class="line"><span class="comment">##  Misc:  #########################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --include_supertranscripts      :yield supertranscripts fasta and gtf files as outputs.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --SS_lib_type &lt;string&gt;          :Strand-specific RNA-Seq read orientation.</span></span><br><span class="line"><span class="comment">#                                   if paired: RF or FR,</span></span><br><span class="line"><span class="comment">#                                   if single: F or R.   (dUTP method = RF)</span></span><br><span class="line"><span class="comment">#                                   See web documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --CPU &lt;int&gt;                     :number of CPUs to use, default: 2</span></span><br><span class="line"><span class="comment">#  --min_contig_length &lt;int&gt;       :minimum assembled contig length to report</span></span><br><span class="line"><span class="comment">#                                   (def=200)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --long_reads &lt;string&gt;           :fasta file containing error-corrected or circular consensus (CCS) pac bio reads</span></span><br><span class="line"><span class="comment">#                                   (** note: experimental parameter **, this functionality continues to be under development)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --genome_guided_bam &lt;string&gt;    :genome guided mode, provide path to coordinate-sorted bam file.</span></span><br><span class="line"><span class="comment">#                                   (see genome-guided param section under --show_full_usage_info)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --jaccard_clip                  :option, set if you have paired reads and</span></span><br><span class="line"><span class="comment">#                                   you expect high gene density with UTR</span></span><br><span class="line"><span class="comment">#                                   overlap (use FASTQ input file format</span></span><br><span class="line"><span class="comment">#                                   for reads).</span></span><br><span class="line"><span class="comment">#                                   (note: jaccard_clip is an expensive</span></span><br><span class="line"><span class="comment">#                                   operation, so avoid using it unless</span></span><br><span class="line"><span class="comment">#                                   necessary due to finding excessive fusion</span></span><br><span class="line"><span class="comment">#                                   transcripts w/o it.)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --trimmomatic                   :run Trimmomatic to quality trim reads</span></span><br><span class="line"><span class="comment">#                                        see &#x27;--quality_trimming_params&#x27; under full usage info for tailored settings.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --output &lt;string&gt;               :name of directory for output (will be</span></span><br><span class="line"><span class="comment">#                                   created if it doesn&#x27;t already exist)</span></span><br><span class="line"><span class="comment">#                                   default( your current working directory: &quot;/home/lixingze/trinity_out_dir&quot; </span></span><br><span class="line"><span class="comment">#                                    note: must include &#x27;trinity&#x27; in the name as a safety precaution! )</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment">#  --full_cleanup                  :only retain the Trinity fasta file, rename as $&#123;output_dir&#125;.Trinity.fasta</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --cite                          :show the Trinity literature citation</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --verbose                       :provide additional job status info during the run.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --version                       :reports Trinity version (Trinity-v2.11.0) and exits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  --show_full_usage_info          :show the many many more options available for running Trinity (expert usage).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  *Note, a typical Trinity command might be:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        Trinity --seqType fq --max_memory 50G --left reads_1.fq  --right reads_2.fq --CPU 6</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#            (if you have multiple samples, use --samples_file ... see above for details)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    and for Genome-guided Trinity, provide a coordinate-sorted bam:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        Trinity --genome_guided_bam rnaseq_alignments.csorted.bam --max_memory 50G</span></span><br><span class="line"><span class="comment">#                --genome_guided_max_intron 10000 --CPU 6</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     see: /home/lixingze/software/trinityrnaseq-v2.11.0/sample_data/test_Trinity_Assembly/</span></span><br><span class="line"><span class="comment">#          for sample data and &#x27;runMe.sh&#x27; for example Trinity execution</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     For more details, visit: http://trinityrnaseq.github.io</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br></pre></td></tr></table></figure>
<p>上面给的信息很详细运行只需要下面一条命令，接下来就是等待结果～</p>
<p><strong>几个常用命令介绍</strong><br><code>Trinity --seqType fq --samples_file 文件名称 --CPU 20 --max_memory 70G --output 输出文件夹</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Trinity </span><br><span class="line">--seqType reads类型fq or fa</span><br><span class="line">--samples_file 如果文件过多，可以将信息写入samples文件中</span><br><span class="line">文件格式已给出：</span><br><span class="line">cond_A    cond_A_rep1    A_rep1_left.fq    A_rep1_right.fq</span><br><span class="line">cond_A    cond_A_rep2    A_rep2_left.fq    A_rep2_right.fq</span><br><span class="line">cond_B    cond_B_rep1    B_rep1_left.fq    B_rep1_right.fq</span><br><span class="line">cond_B    cond_B_rep2    B_rep2_left.fq    B_rep2_right.fq</span><br><span class="line">--CPU 线程数</span><br><span class="line">--max_memory 最大内存数根据自己服务器内存自己定</span><br><span class="line">--output 输出文件名</span><br><span class="line">--left : left reads，多个文件以逗号隔开</span><br><span class="line">--right : right reads，多个文件以逗号隔开</span><br></pre></td></tr></table></figure>
<p>查看trinity的完整的全部参数 <code>Trinity  --show_full_usage_info</code> </p>
<h2 id="数据解读"><a href="#数据解读" class="headerlink" title="数据解读"></a>数据解读</h2><p>组装完成之后会在输出文件夹中输出一个<code>Trinity.fasta</code>这个就是最终组装结果！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;TRINITY_DN59_c0_g1_i10 len=4860 path=[0:0-614 2:615-757 4:758-815 5:816-882 7:883-919 9:920-1052 10:1053-1080 11:1081-1408 13:1409-1434 15:1435-1614 16:1615-1638 18:1639-1773 20:1774-1960 22:1961-2333 24:2334-2374 26:2375-2404 27:2405-2991 29:2992-4149 30:4150-4212 32:4213-4318 33:4319-4526 34:4527-4559 36:4560-4859]</span><br><span class="line">CTTTGCCTCTCCTCAGAAGAGATGACAAGTGCATCAAGGAGTAGTTTTGCATCAACTACACATCATGCTTCGATGTTGCAGATAAGAGATTTCTCAGCATACCATATGGAAAATGTTTCCTACTATGCCTCCATGCATACTCAAAACGCCTCCTGAATTGGGGATAAATAGTTCTCGTATAGAATATAGGTTAATTATACAACAAATAAAGAACAAAGCTGTTAAACTGATTTTATGCATGAACACACTTTTTGA略</span><br></pre></td></tr></table></figure>
<p>其中<code>TRINITY_DN59_c0</code>是Trinity聚类编号，<code>g1</code>是基因编号，<code>i10</code>是转录组亚型编号</p>
<h1 id="转录组后续分析"><a href="#转录组后续分析" class="headerlink" title="转录组后续分析"></a>转录组后续分析</h1><p>组装完成之后，就需要对其进行注释等后续操作，将会在下一篇中提到。</p>
<a class="btn-beautify button--animated purple larger" href="https://lixingze.xyz" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>转录组分析</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>转录组组装</tag>
        <tag>软件</tag>
        <tag>Trinity</tag>
        <tag>Rcorrector</tag>
        <tag>Trimmomatic</tag>
      </tags>
  </entry>
  <entry>
    <title>不同测序数据应用与基因组组装｜Canu</title>
    <url>/2021/02/06/hicanu/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Canu专门组装PacBio或Oxford Nanopore序列。Canu分为三个阶段：校正、修整和装配。校正阶段将提高读取中基数的准确性。微调阶段将微调显示为高质量序列的部分的读取，删除可疑区域，如剩余的SMRTbell适配器。组装阶段将把读取排序为重叠，生成一致序列，并创建备用路径图。<br>输入序列可以是FASTA或FASTQ格式，未压缩或用gzip（.gz）、bzip2（.bz2）或xz（.xz）压缩。请注意，不支持zip文件（.zip）。</p>
<h1 id="官方测试数据下载"><a href="#官方测试数据下载" class="headerlink" title="官方测试数据下载"></a>官方测试数据下载</h1><div class="note red no-icon flat"><p>下面包括了pacbio、Nanopore以及Pacbio HIFI的测试数据集</p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Pacific Biosciences released P6-C4 chemistry reads for Escherichia coli K12. </span><br><span class="line">curl -L -o pacbio.fastq http:&#x2F;&#x2F;gembox.cbcb.umd.edu&#x2F;mhap&#x2F;raw&#x2F;ecoli_p6_25x.filtered.fastq</span><br><span class="line"></span><br><span class="line">#Oxford Nanopore样本数据(Escherichia coli K12)</span><br><span class="line">curl -L -o oxford.fasta http:&#x2F;&#x2F;nanopore.s3.climb.ac.uk&#x2F;MAP006-PCR-1_2D_pass.fasta</span><br><span class="line"></span><br><span class="line">#PacBio测序的大肠杆菌K12 HiFi数据集</span><br><span class="line">curl -L -o ecoli.fastq https:&#x2F;&#x2F;sra-pub-src-1.s3.amazonaws.com&#x2F;SRR10971019&#x2F;m54316_180808_005743.fastq.1</span><br><span class="line"></span><br><span class="line">canu \</span><br><span class="line"> -p asm -d ecoli_hifi \</span><br><span class="line"> genomeSize&#x3D;4.8m \</span><br><span class="line"> -pacbio-hifi ecoli.fastq</span><br></pre></td></tr></table></figure>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Conda</span></span><br><span class="line">conda install -c conda-forge -c bioconda -c defaults canu</span><br><span class="line"><span class="comment">#Homebrew</span></span><br><span class="line">brew install brewsci/bio/canu</span><br><span class="line"><span class="comment">#使用源代码中的最新未发行版本</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/marbl/canu.git</span><br><span class="line"><span class="built_in">cd</span> canu/src</span><br><span class="line">make -j &lt;number of threads&gt;</span><br></pre></td></tr></table></figure>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">canu [-haplotype|-correct|-trim] \</span><br><span class="line">   [-s &lt;assembly-specifications-file&gt;] \</span><br><span class="line">   -p &lt;assembly-prefix&gt; \</span><br><span class="line">   -d &lt;assembly-directory&gt; \</span><br><span class="line">   genomeSize=&lt;number&gt;[g|m|k] \</span><br><span class="line">   [other-options] \</span><br><span class="line">   [-trimmed|-untrimmed|-raw|-corrected] \</span><br><span class="line">   [-pacbio|-nanopore|-pacbio-hifi] *fastq</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p选项用于设置中间文件和输出文件的文件名前缀<br>-s选项将从提供的规范（“ spec”）文件中导入参数列表。<br>-pacbio和-nanopore假定为原始和未修剪，而-pacbio hifi假定为校正和修剪<br>使用-pacbio-corrected或-nanopore-corrected 提供预校正的读操作将只运行修剪和组装阶段。<br>指定reads作为 -corrected  -untrimmed将只运行组装步骤。</p>
</blockquote>
<blockquote>
<p>rawErrorRate &lt;float=unset&gt;<br>    两次未修正的读取之间重叠的允许差值，用分数误差表示;通常不需要修改（PacBio read的默认值为0.300，Nanopore read的默认值为0.500）<br>correctedErrorRate &lt;float=unset&gt;<br>    两次修正后的读数之间重叠的允许差值，用分数误差表示(PacBio read的默认值为0.045，Nanopore read的默认值为0.144);对于低覆盖率数据集（(less than 30X)，建议将校正错误率稍微增加1%左右。对于高覆盖率数据集（more than 60X），我们建议将校正错误率稍微降低1%左右。</p>
</blockquote>
<a class="btn-beautify button--animated purple larger" href="https://canu.readthedocs.io/en/latest/parameter-reference.html#parameter-reference" title="Canu官方文档"><i class="far fa-hand-point-right"></i><span>Canu官方文档</span></a>

<h2 id="组装PacBio-CLR或Nanopore数据"><a href="#组装PacBio-CLR或Nanopore数据" class="headerlink" title="组装PacBio CLR或Nanopore数据"></a>组装PacBio CLR或Nanopore数据</h2><div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>For PacBio:</p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">canu \</span><br><span class="line"> -p ecoli -d ecoli-pacbio \</span><br><span class="line"> genomeSize=4.8m \</span><br><span class="line"> -pacbio pacbio.fastq</span><br></pre></td></tr></table></figure>
<div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>For Nanopore:</p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">canu \</span><br><span class="line"> -p ecoli -d ecoli-oxford \</span><br><span class="line"> genomeSize=4.8m \</span><br><span class="line"> -nanopore oxford.fasta</span><br></pre></td></tr></table></figure>
<h2 id="用HiCanu组装PacBio-HiFi"><a href="#用HiCanu组装PacBio-HiFi" class="headerlink" title="用HiCanu组装PacBio HiFi"></a>用HiCanu组装PacBio HiFi</h2><p>HiCanu通过压缩均聚物、纠正孤立错误和掩盖系统错误来支持PacBio HiFi数据。现在将组装<a href="https://sra-pub-src-1.s3.amazonaws.com/SRR10971019/m54316_180808_005743.fastq.1">大肠杆菌K12 HiFi数据集</a>，并通过PacBio测序，可在<a href="https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR10971019">NCBI SRA（3 GB）</a>获得。组装时，使用-pacbio hifi指定输入读数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常规组装</span></span><br><span class="line">canu -p asm -d &lt;outDir&gt; genomeSize=&lt;GSize&gt; useGrid=<span class="literal">false</span> maxThreads=&lt;nThreads&gt; \</span><br><span class="line">-pacbio-hifi &lt;HiFi-reads.fasta&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># For trio binning assembly</span></span><br><span class="line">canu -haplotype -p asm -d &lt;outDir&gt; genomeSize=&lt;GSize&gt; useGrid=<span class="literal">false</span> \</span><br><span class="line">maxThreads=&lt;nThreads&gt; -haplotypePat &lt;pat-reads.fq&gt; -haplotypeMat &lt;mat-reads.fq&gt; \</span><br><span class="line">-pacbio-raw &lt;HiFi-reads.fasta&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">curl <span class="operator">-</span>L <span class="operator">-</span>o ecoli.fastq https:<span class="operator">/</span><span class="operator">/</span>sra<span class="operator">-</span>pub<span class="operator">-</span>src<span class="number">-1.</span>s3.amazonaws.com<span class="operator">/</span>SRR10971019<span class="operator">/</span>m54316_180808_005743.fastq<span class="number">.1</span></span><br><span class="line"></span><br><span class="line">canu \</span><br><span class="line"> <span class="operator">-</span>p asm <span class="operator">-</span>d ecoli_hifi \</span><br><span class="line"> genomeSize<span class="operator">=</span><span class="number">4.8</span>m \</span><br><span class="line"> <span class="operator">-</span>pacbio<span class="operator">-</span>hifi ecoli.fastq</span><br></pre></td></tr></table></figure>
<h1 id="使用多种技术和多个文件进行组装"><a href="#使用多种技术和多个文件进行组装" class="headerlink" title="使用多种技术和多个文件进行组装"></a>使用多种技术和多个文件进行组装</h1><p>Canu可以读取任意数量的输入文件，这些文件可以是多种格式和技术的混合体。请注意，当前不支持将PacBio HiFi数据与其他数据类型相结合。官网文档将在两个FASTQ文件中组合10X PacBio CLR读取，在一个FASTA文件中组合10X Nanopore读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L -o mix.tar.gz http://gembox.cbcb.umd.edu/mhap/raw/ecoliP6Oxford.tar.gz</span><br><span class="line">tar xvzf mix.tar.gz</span><br><span class="line"></span><br><span class="line">canu \</span><br><span class="line"> -p ecoli -d ecoli-mix \</span><br><span class="line"> genomeSize=4.8m \</span><br><span class="line"> -pacbio pacbio.part?.fastq.gz \</span><br><span class="line"> -nanopore oxford.fasta.gz</span><br></pre></td></tr></table></figure>
<h2 id="手动校正，修剪和组装"><a href="#手动校正，修剪和组装" class="headerlink" title="手动校正，修剪和组装"></a>手动校正，修剪和组装</h2><ol>
<li>矫正原始数据</li>
<li>修剪校正的输出</li>
<li>用不同的严格度将修剪的输出组装两次，重叠使用(<a href="https://canu.readthedocs.io/en/latest/parameter-reference.html#correctederrorrate">参考此处</a>)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canu \</span><br><span class="line">  -p ecoli -d ecoli-erate-0.039 \</span><br><span class="line">  genomeSize&#x3D;4.8m \</span><br><span class="line">  correctedErrorRate&#x3D;0.039 \</span><br><span class="line">  -trimmed -corrected -pacbio ecoli&#x2F;ecoli.trimmedReads.fasta.gz</span><br><span class="line"></span><br><span class="line">canu \</span><br><span class="line">  -p ecoli -d ecoli-erate-0.075 \</span><br><span class="line">  genomeSize&#x3D;4.8m \</span><br><span class="line">  correctedErrorRate&#x3D;0.075 \</span><br><span class="line">  -trimmed -corrected -pacbio ecoli&#x2F;ecoli.trimmedReads.fasta.gz</span><br></pre></td></tr></table></figure>
<h1 id="Consensus-Accuracy"><a href="#Consensus-Accuracy" class="headerlink" title="Consensus Accuracy"></a>Consensus Accuracy</h1><p>使用PacBio-HiFi数据的HiCanu一致序列通常远高于99.99%，<a href="https://canu.readthedocs.io/en/latest/quick-start.html#assembling-with-multiple-technologies-and-multiple-files">官方文档</a>说到不鼓励对这些组件进行任何后期处理/抛光，因为重复中的mis-mapping可能会导致错误。</p>
<p>对于PacBio数据集，Canu一致序列通常远高于99%的一致性。纳米孔的准确度因孔和基孔的不同而不同，但对于最新的数据，准确度通常在99%以上。精确性可以通过使用专门为该任务开发的工具来提高。<br>Canu推荐Arrow用于PacBio，Nanopolish或Medaka用于Oxford Nanpore数据。当Illumina reads可用时，FreeBayes可用于polish either PacBio or Oxford Nanopore assemblies.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>Nurk S, Walenz B P, Rhie A, et al. HiCanu: accurate assembly of segmental duplications, satellites, and allelic variants from high-fidelity long reads[J]. Genome research, 2020, 30(9): 1291-1305.</p>
</blockquote>
<a class="btn-beautify button--animated purple larger" href="https://lxz9.com" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>基因组组装</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Canu</tag>
        <tag>HiCanu</tag>
      </tags>
  </entry>
  <entry>
    <title>利用HIFI测序数据进行基因组组装｜hifiasm</title>
    <url>/2021/02/06/hifiasm/</url>
    <content><![CDATA[<div class="tip"><p>目前用于Pacbio HIFI测序数据的组装软件主流上有：FALCON、Hifiasm、Hicanu三款。</p><p></p></div>

<h1 id="Hifiasm的使用"><a href="#Hifiasm的使用" class="headerlink" title="Hifiasm的使用"></a>Hifiasm的使用</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Hifiasm是用于PacBio Hifi读取的快速单倍型解析的从头汇编程序。它可以在几个小时内组装一个人类基因组，并与加利福尼亚红木基因组（迄今为止测序最复杂的基因组之一）一起工作。Hifiasm可以生产质量最好的组装商的初级/替代组装。它还引入了新的图合并算法，并在给定三重数据的情况下实现了最佳的单倍型解析程序集。</p>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用conda安装</span><br><span class="line">conda install -c bioconda hifiasm</span><br><span class="line"></span><br><span class="line">#安装hifiasm（需要g++和zlib）</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;chhylp123&#x2F;hifiasm</span><br><span class="line">cd hifiasm &amp;&amp; make</span><br></pre></td></tr></table></figure>
<h1 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h1><div class="note blue no-icon flat"><p>由于是bam格式需要转换为fasta格式</p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bam --&gt; fasta</span></span><br><span class="line">samtools view *.bam | awk <span class="string">&#x27;&#123;print &quot;&gt;&quot;$1&quot;\n&quot;$10&#125;&#x27;</span> &gt; fasta</span><br><span class="line"></span><br><span class="line"><span class="comment">#补充一下其他格式的转换</span></span><br><span class="line"><span class="comment">## sam ---&gt; fasta</span></span><br><span class="line">cat *.sam | awk <span class="string">&#x27;&#123;print &quot;&gt;&quot;$1&quot;\n&quot;$10&#125;&#x27;</span> &gt; *.fasta</span><br><span class="line"><span class="comment">## fasta ---&gt; sam</span></span><br><span class="line">bowtie2 -1 *_1.fa -2 *_2.fa -p 16 -x prefix -S *.sam</span><br><span class="line"><span class="comment">## sam --&gt; bam</span></span><br><span class="line"><span class="comment"># -@：线程 -b：输出格式为BAM -S：自动检测输入格式 -o：输出文件</span></span><br><span class="line">samtools view -@ 16 -b -S final.sam -o final.bam</span><br><span class="line"><span class="comment">## bam --&gt; sam</span></span><br><span class="line">samtools view *.bam -O SAM &gt; *.sam</span><br></pre></td></tr></table></figure>
<h1 id="软件参数"><a href="#软件参数" class="headerlink" title="软件参数"></a>软件参数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hifiasm</span><br><span class="line">Usage: hifiasm [options] &lt;in_1.fq&gt; &lt;in_2.fq&gt; &lt;...&gt;</span><br><span class="line">Options:</span><br><span class="line">  Input/Output:</span><br><span class="line">    -o STR      prefix of output files [hifiasm.asm]</span><br><span class="line">    -i          ignore saved <span class="built_in">read</span> correction and overlaps</span><br><span class="line">    -t INT      number of threads [1]</span><br><span class="line">    -z INT      length of adapters that should be removed [0]</span><br><span class="line">    --version   show version number</span><br><span class="line">  Overlap/Error correction:</span><br><span class="line">    -k INT      k-mer length (must be &lt;64) [51]</span><br><span class="line">    -w INT      minimizer window size [51]</span><br><span class="line">    -f INT      number of bits <span class="keyword">for</span> bloom filter; 0 to <span class="built_in">disable</span> [37]</span><br><span class="line">    -D FLOAT    drop k-mers occurring &gt;FLOAT*coverage <span class="built_in">times</span> [5.0]</span><br><span class="line">    -N INT      consider up to max(-D*coverage,-N) overlaps <span class="keyword">for</span> each oriented <span class="built_in">read</span> [100]</span><br><span class="line">    -r INT      round of correction [3]</span><br><span class="line">  Assembly:</span><br><span class="line">    -a INT      round of assembly cleaning [4]</span><br><span class="line">    -m INT      pop bubbles of &lt;INT <span class="keyword">in</span> size <span class="keyword">in</span> contig graphs [10000000]</span><br><span class="line">    -p INT      pop bubbles of &lt;INT <span class="keyword">in</span> size <span class="keyword">in</span> unitig graphs [100000]</span><br><span class="line">    -n INT      remove tip unitigs composed of &lt;=INT reads [3]</span><br><span class="line">    -x FLOAT    max overlap drop ratio [0.8]</span><br><span class="line">    -y FLOAT    min overlap drop ratio [0.2]</span><br><span class="line">    -u          <span class="built_in">disable</span> post join contigs step <span class="built_in">which</span> may improve N50</span><br><span class="line">    --lowQ      INT</span><br><span class="line">                output contig regions with &gt;=INT% inconsistency <span class="keyword">in</span> BED format; 0 to <span class="built_in">disable</span> [70]</span><br><span class="line">  Trio-partition:</span><br><span class="line">    -1 FILE     hap1/paternal k-mer dump generated by <span class="string">&quot;yak count&quot;</span> []</span><br><span class="line">    -2 FILE     hap2/maternal k-mer dump generated by <span class="string">&quot;yak count&quot;</span> []</span><br><span class="line">    -c INT      lower bound of the binned k-mer<span class="string">&#x27;s frequency [2]</span></span><br><span class="line"><span class="string">    -d INT      upper bound of the binned k-mer&#x27;</span>s frequency [5]</span><br><span class="line">    -3 FILE     list of hap1/paternal <span class="built_in">read</span> names []</span><br><span class="line">    -4 FILE     list of hap2/maternal <span class="built_in">read</span> names []</span><br><span class="line">  Purge-dups:</span><br><span class="line">    -l INT      purge level. 0: no purging; 1: light; 2: aggressive [0 <span class="keyword">for</span> trio; 2 <span class="keyword">for</span> unzip]</span><br><span class="line">    -s FLOAT    similarity threshold <span class="keyword">for</span> duplicate haplotigs [0.75]</span><br><span class="line">    -O INT      min number of overlapped reads <span class="keyword">for</span> duplicate haplotigs [1]</span><br><span class="line">    --purge-cov INT</span><br><span class="line">                coverage upper bound of Purge-dups [auto]</span><br><span class="line">    --high-het  <span class="built_in">enable</span> this mode <span class="keyword">for</span> high heterozygosity sample [experimental, not stable]</span><br><span class="line">Example: ./hifiasm -o NA12878.asm -t 32 NA12878.fq.gz</span><br><span class="line">See `man ./hifiasm.1<span class="string">&#x27; for detailed description of these command-line options.</span></span><br></pre></td></tr></table></figure>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><div class="note pink no-icon flat"><p>典型的hifiasm命令行如下所示：</p>
</div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hifiasm <span class="operator">-</span>o <span class="operator">&lt;</span>outputPrefix<span class="operator">&gt;</span> <span class="operator">-</span>t <span class="operator">&lt;</span>nThreads<span class="operator">&gt;</span> <span class="operator">&lt;</span>HiFi<span class="operator">-</span>reads.fasta<span class="operator">&gt;</span></span><br><span class="line">#eg：</span><br><span class="line">hifiasm <span class="operator">-</span>o NA12878.asm <span class="operator">-</span>t <span class="number">32</span> NA12878.fq.gz</span><br></pre></td></tr></table></figure>
<p>其中<code>NA12878.fq.gz</code>提供输入reads，<code>-t</code>设置使用中的CPU数,<code>-o</code>输出文件的前缀名</p>
<p>当亲本短读可用时，hifiasm可以生成一对具有三位一体的单倍型解析程序集。要进行这种组装，需要先用<a href="https://github.com/lh3/yak">yak</a>计算k-mers，然后进行组装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yak count -b37 -t &lt;nThreads&gt; -o &lt;pat.yak&gt; &lt;paternal-short-reads.fastq&gt;</span><br><span class="line">yak count -b37 -t &lt;nThreads&gt; -o &lt;mat.yak&gt; &lt;maternal-short-reads.fastq&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#eg：</span></span><br><span class="line">yak count -k31 -b37 -t16 -o pat.yak paternal.fq.gz</span><br><span class="line">yak count -k31 -b37 -t16 -o mat.yak maternal.fq.gz</span><br></pre></td></tr></table></figure>
<p>然后我们用以下命令产生<code>the paternal assembly and the maternal assembly</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hifiasm -o &lt;outputPrefix&gt; -t &lt;nThreads&gt; -1 &lt;pat.yak&gt; -2 &lt;mat.yak&gt; &lt;HiFi-reads.fasta&gt;</span><br><span class="line"><span class="comment">#eg:</span></span><br><span class="line">hifiasm -o NA12878.asm -t 20 -1 pat.yak -2 mat.yak NA12878.fq.gz</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="对于非三重组装，hifiasm会生成以下文件："><a href="#对于非三重组装，hifiasm会生成以下文件：" class="headerlink" title="对于非三重组装，hifiasm会生成以下文件："></a>对于非三重组装，hifiasm会生成以下文件：</h2><p><strong>prefix.r_utg.gfa</strong>(Haplotype-resolved raw <a href="http://wgs-assembler.sourceforge.net/wiki/index.php/Celera_Assembler_Terminology">unitig</a> graph in <a href="https://github.com/GFA-spec/GFA-spec/blob/master/GFA-spec.md">GFA</a> format)：保留了组装生成的所有单体型信息，包括体细胞突变和重复的测序错误。<br><strong>prefix.p_utg.gfa</strong>(Haplotype-resolved processed unitig graph without small bubbles)：无小气泡的单倍型解析；去掉由于体细胞突变和数据背景噪音引起的small bubbles（这个并不是真正的单体型信息），对于高度杂合基因组物种优先选择这个结果。<br><strong>prefix.p_ctg.gfa</strong>(Primary assembly <a href="http://wgs-assembler.sourceforge.net/wiki/index.php/Celera_Assembler_Terminology">contig</a> graph)：对于低杂合度物种来说，优先选择该文件；对于高杂合度物种，该结果代表其中一个单倍型。<br><strong>prefix.a_ctg.gfa</strong>(Alternate assembly contig graph)：组装出来的另一套单体型基因组结果。</p>
<h2 id="对于三重组装，hifiasm会生成以下文件："><a href="#对于三重组装，hifiasm会生成以下文件：" class="headerlink" title="对于三重组装，hifiasm会生成以下文件："></a>对于三重组装，hifiasm会生成以下文件：</h2><p><strong>prefix.r_utg.gfa</strong>(Haplotype-resolved raw unitig graph in GFA format):保存了所有的单倍型信息。<br><strong>prefix.hap1.p_ctg.gfa</strong>(Phased paternal/haplotype1 contig graph):保留了阶段性父系/单倍型1组装。<br><strong>prefix.hap2.p_ctg.gfa</strong>(Phased maternal/haplotype2 contig graph):保留了阶段性母系/单倍型2组装。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>Cheng H, Concepcion G T, Feng X, et al. Haplotype-resolved de novo assembly with phased assembly graphs[J]. arXiv preprint arXiv:2008.01237, 2020.</p>
</blockquote>
<a class="btn-beautify button--animated purple larger" href="https://lxz9.com" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>基因组组装</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>HiFiasm</tag>
      </tags>
  </entry>
  <entry>
    <title>物种内共线性分析——JCVI安装以及数据下载（一）</title>
    <url>/2021/01/17/jcvi/</url>
    <content><![CDATA[<h1 id="物种内共线性分析步骤——JCVI安装以及数据下载（一）"><a href="#物种内共线性分析步骤——JCVI安装以及数据下载（一）" class="headerlink" title="物种内共线性分析步骤——JCVI安装以及数据下载（一）"></a>物种内共线性分析步骤——JCVI安装以及数据下载（一）</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>最简单的方法是通过PyPI安装它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jcvi</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者安装开发版本</span></span><br><span class="line">pip install git+git://github.com/tanghaibao/jcvi.git</span><br></pre></td></tr></table></figure>
<p>或者，如果要手动安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/tanghaibao/jcvi.git</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure>
<p>还有一些依赖包安装方法移步<a href="https://github.com/tanghaibao/jcvi">官网</a></p>
<h2 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h2><p>接下来重点说一下安装完成之后的使用，</p>
<p>1、下载测试数据<br>下载数据可以从<a href="https://phytozome.jgi.doe.gov/pz/portal.html#">Phytozome</a>官方直接下载，<br>当然也有另外一种方法就是直接在服务器操作下载，相比而言第二种省去了下载上传的时间，可以直接放到后台运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m jcvi.apps.fetch phytozome</span><br><span class="line">#输入第一行命令之后会弹出，只需输入自己注册过的Phyzome账号密码即可</span><br><span class="line">Phytozome Login: xxxxxxxx</span><br><span class="line">Phytozome Password:</span><br></pre></td></tr></table></figure>
<p>如果没有登录名，在<a href="https://phytozome.jgi.doe.gov/pz/portal.html#">此处</a>注册一个。<br>登录成功之后会自动弹出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Usage: </span><br><span class="line">    fetch.py phytozome species</span><br><span class="line"></span><br><span class="line">    Retrieve genomes <span class="keyword">and</span> annotations <span class="keyword">from</span> phytozome <span class="keyword">using</span> Globus API. Available</span><br><span class="line">    species listed below. Use comma <span class="keyword">to</span> give a list <span class="keyword">of</span> species <span class="keyword">to</span> download. <span class="keyword">For</span></span><br><span class="line">    example:</span><br><span class="line"></span><br><span class="line">    $ fetch.py phytozome Athaliana,Vvinifera,Osativa,Sbicolor,Slycopersicum</span><br><span class="line"></span><br><span class="line">    The downloader will prompt you <span class="keyword">to</span> enter Phytozome <span class="keyword">user</span> name <span class="keyword">and</span> password</span><br><span class="line">    during downloading. Please register <span class="keyword">for</span> a login <span class="keyword">at</span>:</span><br><span class="line">    https:<span class="operator">/</span><span class="operator">/</span>phytozome.jgi.doe.gov<span class="operator">/</span>pz<span class="operator">/</span>portal.html.</span><br><span class="line">    </span><br><span class="line">                 ZmaysPH207                      Zmays</span><br><span class="line">                    Zmarina                  Vvinifera</span><br><span class="line">                   Vcarteri                  Tpratense</span><br><span class="line">                     Tcacao                   Sviridis</span><br><span class="line">                 Stuberosum                  Spurpurea</span><br><span class="line">                 Spolyrhiza            Smoellendorffii</span><br><span class="line">              Slycopersicum                   Sitalica</span><br><span class="line">                    Sfallax                   Sbicolor</span><br><span class="line">                  Rcommunis                  Pvulgaris</span><br><span class="line">                  Pvirgatum               Ptrichocarpa</span><br><span class="line">                   Ppersica                    Ppatens</span><br><span class="line">                    Phallii                  Othomaeum</span><br><span class="line">             OsativaKitaake                    Osativa</span><br><span class="line">               Olucimarinus                Mtruncatula</span><br><span class="line">                  MspRCC299           MpusillaCCMP1545</span><br><span class="line">                Mpolymorpha                  Mguttatus</span><br><span class="line">                 Mesculenta                 Mdomestica</span><br><span class="line">                 Macuminata             Lusitatissimum</span><br><span class="line">                 Klaxiflora              Kfedtschenkoi</span><br><span class="line">                 Graimondii                       Gmax</span><br><span class="line">                     Fvesca               Esalsugineum</span><br><span class="line">                   Egrandis                    Dsalina</span><br><span class="line">                    Dcarota        CsubellipsoideaC169</span><br><span class="line">                  Csinensis                   Csativus</span><br><span class="line">                   Crubella               Creinhardtii</span><br><span class="line">                    Cpapaya               Cgrandiflora</span><br><span class="line">                Cclementina                   Bstricta</span><br><span class="line">                    Bstacei                  BrapaFPsc</span><br><span class="line">          Boleraceacapitata                Bdistachyon</span><br><span class="line">                Atrichopoda                  Athaliana</span><br><span class="line">                    Alyrata           Ahypochondriacus</span><br><span class="line">                   Ahalleri                   Acomosus</span><br><span class="line">                  Acoerulea      Vunguiculata_469_v1<span class="number">.1</span></span><br><span class="line">      Tintermedium_503_v2<span class="number">.1</span>         Taestivum_296_v2<span class="number">.2</span></span><br><span class="line">          Sviridis_500_v2<span class="number">.1</span>       SbicolorRio_468_v2<span class="number">.1</span></span><br><span class="line">         Pvirgatum_450_v4<span class="number">.1</span>      Pumbilicalis_456_v1<span class="number">.5</span></span><br><span class="line">      Ptrichocarpa_444_v3<span class="number">.1</span>           Phallii_495_v3<span class="number">.1</span></span><br><span class="line">        PhalliiHAL_496_v2<span class="number">.1</span>    PdeltoidesWV94_445_v2<span class="number">.1</span></span><br><span class="line">         Oeuropaea_451_v1<span class="number">.0</span>         Msinensis_497_v7<span class="number">.1</span></span><br><span class="line">             Lsativa_467_v5            Hvulgare_462_r1</span><br><span class="line">           Hannuus_494_r1<span class="number">.2</span>         Ghirsutum_458_v1<span class="number">.1</span></span><br><span class="line"> Czofingiensis_461_v5<span class="number">.2</span><span class="number">.3</span><span class="number">.2</span>           Cquinoa_392_v1<span class="number">.0</span></span><br><span class="line">        Carietinum_492_v1<span class="number">.0</span>       Bsylvaticum_490_v1<span class="number">.1</span></span><br><span class="line">         Bhybridum_463_v1<span class="number">.1</span> BdistachyonBd21_3_460_v1<span class="number">.1</span></span><br><span class="line">          Bbraunii_502_v2<span class="number">.1</span>    Athaliana_447_Araport11</span><br><span class="line">      Aofficinalis_498_V1<span class="number">.1</span>      Aoccidentale_449_v0<span class="number">.9</span></span><br><span class="line">  Ahypochondriacus_459_v2<span class="number">.1</span></span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  <span class="operator">-</span>h, <span class="comment">--help            Show this help message and exit</span></span><br><span class="line">  <span class="comment">--version=VERSION     Phytozome version, must be one of</span></span><br><span class="line">                        <span class="number">9</span><span class="operator">|</span><span class="number">10</span><span class="operator">|</span><span class="number">11</span><span class="operator">|</span><span class="number">12</span><span class="operator">|</span><span class="number">12</span>_unrestricted<span class="operator">|</span><span class="number">13</span> [<span class="keyword">default</span>: <span class="number">12</span>]</span><br><span class="line">  <span class="comment">--assembly            Download assembly [default: False]</span></span><br><span class="line">  <span class="comment">--format              Format to CDS and BED for synteny inference [default:</span></span><br><span class="line">                        <span class="literal">False</span>]</span><br><span class="line">  <span class="comment">--downloader=DOWNLOADER</span></span><br><span class="line">                        Use the specified downloader <span class="keyword">to</span> retrieve resources,</span><br><span class="line">                        must be <span class="keyword">one</span> <span class="keyword">of</span> curl<span class="operator">|</span>insecure<span class="operator">|</span>powershell<span class="operator">|</span>wget [<span class="keyword">default</span>:</span><br><span class="line">                        guess]</span><br><span class="line"></span><br><span class="line">JCVI utility libraries v1<span class="number">.0</span><span class="number">.12</span> [Copyright (c) <span class="number">2010</span><span class="number">-2021</span>, Haibao Tang]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要下载可直接输入上面的名称，<br>eg：我需要下载Zmays和Zmarina只需要输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m jcvi.apps.fetch phytozome Zmays,Zmarina</span><br></pre></td></tr></table></figure>
<p>非常方便的下载共线性分析需要用到的数据，而不需要你在官网自己查找！！</p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>本次笔者使用的数据为<code>Zmarina</code>,使用命令下载完成之后得到以下两个压缩文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -lh</span><br><span class="line">总用量 10M</span><br><span class="line">-rw-rw-r-- 1 lixingze lixingze 7.6M 10月   4 14:55 Zmarina_324_v2.2.cds.fa.gz</span><br><span class="line">-rw-rw-r-- 1 lixingze lixingze 2.4M 10月   4 14:55 Zmarina_324_v2.2.gene.gff3.gz</span><br></pre></td></tr></table></figure>
<p>通过<code>$ gunzip Zmarina_324_v2.2.*</code><br>解压得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -lh</span><br><span class="line">总用量 47M</span><br><span class="line">-rw-rw-r-- 1 lixingze lixingze 26M 2月   4 14:55 Zmarina_324_v2.2.cds.fa</span><br><span class="line">-rw-rw-r-- 1 lixingze lixingze 21M 2月   4 14:55 Zmarina_324_v2.2.gene.gff3</span><br></pre></td></tr></table></figure>
<p>下一步进行物种内共线性</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/tanghaibao/jcvi">https://github.com/tanghaibao/jcvi</a></p>
<a class="btn-beautify button--animated purple larger" href="https://lxz9.com" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>共线性分析</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>物种内共线性分析</tag>
        <tag>JCVI</tag>
      </tags>
  </entry>
  <entry>
    <title>lrzsz(Linux服务器和Mac互传文件工具)</title>
    <url>/2021/08/31/lrzsz/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="Mac电脑安装"><a href="#Mac电脑安装" class="headerlink" title="Mac电脑安装"></a>Mac电脑安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install lrzsz</span><br><span class="line"></span><br><span class="line">wget https://hub.fastgit.org/aikuyun/iterm2-zmodem/blob/master/iterm2-recv-zmodem.sh -P /usr/<span class="built_in">local</span>/bin</span><br><span class="line">wget https://hub.fastgit.org/aikuyun/iterm2-zmodem/blob/master/iterm2-send-zmodem.sh -P /usr/<span class="built_in">local</span>/bin</span><br><span class="line">chmod 777 /usr/<span class="built_in">local</span>/bin/*.sh  <span class="comment">#设置一下两个脚本的权限</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在本地/usr/local/bin/目录下保存iterm2-send-zmodem.sh 和iterm2-recv-zmodem.sh两个脚本</p>
</blockquote>
<h2 id="设置Iterm2的Tirgger特性"><a href="#设置Iterm2的Tirgger特性" class="headerlink" title="设置Iterm2的Tirgger特性"></a>设置Iterm2的Tirgger特性</h2><p>Mac电脑需要使用 iterm2 这个终端软件(<a href="https://iterm2.com/">https://iterm2.com/</a>)</p>
<p><strong><em>1. 打开偏好设置</em></strong><br><img src="https://z3.ax1x.com/2021/08/31/hU46KS.png"></p>
<p><strong><em>2. 进入</em></strong><br><strong>profiles-&gt;default-&gt;editProfiles-&gt;Advanced中的Tirgger</strong><br><img src="https://z3.ax1x.com/2021/08/31/hU4rgf.png"></p>
<p><strong><em>3. 添加两条trigger，分别设置 Regular expression，Action，Parameters，Instant如下</em></strong><br><img src="https://z3.ax1x.com/2021/08/31/hU4sv8.png"></p>
<div class="note pink no-icon flat"><p><strong>1.第一条</strong><br>        Regular expression: rz waiting to receive.**B0100<br>        Action: Run Silent Coprocess<br>        Parameters: /usr/local/bin/iterm2-send-zmodem.sh<br>        Instant: checked<br><strong>2.第二条</strong><br>        Regular expression: **B00000000000000<br>        Action: Run Silent Coprocess<br>        Parameters: /usr/local/bin/iterm2-recv-zmodem.sh<br>        Instant: checked</p>
</div>


<h1 id="服务器端安装"><a href="#服务器端安装" class="headerlink" title="服务器端安装"></a>服务器端安装</h1><h2 id="Root用户"><a href="#Root用户" class="headerlink" title="Root用户"></a>Root用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum -y install lrzsz  <span class="comment">#centos</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install lrzsz <span class="comment">#Ubuntu</span></span><br></pre></td></tr></table></figure>
<h2 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; <span class="built_in">cd</span> lrzsz-0.12.20</span><br><span class="line"></span><br><span class="line">./configure --prefix=/home/lixingze/sorfware/lrzsz</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/lixingze/sorfware/lrzsz/</span><br><span class="line">mkdir bash-command</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/lixingze/sorfware/lrzsz/bash-command/</span><br><span class="line">ln -s /home/lixingze/sorfware/lrzsz/bin/lrz rz </span><br><span class="line">ln -s /home/lixingze/sorfware/lrzsz/bin/lsz sz</span><br><span class="line"></span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/home/lixingze/sorfware/lrzsz/bash-command/</span><br></pre></td></tr></table></figure>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><div class="note purple no-icon flat"><p>直接输入<br>rz:上传文件到服务器<br>sz:下载文件到服务器</p>
</div>
<h2 id="rz"><a href="#rz" class="headerlink" title="rz"></a>rz</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line"></span><br><span class="line">rz [选项]</span><br><span class="line"></span><br><span class="line">选项说明：</span><br><span class="line">-+, --append  <span class="comment">#将文件内容追加到已存在的同名文件</span></span><br><span class="line">-a,--ascii  <span class="comment">#以文本方式传输(ASCII传输)</span></span><br><span class="line">-b, --binary  <span class="comment">#以二进制方式传输，推荐使用</span></span><br><span class="line">-c, --with-crc  <span class="comment">#使用16位CRC（X）</span></span><br><span class="line">-C, --allow-remote-commands  <span class="comment">#允许执行远程命令（Z）</span></span><br><span class="line">-D, --delay-startup N  <span class="comment">#等待N秒</span></span><br><span class="line">-e, --escape  <span class="comment">#对所有控制字符转义，建议使用</span></span><br><span class="line">-E, --rename  <span class="comment">#重命名已存在的任何文件，以点和数字作为后缀</span></span><br><span class="line">-p, --protect  <span class="comment">#对ZMODEM协议有效，如果目标文件已存在则跳过 </span></span><br><span class="line">-q, --quiet  <span class="comment">#安静执行，不输出提示信息</span></span><br><span class="line">-v, --verbose  <span class="comment">#输出传输过程中的提示信息</span></span><br><span class="line">-y, --overwrite  <span class="comment">#存在同名文件则替换</span></span><br><span class="line">-X, --xmodem  <span class="comment">#使用XMODEM协议</span></span><br><span class="line">--ymodem  <span class="comment">#使用YMODEM协议</span></span><br><span class="line">-Z, --zmodem  <span class="comment">#使用ZMODEM协议</span></span><br><span class="line">--version  <span class="comment">#显示版本信息</span></span><br><span class="line">--h, --<span class="built_in">help</span>  <span class="comment">#显示帮助信息</span></span><br><span class="line">-R, --restricted  <span class="comment">#受限、更安全的模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#短选项使用与长选项相同的参数</span></span><br></pre></td></tr></table></figure>
<h2 id="sz"><a href="#sz" class="headerlink" title="sz"></a>sz</h2><p><code>sz -h</code>参数查看详细内容，一般情况下直接输入rz/sz 进行文件本地与服务器之间的传送就足够了。</p>
<a class="btn-beautify button--animated purple larger" href="https://lxz9.com" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>物种内共线性分析——思路以及踩坑总结（二）</title>
    <url>/2021/01/17/mcscanX/</url>
    <content><![CDATA[<h1 id="物种内共线性分析（MCScanX-BLAST-TBtools）"><a href="#物种内共线性分析（MCScanX-BLAST-TBtools）" class="headerlink" title="物种内共线性分析（MCScanX+BLAST+TBtools）"></a><font face="微软雅黑" color="#000080" size="5">物种内共线性分析（MCScanX+BLAST+TBtools）</font></h1><p><strong>数据要求</strong>：做物种内共线性分析的话主要需要的是<br>全基因组序列、cds或pep序列、gff3/gtf序列三者缺一不可。<br>上一节下载好了cds序列以及gff3序列文件，以此为例<br><strong>（数据可在Phyzome下载，也可以在服务器上在线下载）</strong></p>
<p><strong>软件要求</strong>：MCScanX、blast、TBtools（JCVI）</p>
<h1 id="物种内blast"><a href="#物种内blast" class="headerlink" title="物种内blast"></a><strong>物种内blast</strong></h1><p>物种内blast 使用cds或pep序列进行自我比对，结果*.blast格式得到此结果（这一步耗时最长，可以使用TBtools一键完成，有服务器的同学可以使用服务器运行）</p>
<h2 id="blast构建索引-makeblastdb"><a href="#blast构建索引-makeblastdb" class="headerlink" title="blast构建索引 | makeblastdb"></a>blast构建索引 | makeblastdb</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">makeblastdb -in Zmarina_324_v2.2.cds.fa -dbtype nucl -out Zmarina.db</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<blockquote>
<p>-in 后接输入文件，你要格式化的fasta序列<br>-dbtype 后接序列类型，nucl为核酸，prot为蛋白<br>-out 后接数据库名，自定义，后续blast+要用到的-db的参数<br>-logfile 日志文件，如果没有默认输出到屏幕</p>
</blockquote>
<h2 id="比对核酸数据库（blastn）"><a href="#比对核酸数据库（blastn）" class="headerlink" title="比对核酸数据库（blastn）"></a>比对核酸数据库（blastn）</h2><p>如果下载的cds序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blastn  -query Zmarina_324_v2.2.cds.fa -db Zmarina.db -out Zmarina.blast -evalue 1e-10 -num_threads 10 -outfmt 6 -num_alignments 5</span><br></pre></td></tr></table></figure>
<h2 id="比对蛋白数据库（blastp）"><a href="#比对蛋白数据库（blastp）" class="headerlink" title="比对蛋白数据库（blastp）"></a>比对蛋白数据库（blastp）</h2><p>如果下载为pep序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blastp  -query Zmarina_324_v2.2.pep.fa -db Zmarina.db -out Zmarina.blast -evalue 1e-10 -num_threads 10 -outfmt 6 -num_alignments 5</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<blockquote>
<p>-query： 输入文件路径及文件名<br>-out：输出文件路径及文件名<br>-db：格式化了的数据库路径及数据库名<br>-outfmt：输出文件格式，总共有12种格式，6是tabular格式对应BLAST的m8格式<br>-evalue：设置输出结果的e-value值<br>-num_threads：线程数<br>-num_alignments: 设置每个query保留多少条匹配结果</p>
</blockquote>
<h1 id="gff序列简化"><a href="#gff序列简化" class="headerlink" title="gff序列简化"></a><strong>gff序列简化</strong></h1><p>已知gff序列分成许多行，其实我们只需要四行，所以需要将这四行提取出来得到简化后的gff文件<br>简化的步骤可用脚本获得如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##Phytozome GFF3文件处理</span></span><br><span class="line">awk -F <span class="string">&#x27;[\t;]&#x27;</span> <span class="string">&#x27;&#123;if($3==&quot;mRNA&quot;)print $1&quot;\t&quot;$10&quot;\t&quot;$4&quot;\t&quot;$5&#125;&#x27;</span> Zmarina_324_v2.2.gene.gff3 | sed <span class="string">&#x27;s/Name=//g&#x27;</span> &gt; Zmarina_324_v2.2.gene.gff3.gff</span><br><span class="line"><span class="comment">##CDS序列文件处理</span></span><br><span class="line">cut -d <span class="string">&quot; &quot;</span> -f 1 Zmarina_324_v2.2.cds.fa &gt; Zmarina_324_v2.2.cds.simple.fa、</span><br><span class="line"><span class="comment">##提取第一列染色体（control文件，设置需要展示的染色体信息（和gff的第一列一致））</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> ./CH_word_ls.txt &gt; ./out.txt</span><br><span class="line"><span class="comment">##删除文件 text中第一列</span></span><br><span class="line"><span class="comment">#方式一 </span></span><br><span class="line">awk <span class="string">&#x27;&#123;$1=&quot;&quot;;print $0&#125;&#x27;</span> text</span><br><span class="line"><span class="comment">#方式二</span></span><br><span class="line">sed -e <span class="string">&#x27;s/[^ ]* //&#x27;</span> text</span><br></pre></td></tr></table></figure>
<h1 id="MCScanX"><a href="#MCScanX" class="headerlink" title="MCScanX"></a><strong>MCScanX</strong></h1><p>命令行格式：MCScanX + 名称（这里需要注意的是前面得到的简化后的gff文件以及blast之后的结果文件；命名须一致）<br>比如得到的blast结果为<code>zm.blast</code>,简化为四列后的gff文件为<code>zm.gff</code><br>使用命令<code>MCScanX zm</code>即可得出共线性结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -lh</span><br><span class="line">总用量 6.5M</span><br><span class="line">-rw-r--r--. 1 lixingze lixingze 5.6M 12月 17 00:55 zm.blast</span><br><span class="line">-rw-r--r--. 1 lixingze lixingze 4.1K 12月 17 00:55 zm.collinearity</span><br><span class="line">-rw-r--r--. 1 lixingze lixingze 845K 12月 17 00:55 zm.gff</span><br><span class="line">drwxr-x---. 2 lixingze lixingze  28K 12月 17 00:55 zm.html</span><br><span class="line">-rw-r--r--. 1 lixingze lixingze  20K 12月 17 00:55 zm.tandem</span><br></pre></td></tr></table></figure>
<p>运行此软件即可得出结果文件：<br>名称.html,<br>名称.collinearity, （包含了共线性分析的结果）<br>名称.tandem（串联重复）</p>
<p>在这一步遇到了问题是一直出不来结果的原因：<br>上面gff格式的问题tab改为空格等原因导致软件跑不出来共线性。可以通过文本软件检查一下格式是否准确</p>
<h1 id="可视化circos"><a href="#可视化circos" class="headerlink" title="可视化circos"></a><strong>可视化circos</strong></h1><p>在这里可以用的有TBtools、circos、JCVI等软件进行可视化其中需要配置很多的文件进行分析出图<br>准备好简化后的四列gff文件；<code>*.blast</code>文件<br>以及MCScanX分析得出的<code>.collinearity</code>和<code>.tandem</code>进一步分析步骤<br>这里以TBtools为例进行说明：<br>整体流程如下～</p>
<ol>
<li>用到 Advanced Circos 模块 </li>
</ol>
<p><img src="https://z3.ax1x.com/2021/02/04/y14BX8.png" alt="y14BX8.png"></p>
<p>需要准备的文件如下：</p>
<ul>
<li><p>染色体长度文件：<br>用到 fasta stat 模块， 将基因组的文件输入进去，输出整个染色体长度的文件；提取染色体的长度信息，保存为文本文件，ChrLen.txt （ Advanced Circos 模块 需要的文件1）</p>
</li>
<li><p>基因组内的共线性：<br>将共线性分析结果，转换成GenePairTable（模块Text Merge for MCScanX;输入前面得到的.collinearity文件，Merge Mode选择Collinear输出txt文件命名为GenePair.tab.txt）,之后需要继续转换为LinkedRegion文件（模块Text Transformat for Micro-Synteny View;Input File Format为<strong>GenePair</strong>，输出命名为LickedRegion.tab.txt）</p>
</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/02/04/y14rnS.png" alt="y14rnS.png"></p>
<p>这一步做完就得到了他们的共线性关系<br>需要的是展示WRKY基因家族内部参与的复制事件，所以与WRKY·ID相关的连接线应该被高亮出来。或者我们直接补充一些高亮的线进去就可以了<br>直接使用TBtools的文本区块提取工具【Text Block Extract】</p>
<p><img src="https://z3.ax1x.com/2021/02/04/y14s0g.png" alt="y14s0g.png"></p>
<p><img src="https://z3.ax1x.com/2021/02/04/y14w1P.png" alt="y14w1P.png"></p>
<p><img src="https://z3.ax1x.com/2021/02/04/y14y7Q.png" alt="y14y7Q.png"></p>
<h1 id="结果图"><a href="#结果图" class="headerlink" title="结果图"></a>结果图</h1><p><img src="https://z3.ax1x.com/2021/02/04/y14gts.md.jpg" alt="y14gts.md.jpg"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>关于TBtools这一部分内容可以参考<a href="https://www.meiwen.com.cn/subject/ljltbctx.html">此处更为详细</a></p>
<a class="btn-beautify button--animated purple larger" href="https://lxz9.com" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>共线性分析</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>物种内共线性分析</tag>
        <tag>BLAST</tag>
        <tag>MCScanX</tag>
        <tag>TBtools</tag>
      </tags>
  </entry>
  <entry>
    <title>转录组分析流程｜基于salmon转录组批量定量流程（三）</title>
    <url>/2021/01/20/salmon/</url>
    <content><![CDATA[<p>TransDecoder那一步最终得到了<code>*.cds</code>序列，之后就需要用到<strong>salmon</strong>进行下面操作<br><img src="https://z3.ax1x.com/2021/01/30/yk4874.md.png" alt="salmon"></p>
<h1 id="salmon介绍"><a href="#salmon介绍" class="headerlink" title="salmon介绍"></a>salmon介绍</h1><p><code>Salmon</code>是不基于比对计数而直接对基因进行定量的工具，适用于转录组、宏基因组等的分析。Salmon通过许多不同的创新来提高其准确性和速度，包括使用选择性比对（传统读取比对中的准确但快速计算的代理）以及大规模并行的随机折叠变分推理。</p>
<blockquote>
<p>其优势是：</p>
</blockquote>
<ol>
<li>定量时考虑到不同样品中基因长度的改变（比如不同isoform的使用）</li>
<li>速度快、需要的计算资源和存储资源小</li>
<li>敏感性高，不会丢弃匹配到多个基因同源区域的reads</li>
<li>可以直接校正GC-bias</li>
<li>自动判断文库类型</li>
</ol>
<h1 id="使用Salmon"><a href="#使用Salmon" class="headerlink" title="使用Salmon"></a>使用Salmon</h1><p><code>salmon</code>有两种“操作模式”。首先，要求您为转录组建立索引，但随后需要直接处理读取。第二种模式仅要求您提供转录组的FASTA文件和包含一组比对的<code>.sam</code>或<code>.bam</code></p>
<h2 id="准备转录组索引-mapping-based-mode"><a href="#准备转录组索引-mapping-based-mode" class="headerlink" title="准备转录组索引(mapping-based mode)"></a>准备转录组索引(mapping-based mode)</h2><p><strong>生成decoy-aware transcriptome的方法有两种:</strong></p>
<ul>
<li><p>  第一种方法是通过将你想要索引的注释转录本映射到生物体基因组的hard-masked version来计算一组诱饵序列。可以通过minimap2来实现或者使用<a href="https://github.com/COMBINE-lab/SalmonTools/blob/master/scripts/generateDecoyTranscriptome.sh">generateDecoyTranscriptome.sh</a>脚本来实现</p>
</li>
<li><p>  第二种是将生物的整个基因组用作诱饵序列。这可以通过将基因组连接到要索引的转录组的末端并填充decoys.txt染色体名称的文件。关于如何准备这种诱饵序列的详细说明可以在<a href="https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/">这里</a>找到。</p>
</li>
</ul>
<p><strong>如果不使用预先计算的索引，则按以下方式运行salmon</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">salmon index <span class="operator">-</span>t transcripts.fa <span class="operator">-</span>i transcripts_index</span><br></pre></td></tr></table></figure>
<h2 id="定量-mapping-based-mode"><a href="#定量-mapping-based-mode" class="headerlink" title="定量(mapping-based mode)"></a>定量(mapping-based mode)</h2><p>以使用Salmon命令直接针对此索引来量化任何一组读取(say, paired-end reads in files reads1.fq and reads2.fq)<code>quant</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">salmon quant <span class="operator">-</span>i transcripts_index <span class="operator">-</span>l <span class="operator">&lt;</span>LIBTYPE<span class="operator">&gt;</span> <span class="number">-1</span> reads1.fq <span class="number">-2</span> reads2.fq <span class="comment">--validateMappings -o transcripts_quant</span></span><br></pre></td></tr></table></figure>
<p>如果使用的是单端测序reads，则将它们带有如下<code>-r</code>标记：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">salmon quant <span class="operator">-</span>i transcripts_index <span class="operator">-</span>l <span class="operator">&lt;</span>LIBTYPE<span class="operator">&gt;</span> <span class="operator">-</span>r reads.fq <span class="comment">--validateMappings -o transcripts_quant</span></span><br></pre></td></tr></table></figure>
<h1 id="向Salmon提供多个读取文件"><a href="#向Salmon提供多个读取文件" class="headerlink" title="向Salmon提供多个读取文件"></a>向Salmon提供多个读取文件</h1><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>通过前面的trandecoder得到序列<code>LXZ_30sample_longest.cds.fa</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">salmon index -t LXZ_30sample_longest.cds.fa -i LXZ_30sample_longest.cds.fa_index -p 20</span><br></pre></td></tr></table></figure>
<p>通过<a href="https://lixingze.xyz/2021/01/24/%E8%BD%AC%E5%BD%95%E7%BB%84de%20novo%E7%BB%84%E8%A3%85/">教程（一）</a>和<a href="https://lixingze.xyz/2021/01/27/TransDecoder/">教程（二）</a>的处理之后得到的序列为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LXZ_1_A_1.cor.p.fq.gz    LXZ_1_A_2.cor.p.fq.gz</span><br><span class="line">LXZ_2_B_1.cor.p.fq.gz    LXZ_2_B_2.cor.p.fq.gz</span><br><span class="line">LXZ_3_C_1.cor.p.fq.gz    LXZ_3_C_2.cor.p.fq.gz</span><br><span class="line">LXZ_4_D_1.cor.p.fq.gz    LXZ_4_D_2.cor.p.fq.gz</span><br><span class="line">LXZ_5_E_1.cor.p.fq.gz    LXZ_5_E_2.cor.p.fq.gz</span><br></pre></td></tr></table></figure>
<p>整理样本信息表，命名为sampleFile，内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Samp    conditions    individual</span><br><span class="line">LXZ_1_A    LXZ_    <span class="number">1</span>_A</span><br><span class="line">LXZ_2_B    LXZ_    <span class="number">2</span>_B</span><br><span class="line">LXZ_3_C    LXZ_    <span class="number">3</span>_C</span><br><span class="line">LXZ_4_D    LXZ_    <span class="number">4</span>_D</span><br><span class="line">LXZ_5_E    LXZ_    <span class="number">5</span>_E</span><br></pre></td></tr></table></figure>
<h2 id="循环定量多个样品的表达量"><a href="#循环定量多个样品的表达量" class="headerlink" title="循环定量多个样品的表达量"></a>循环定量多个样品的表达量</h2><p>采用for循环进行批量定量</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">for samp in `tail -n +2 sampleFile | cut -f 1`; do salmon quant -l A -1 $&#123;samp&#125;_1.cor.p.fq.gz -2 $&#123;samp&#125;_2.cor.p.fq.gz  -i /home/lixingze/data/salmon/test/LXZ_30samples_longest.cds.fa_index -o $&#123;samp&#125;/$&#123;samp&#125;.salmon.count -p 20  &gt;$&#123;samp&#125;.salmon.log 2&gt;&amp;1; done &amp;  </span><br></pre></td></tr></table></figure>
<p>最后可以批量在每个样本下面生成对应名称的文件每个文件中的<code>quant.sf</code>即为定量结果，以下为示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Name    Length  EffectiveLength TPM     NumReads</span><br><span class="line">Name1    <span class="number">13476</span>   <span class="number">13184.752</span>       <span class="number">22.536164</span>       <span class="number">5948.000</span></span><br><span class="line">Name2    <span class="number">12195</span>   <span class="number">11903.752</span>       <span class="number">0.000000</span>        <span class="number">0.000</span></span><br><span class="line">Name3   <span class="number">12174</span>   <span class="number">11882.752</span>       <span class="number">0.000000</span>        <span class="number">0.000</span></span><br><span class="line">Name4    <span class="number">10890</span>   <span class="number">10598.752</span>       <span class="number">0.000000</span>        <span class="number">0.000</span></span><br><span class="line">Name5    <span class="number">9384</span>    <span class="number">9092.752</span>        <span class="number">26.711841</span>       <span class="number">4862.036</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后如果要将所有样品做成矩阵可以进行提取TPM那一列，最后合并</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">awk ‘ &#123;print $4&#125; ‘ quant.sf &gt;quant.sf_extracted </span><br><span class="line">#表明提取第四列的内容`quant.sf_extracted`为输出文件可以自定义命名，提取完成之后合并的话，修改TPM名称为对应样本名称 </span><br><span class="line">awk ‘ &#123;print $1&#125; ‘ quant.sf &gt;ID</span><br><span class="line">#提取文档第一列ID名称</span><br><span class="line">paste id quant.sf_extracted quant.sf_extracted <span class="operator">&gt;</span> final_matrix</span><br><span class="line">#将所有的提取文件合并在一起生成最终的矩阵，可通过WGCNA来进行共表达分析</span><br></pre></td></tr></table></figure>
<p>最终处理完成！</p>
<h2 id="整理Salmon定量文件用于DESeq2差异基因鉴定"><a href="#整理Salmon定量文件用于DESeq2差异基因鉴定" class="headerlink" title="整理Salmon定量文件用于DESeq2差异基因鉴定"></a>整理Salmon定量文件用于DESeq2差异基因鉴定</h2><p>此步骤参考<code>生信宝典</code>公众号相关内容,具体内容本文不在复述，有需要的可以访问<a href="https://blog.csdn.net/qazplm12_3/article/details/111056012">此处</a><br>大致内容为：<br>找到Salmon的输出文件并压缩起来，用于下载到本地进行差异分析。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 列出salmon的输出文件</span><br><span class="line">find . <span class="operator">-</span>name quant.sf</span><br><span class="line"># 这个压缩包下载解压到本地</span><br><span class="line">zip quant.sf.zip `find . <span class="operator">-</span>name quant.sf`</span><br></pre></td></tr></table></figure>
<p>./LXZ_1_A.salmon.count/quant.sf<br>./LXZ_2_B.salmon.count/quant.sf<br>./LXZ_3_C.salmon.count/quant.sf<br>./LXZ_4_D.salmon.count/quant.sf<br>./LXZ_5_E.salmon.count/quant.sf</p>
<p>生成辅助文件，指出每个样品对应的自己的quant.sf文件，便于导入tximport包。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 生成一个两列文件方便R导入</span><br><span class="line"># xargs接收上一步的输出，按批次提供给下游程序作为输入</span><br><span class="line"># -i: 用&#123;&#125;表示传递的值</span><br><span class="line">cut <span class="operator">-</span>f <span class="number">1</span> sampleFile <span class="operator">|</span> xargs <span class="operator">-</span>i echo <span class="operator">-</span>e &quot;&#123;&#125;\t&#123;&#125;/&#123;&#125;.salmon.count/quant.sf&quot; <span class="operator">&gt;</span>salmon.output</span><br><span class="line">head salmon.output</span><br></pre></td></tr></table></figure>
<h1 id="重要选项说明"><a href="#重要选项说明" class="headerlink" title="重要选项说明"></a>重要选项说明</h1><p>Salmon向用户提供了许多有用的可选命令行参数,通过<code>salmon quant -h</code>查看</p>
<h2 id="p-threads"><a href="#p-threads" class="headerlink" title="-p/--threads"></a><code>-p</code>/<code>--threads</code></h2><p>设置线程数，根据配置自行选择</p>
<h2 id="validateMappings"><a href="#validateMappings" class="headerlink" title="--validateMappings"></a><code>--validateMappings</code></h2><p>在将测序读段映射到转录组时启用选择性比对。这可以提高映射的敏感性和特异性，结果可以提高定量准确性。</p>
<h2 id="useEM"><a href="#useEM" class="headerlink" title="--useEM"></a><code>--useEM</code></h2><p>使用“标准” EM算法代替变量贝叶斯EM算法来优化丰度估计。</p>
<h2 id="seqBias"><a href="#seqBias" class="headerlink" title="--seqBias"></a><code>--seqBias</code></h2><p>能够学习和纠正输入数据中特定于序列的偏差。默认情况下，Salmon使​​用从输入开始的1,000,000次读取来学习特定于序列的偏差参数。如果要更改从中学习模型的样本数，可以使用<code>--numBiasSamples </code>参数。</p>
<h2 id="l-A-libType-A"><a href="#l-A-libType-A" class="headerlink" title="-l A/--libType A"></a><code>-l A</code>/<code>--libType A</code></h2><p>基于对齐方式的自动库类型检测,自动判断文库类型，尤其适用于链特异性文库.</p>
<h2 id="gcBias"><a href="#gcBias" class="headerlink" title="--gcBias"></a><code>--gcBias</code></h2><p>校正测序片段GC含量，获得更准确的转录本定量结果</p>
<h1 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h1><p>如果有需要更详细的了解软件的具体内容请参照salmon官方文档，以及github。</p>
<a class="btn-beautify button--animated purple larger" href="https://salmon.readthedocs.io/en/latest/index.html" title="点击前往Salmon官方文档"><i class="far fa-hand-point-right"></i><span>点击前往Salmon官方文档</span></a>

<a class="btn-beautify button--animated purple larger" href="https://lixingze.xyz" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>转录组分析</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>转录组组装</tag>
        <tag>软件</tag>
        <tag>salmon</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用教程｜入门指南</title>
    <url>/2021/01/17/Markdown/</url>
    <content><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a><font face="微软雅黑" color="#000080" size="5">导语</font></h1><p>这是我的第一篇文章，写博客主要目的是把自己所学到的知识整理归纳起来，自己每次总结的过程也是不断学习重复巩固的过程，因为博文的编写需要用到Markdown所以下面先介绍一下具体的使用方法<br>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。<br>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、StackExchange、OpenStreetMap、SourceForge、简书等，甚至还能被使用来撰写电子书。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a><font face="微软雅黑" color="#000080" size="5">标题</font></h1><p>要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a><font face="微软雅黑" color="#000080" size="5">字体</font></h1><h2 id="字体、字号、颜色设置"><a href="#字体、字号、颜色设置" class="headerlink" title="字体、字号、颜色设置"></a><font face="微软雅黑" color="#20B2AA">字体、字号、颜色设置</font></h2><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;font face=<span class="string">&quot;微软雅黑&quot;</span> &gt;微软雅黑字体&lt;/font&gt;</span><br><span class="line">&lt;font face=<span class="string">&quot;黑体&quot;</span> &gt;黑体&lt;/font&gt;</span><br><span class="line">&lt;font face=<span class="string">&quot;楷体&quot;</span>&gt;楷体&lt;/font&gt;</span><br><span class="line">&lt;font size=3 &gt;3号字&lt;/font&gt;</span><br><span class="line">&lt;font size=4 &gt;4号字&lt;/font&gt;</span><br><span class="line">&lt;font color=<span class="comment">#FF0000 &gt;红色&lt;/font&gt;</span></span><br><span class="line">&lt;font color=<span class="comment">#008000 &gt;绿色&lt;/font&gt;</span></span><br><span class="line">&lt;font color=<span class="comment">#0000FF &gt;蓝色&lt;/font&gt;</span></span><br><span class="line">&lt;font face=<span class="string">&quot;微软雅黑&quot;</span> color=<span class="comment">#FF0000 size=5&gt;微软雅黑字体，颜色为红色，字体大小5号&lt;/font&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><font face="微软雅黑">微软雅黑字体</font><br><font face="黑体">黑体</font><br><font face="楷体">楷体</font><br><font size="3">3号字</font><br><font size="4">4号字</font><br><font color="#FF0000">红色</font><br><font color="#008000">绿色</font><br><font color="#0000FF">蓝色</font><br><font face="微软雅黑" color="#FF0000" size="5">微软雅黑字体，颜色为红色，字体大小5号</font></p>
<h2 id="字体加粗、倾斜"><a href="#字体加粗、倾斜" class="headerlink" title="字体加粗、倾斜"></a><font face="微软雅黑" color="#20B2AA">字体加粗、倾斜</font></h2><p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**加粗的文字**</span></span><br><span class="line"><span class="emphasis">*倾斜的文字*</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*斜体加粗的文字<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~加删除线的文字~~</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><strong>加粗的文字</strong><br><em>倾斜的文字</em><br><strong><em>斜体加粗的文字</em></strong><br><del>加删除线的文字</del></p>
<h2 id="为文字添加背景"><a href="#为文字添加背景" class="headerlink" title="为文字添加背景"></a><font face="微软雅黑" color="#20B2AA">为文字添加背景</font></h2><p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">yellow</span>&gt;</span></span>背景色yellow<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">blue</span>&gt;</span></span>背景色是blue<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">red</span>&gt;</span></span>背景色是red<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<table><tr><td bgcolor="yellow">背景色yellow</td></tr></table>
<table><tr><td bgcolor="blue">背景色是blue</td></tr></table>
<table><tr><td bgcolor="red">背景色是red</td></tr></table>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a><font face="微软雅黑" color="#000080" size="5">列表</font></h1><p>Markdown 支持有序列表和无序列表.<br>列表嵌套（上一级和下一级之间敲三个空格即可）</p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a><font face="微软雅黑" color="#20B2AA">无序列表</font></h2><p>使用星号, 加号, 和连字符 – 这些符号是可互换的:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">-</span>   Blue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>  Red</li>
</ul>
<ul>
<li>  Green</li>
</ul>
<ul>
<li>  Blue</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a><font face="微软雅黑" color="#20B2AA">有序列表</font></h2><p>使用数字加句号:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a><font face="微软雅黑" color="#000080" size="5">引用</font></h1><p>使用标记符<code>&gt;</code>对内容进行引用：</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 后面是我引用内容</span></span><br><span class="line"><span class="section">#引用的多层嵌套</span></span><br><span class="line"><span class="quote">&gt;  引用1</span></span><br><span class="line">&gt;&gt;  引用2</span><br><span class="line">&gt;&gt;&gt;  引用3</span><br><span class="line">&gt;&gt;  </span><br><span class="line">&gt;&gt;  引用2</span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt;  引用1</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<blockquote>
<p>后面是我引用内容</p>
</blockquote>
<blockquote>
<p> 引用1</p>
<blockquote>
<p> 引用2</p>
<blockquote>
<p> 引用3</p>
</blockquote>
<p> 引用2</p>
</blockquote>
<p> 引用1</p>
</blockquote>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a><font face="微软雅黑" color="#000080" size="5">超链接</font></h1><p>Markdown 支持两种链接形式: 内联 和 引用.<br>这两种形式下链接文本的定界符都是<code>[中括号]</code>.<br>要创建内联链接, 只需在链接文本的右括号后面紧接一对圆括号. 圆括号里面放所需的 URL 链接, 还可以放一个 可选 的链接标题, 标题要用引号包围.</p>
<p>示例一：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">名称</span>](<span class="link">所在地址 &quot;title&quot;</span>)</span><br><span class="line">[<span class="string">名称</span>](<span class="link">具体地址</span>)</span><br><span class="line">欢迎大家，来到[<span class="string">Li Xingze&#x27;s Blog</span>](<span class="link">https://lixingze.xyz</span>)</span><br><span class="line">欢迎大家，来到[<span class="string">百度</span>](<span class="link">https://baidu.com</span>)</span><br><span class="line">[<span class="string">必应</span>](<span class="link">https://cn.bing.com/</span>)</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>欢迎大家，来到<a href="https://lixingze.xyz/">Li Xingze’s Blog</a><br>欢迎大家，来到<a href="https://baidu.com/">百度</a><br><a href="https://cn.bing.com/">必应</a></p>
<p>示例二：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我目前用的几个搜索引擎是：[<span class="string">谷歌</span>][<span class="symbol">2</span>]、[<span class="string">百度</span>][<span class="symbol">3</span>]、[<span class="string">必应</span>][<span class="symbol">随便输入</span>]</span><br><span class="line">欢迎大家来我的[<span class="string">博客</span>][<span class="symbol">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">https:lixingze.xyz</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">https://www.baidu.com/</span></span><br><span class="line">[<span class="symbol">3</span>]:<span class="link">https://www.google.cn/&quot;Google&quot;</span></span><br><span class="line">[<span class="symbol">随便输入</span>]:<span class="link">https://cn.bing.com/</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>我目前用的几个搜索引擎是：<a href="https://www.baidu.com/">谷歌</a>、<a href="https://www.google.cn/%22Google%22">百度</a>、<a href="https://cn.bing.com/">必应</a><br>欢迎大家来我的<a href="https://lixingze.xyz/">博客</a></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a><font face="微软雅黑" color="#000080" size="5">图片</font></h1><p>通常, 要用 “原生” 的语法在纯文本格式中插入图片是很困难的.<br>Markdown 使用了类似链接的语法来插入图片, 包含两种形式: 内联 和 引用.<br>内联图片语法如下:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg &quot;Optional title&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>也就是:<br>一个感叹号:<code>!</code>;<br>紧跟着一对方括号, 包含了图片的<code>alt</code>属性;<br>紧跟着一对圆括号, 包含了图片的 URL 或者路径, 以及一个可选的用单引号或双引号包裹的<code>title</code>属性.</p>
<p><img src="https://raw.githubusercontent.com/lxingze/photo/main/img/markdown_logo.png"><br><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1969454436,2593720224&fm=26&gp=0.jpg" width="50%" height="50%"></p>
<p>注意：Markdown 没有语法指定图片尺寸; 如果需要指定图片尺寸, 可以使用 HTML<code>&lt;img&gt;</code>标签.</p>
<h2 id="设置设置图片百分比"><a href="#设置设置图片百分比" class="headerlink" title="设置设置图片百分比"></a>设置设置图片百分比</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://图片链接&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a>设置图片大小</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://图片链接&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> &gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="设置图片居中"><a href="#设置图片居中" class="headerlink" title="设置图片居中"></a>设置图片居中</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">right</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://图片链接&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="两张图片并排显示"><a href="#两张图片并排显示" class="headerlink" title="两张图片并排显示"></a>两张图片并排显示</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> &gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> &gt;</span></span>  </span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a><font face="微软雅黑" color="#000080" size="5">表格</font></h1><p>举个简单的小例子</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---------------------------</span><br><span class="line">学习计划 | 任务</span><br><span class="line">-------- | -----</span><br><span class="line">英语 | 背单词</span><br><span class="line">数学 | 做卷子</span><br><span class="line">语文 | 背古诗</span><br><span class="line">---------------------------</span><br></pre></td></tr></table></figure>
<hr>
<table>
<thead>
<tr>
<th>学习计划</th>
<th>任务</th>
</tr>
</thead>
<tbody><tr>
<td>英语</td>
<td>背单词</td>
</tr>
<tr>
<td>数学</td>
<td>做卷子</td>
</tr>
<tr>
<td>语文</td>
<td>背古诗</td>
</tr>
</tbody></table>
<p>当然还可以制作流程图等等</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font face="微软雅黑" color="#000080" size="5">总结</font></h1><p>其实Markdown的功能还有很多，只要去不断学习就会做出更好的文章，让文章的内容更加丰富<br>更多内容点击进入<a href="https://markdown-zh.readthedocs.io/en/latest/">Markdown中文文档</a></p>
<a class="btn-beautify button--animated purple larger" href="https://markdown-zh.readthedocs.io/en/latest/" title="Markdown"><i class="far fa-hand-point-right"></i><span>Markdown</span></a>

<p>不断更新完善中<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">ing
  </button><span class="hide-content">I'm Li</span></span></p>
<p>最后附上<font face="微软雅黑" color="#DC143C" size="3">颜色对照表</font>供大家参考</p>
<h1 id="数学常用符号"><a href="#数学常用符号" class="headerlink" title="数学常用符号"></a>数学常用符号</h1><blockquote>
<p>很多时候需要去写一些特殊数学符号的内容就需要使用到代码如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th><font color="#F0F8FF">符号</font></th>
<th><font color="#F0F8FF">代码</font></th>
<th><font color="#F0F8FF">描述</font></th>
</tr>
</thead>
<tbody><tr>
<td>∑</td>
<td>$\sum$</td>
<td>求和公式</td>
</tr>
<tr>
<td>∑𝑛𝑖=0</td>
<td>$\sum_{i=0}^n$</td>
<td>求和上下标</td>
</tr>
<tr>
<td>∏</td>
<td>$\prod_{i=0}^n$</td>
<td>N元乘积</td>
</tr>
<tr>
<td>∏𝑛𝑖=0</td>
<td>$\prod_{i=0}^n$</td>
<td>N元乘积上下标</td>
</tr>
<tr>
<td>÷</td>
<td>$\div$</td>
<td>除号</td>
</tr>
<tr>
<td>×</td>
<td>$\times$</td>
<td>乘号</td>
</tr>
<tr>
<td>∣</td>
<td>$\mid$</td>
<td>竖线</td>
</tr>
<tr>
<td>⋅</td>
<td>$\cdot$</td>
<td>点</td>
</tr>
<tr>
<td>∘</td>
<td>$\circ$</td>
<td>圈</td>
</tr>
<tr>
<td>∗</td>
<td>$\ast$</td>
<td>星号</td>
</tr>
<tr>
<td>≤</td>
<td>$\leq$</td>
<td>小于等于</td>
</tr>
<tr>
<td>≥</td>
<td>$\geq$</td>
<td>大于等于</td>
</tr>
<tr>
<td>≠</td>
<td>$\neq$</td>
<td>不等于</td>
</tr>
<tr>
<td>∀</td>
<td>$\forall$</td>
<td>任意</td>
</tr>
<tr>
<td>∃</td>
<td>$\exists$</td>
<td>存在</td>
</tr>
<tr>
<td>∈</td>
<td>$\in$</td>
<td>属于</td>
</tr>
<tr>
<td>∉</td>
<td>$\notin$</td>
<td>不属于</td>
</tr>
<tr>
<td>⊂</td>
<td>$\subset$</td>
<td>子集</td>
</tr>
<tr>
<td>⊆</td>
<td>$\subseteq$</td>
<td>真子集</td>
</tr>
<tr>
<td>⋃</td>
<td>$\bigcup$</td>
<td>并集</td>
</tr>
<tr>
<td>⋂</td>
<td>$\bigcap$</td>
<td>交集</td>
</tr>
<tr>
<td>⋁</td>
<td>$\bigvee$</td>
<td>逻辑或</td>
</tr>
<tr>
<td>⋀</td>
<td>$\bigwedge$</td>
<td>逻辑与</td>
</tr>
<tr>
<td>∅</td>
<td>$\emptyset$</td>
<td>空集</td>
</tr>
<tr>
<td>↑</td>
<td>$\uparrow$</td>
<td>向上</td>
</tr>
<tr>
<td>↓</td>
<td>$\downarrow$</td>
<td>向下</td>
</tr>
<tr>
<td>→</td>
<td>$\rightarrow$</td>
<td>向右</td>
</tr>
<tr>
<td>←</td>
<td>$\leftarrow$</td>
<td>向左</td>
</tr>
<tr>
<td>𝛼</td>
<td>$\alpha$</td>
<td>𝛼</td>
</tr>
<tr>
<td>𝛽</td>
<td>$\beta$</td>
<td>𝛽</td>
</tr>
<tr>
<td>𝛾</td>
<td>$\gamma$</td>
<td>𝛾</td>
</tr>
<tr>
<td>𝜋</td>
<td>$\pi$</td>
<td>𝜋</td>
</tr>
<tr>
<td>𝛿</td>
<td>$\delta$</td>
<td>𝛿</td>
</tr>
<tr>
<td>𝜀</td>
<td>$\varepsilon$</td>
<td>𝜀</td>
</tr>
<tr>
<td>𝜂</td>
<td>$\eta$</td>
<td>𝜂</td>
</tr>
<tr>
<td>𝜇</td>
<td>$\mu$</td>
<td>𝜇</td>
</tr>
<tr>
<td>𝜆</td>
<td>$\lambda$</td>
<td>𝜆</td>
</tr>
<tr>
<td>𝜔</td>
<td>$\omega$</td>
<td>𝜔</td>
</tr>
<tr>
<td>{}</td>
<td>$\lbrace \rbrace$</td>
<td>{}</td>
</tr>
<tr>
<td>∞</td>
<td>$\infin$</td>
<td>∞</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th>颜色名称</th>
<th>十六进制颜色值</th>
<th>颜色</th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td>AliceBlue</td>
<td>#F0F8FF</td>
<td>rgb(240, 248, 255)</td>
<td><font color="#F0F8FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>AntiqueWhite</td>
<td>#FAEBD7</td>
<td>rgb(250, 235, 215)</td>
<td><font color="#FAEBD7">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Aqua</td>
<td>#00FFFF</td>
<td>rgb(0, 255, 255)</td>
<td><font color="#00FFFF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Aquamarine</td>
<td>#7FFFD4</td>
<td>rgb(127, 255, 212)</td>
<td><font color="#7FFFD4">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Azure</td>
<td>#F0FFFF</td>
<td>rgb(240, 255, 255)</td>
<td><font color="#F0FFFF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Beige</td>
<td>#F5F5DC</td>
<td>rgb(245, 245, 220)</td>
<td><font color="#F5F5DC">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Bisque</td>
<td>#FFE4C4</td>
<td>rgb(255, 228, 196)</td>
<td><font color="#FFE4C4">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Black</td>
<td>#000000</td>
<td>rgb(0, 0, 0)</td>
<td><font color="#000000">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>BlanchedAlmond</td>
<td>#FFEBCD</td>
<td>rgb(255, 235, 205)</td>
<td><font color="#FFEBCD">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Blue</td>
<td>#0000FF</td>
<td>rgb(0, 0, 255)</td>
<td><font color="#0000FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>BlueViolet</td>
<td>#8A2BE2</td>
<td>rgb(138, 43, 226)</td>
<td><font color="#8A2BE2">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Brown</td>
<td>#A52A2A</td>
<td>rgb(165, 42, 42)</td>
<td><font color="#A52A2A">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>BurlyWood</td>
<td>#DEB887</td>
<td>rgb(222, 184, 135)</td>
<td><font color="#DEB887">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>CadetBlue</td>
<td>#5F9EA0</td>
<td>rgb(95, 158, 160)</td>
<td><font color="#5F9EA0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Chartreuse</td>
<td>#7FFF00</td>
<td>rgb(127, 255, 0)</td>
<td><font color="#7FFF00">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Chocolate</td>
<td>#D2691E</td>
<td>rgb(210, 105, 30)</td>
<td><font color="#D2691E">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Coral</td>
<td>#FF7F50</td>
<td>rgb(255, 127, 80)</td>
<td><font color="#FF7F50">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>CornflowerBlue</td>
<td>#6495ED</td>
<td>rgb(100, 149, 237)</td>
<td><font color="#6495ED">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Cornsilk</td>
<td>#FFF8DC</td>
<td>rgb(255, 248, 220)</td>
<td><font color="#FFF8DC">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Crimson</td>
<td>#DC143C</td>
<td>rgb(220, 20, 60)</td>
<td><font color="#DC143C">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Cyan</td>
<td>#00FFFF</td>
<td>rgb(0, 255, 255)</td>
<td><font color="#00FFFF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkBlue</td>
<td>#00008B</td>
<td>rgb(0, 0, 139)</td>
<td><font color="#00008B">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkCyan</td>
<td>#008B8B</td>
<td>rgb(0, 139, 139)</td>
<td><font color="#008B8B">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkGoldenRod</td>
<td>#B8860B</td>
<td>rgb(184, 134, 11)</td>
<td><font color="#B8860B">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkGray</td>
<td>#A9A9A9</td>
<td>rgb(169, 169, 169)</td>
<td><font color="#A9A9A9">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkGreen</td>
<td>#006400</td>
<td>rgb(0, 100, 0)</td>
<td><font color="#006400">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkKhaki</td>
<td>#BDB76B</td>
<td>rgb(189, 183, 107)</td>
<td><font color="#BDB76B">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkMagenta</td>
<td>#8B008B</td>
<td>rgb(139, 0, 139)</td>
<td><font color="#8B008B">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkOliveGreen</td>
<td>#556B2F</td>
<td>rgb(85, 107, 47)</td>
<td><font color="#556B2F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Darkorange</td>
<td>#FF8C00</td>
<td>rgb(255, 140, 0)</td>
<td><font color="#FF8C00">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkOrchid</td>
<td>#9932CC</td>
<td>rgb(153, 50, 204)</td>
<td><font color="#9932CC">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkRed</td>
<td>#8B0000</td>
<td>rgb(139, 0, 0)</td>
<td><font color="#8B0000">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkSalmon</td>
<td>#E9967A</td>
<td>rgb(233, 150, 122)</td>
<td><font color="#E9967A">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkSeaGreen</td>
<td>#8FBC8F</td>
<td>rgb(143, 188, 143)</td>
<td><font color="#8FBC8F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkSlateBlue</td>
<td>#483D8B</td>
<td>rgb(72, 61, 139)</td>
<td><font color="#483D8B">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkSlateGray</td>
<td>#2F4F4F</td>
<td>rgb(47, 79, 79)</td>
<td><font color="#2F4F4F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkTurquoise</td>
<td>#00CED1</td>
<td>rgb(0, 206, 209)</td>
<td><font color="#00CED1">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DarkViolet</td>
<td>#9400D3</td>
<td>rgb(148, 0, 211)</td>
<td><font color="#9400D3">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DeepPink</td>
<td>#FF1493</td>
<td>rgb(255, 20, 147)</td>
<td><font color="#FF1493">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DeepSkyBlue</td>
<td>#00BFFF</td>
<td>rgb(0, 191, 255)</td>
<td><font color="#00BFFF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DimGray</td>
<td>#696969</td>
<td>rgb(105, 105, 105)</td>
<td><font color="#696969">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>DodgerBlue</td>
<td>#1E90FF</td>
<td>rgb(30, 144, 255)</td>
<td><font color="#1E90FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Feldspar</td>
<td>#D19275</td>
<td>rgb(209, 146, 117)</td>
<td><font color="#D19275">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>FireBrick</td>
<td>#B22222</td>
<td>rgb(178, 34, 34)</td>
<td><font color="#B22222">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>FloralWhite</td>
<td>#FFFAF0</td>
<td>rgb(255, 250, 240)</td>
<td><font color="#FFFAF0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>ForestGreen</td>
<td>#228B22</td>
<td>rgb(34, 139, 34)</td>
<td><font color="#228B22">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Fuchsia</td>
<td>#FF00FF</td>
<td>rgb(255, 0, 255)</td>
<td><font color="#FF00FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Gainsboro</td>
<td>#DCDCDC</td>
<td>rgb(220, 220, 220)</td>
<td><font color="#DCDCDC">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>GhostWhite</td>
<td>#F8F8FF</td>
<td>rgb(248, 248, 255)</td>
<td><font color="#F8F8FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Gold</td>
<td>#FFD700</td>
<td>rgb(255, 215, 0)</td>
<td><font color="#FFD700">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>GoldenRod</td>
<td>#DAA520</td>
<td>rgb(218, 165, 32)</td>
<td><font color="#DAA520">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Gray</td>
<td>#808080</td>
<td>rgb(128, 128, 128)</td>
<td><font color="#808080">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Green</td>
<td>#008000</td>
<td>rgb(0, 128, 0)</td>
<td><font color="#008000">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>GreenYellow</td>
<td>#ADFF2F</td>
<td>rgb(173, 255, 47)</td>
<td><font color="#ADFF2F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>HoneyDew</td>
<td>#F0FFF0</td>
<td>rgb(240, 255, 240)</td>
<td><font color="#F0FFF0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>HotPink</td>
<td>#FF69B4</td>
<td>rgb(255, 105, 180)</td>
<td><font color="#FF69B4">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>IndianRed</td>
<td>#CD5C5C</td>
<td>rgb(205, 92, 92)</td>
<td><font color="#CD5C5C">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Indigo</td>
<td>#4B0082</td>
<td>rgb(75, 0, 130)</td>
<td><font color="#4B0082">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Ivory</td>
<td>#FFFFF0</td>
<td>rgb(255, 255, 240)</td>
<td><font color="#FFFFF0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Khaki</td>
<td>#F0E68C</td>
<td>rgb(240, 230, 140)</td>
<td><font color="#F0E68C">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Lavender</td>
<td>#E6E6FA</td>
<td>rgb(230, 230, 250)</td>
<td><font color="#E6E6FA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LavenderBlush</td>
<td>#FFF0F5</td>
<td>rgb(255, 240, 245)</td>
<td><font color="#FFF0F5">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LawnGreen</td>
<td>#7CFC00</td>
<td>rgb(124, 252, 0)</td>
<td><font color="#7CFC00">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LemonChiffon</td>
<td>#FFFACD</td>
<td>rgb(255, 250, 205)</td>
<td><font color="#FFFACD">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightBlue</td>
<td>#ADD8E6</td>
<td>rgb(173, 216, 230)</td>
<td><font color="#ADD8E6">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightCoral</td>
<td>#F08080</td>
<td>rgb(240, 128, 128)</td>
<td><font color="#F08080">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightCyan</td>
<td>#E0FFFF</td>
<td>rgb(224, 255, 255)</td>
<td><font color="#E0FFFF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightGoldenRodYellow</td>
<td>#FAFAD2</td>
<td>rgb(250, 250, 210)</td>
<td><font color="#FAFAD2">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightGrey</td>
<td>#D3D3D3</td>
<td>rgb(211, 211, 211)</td>
<td><font color="#D3D3D3">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightGreen</td>
<td>#90EE90</td>
<td>rgb(144, 238, 144)</td>
<td><font color="#90EE90">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightPink</td>
<td>#FFB6C1</td>
<td>rgb(255, 182, 193)</td>
<td><font color="#FFB6C1">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightSalmon</td>
<td>#FFA07A</td>
<td>rgb(255, 160, 122)</td>
<td><font color="#FFA07A">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightSeaGreen</td>
<td>#20B2AA</td>
<td>rgb(32, 178, 170)</td>
<td><font color="#20B2AA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightSkyBlue</td>
<td>#87CEFA</td>
<td>rgb(135, 206, 250)</td>
<td><font color="#87CEFA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightSlateBlue</td>
<td>#8470FF</td>
<td>rgb(132, 112, 255)</td>
<td><font color="#8470FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightSlateGray</td>
<td>#778899</td>
<td>rgb(119, 136, 153)</td>
<td><font color="#778899">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightSteelBlue</td>
<td>#B0C4DE</td>
<td>rgb(176, 196, 222)</td>
<td><font color="#B0C4DE">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LightYellow</td>
<td>#FFFFE0</td>
<td>rgb(255, 255, 224)</td>
<td><font color="#FFFFE0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Lime</td>
<td>#00FF00</td>
<td>rgb(0, 255, 0)</td>
<td><font color="#00FF00">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>LimeGreen</td>
<td>#32CD32</td>
<td>rgb(50, 205, 50)</td>
<td><font color="#32CD32">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Linen</td>
<td>#FAF0E6</td>
<td>rgb(250, 240, 230)</td>
<td><font color="#FAF0E6">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Magenta</td>
<td>#FF00FF</td>
<td>rgb(255, 0, 255)</td>
<td><font color="#FF00FF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Maroon</td>
<td>#800000</td>
<td>rgb(128, 0, 0)</td>
<td><font color="#800000">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumAquaMarine</td>
<td>#66CDAA</td>
<td>rgb(102, 205, 170)</td>
<td><font color="#66CDAA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumBlue</td>
<td>#0000CD</td>
<td>rgb(0, 0, 205)</td>
<td><font color="#0000CD">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumOrchid</td>
<td>#BA55D3</td>
<td>rgb(186, 85, 211)</td>
<td><font color="#BA55D3">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumPurple</td>
<td>#9370D8</td>
<td>rgb(147, 112, 216)</td>
<td><font color="#9370D8">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumSeaGreen</td>
<td>#3CB371</td>
<td>rgb(60, 179, 113)</td>
<td><font color="#3CB371">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumSlateBlue</td>
<td>#7B68EE</td>
<td>rgb(123, 104, 238)</td>
<td><font color="#7B68EE">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumSpringGreen</td>
<td>#00FA9A</td>
<td>rgb(0, 250, 154)</td>
<td><font color="#00FA9A">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumTurquoise</td>
<td>#48D1CC</td>
<td>rgb(72, 209, 204)</td>
<td><font color="#48D1CC">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MediumVioletRed</td>
<td>#C71585</td>
<td>rgb(199, 21, 133)</td>
<td><font color="#C71585">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MidnightBlue</td>
<td>#191970</td>
<td>rgb(25, 25, 112)</td>
<td><font color="#191970">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MintCream</td>
<td>#F5FFFA</td>
<td>rgb(245, 255, 250)</td>
<td><font color="#F5FFFA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>MistyRose</td>
<td>#FFE4E1</td>
<td>rgb(255, 228, 225)</td>
<td><font color="#FFE4E1">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Moccasin</td>
<td>#FFE4B5</td>
<td>rgb(255, 228, 181)</td>
<td><font color="#FFE4B5">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>NavajoWhite</td>
<td>#FFDEAD</td>
<td>rgb(255, 222, 173)</td>
<td><font color="#FFDEAD">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Navy</td>
<td>#000080</td>
<td>rgb(0, 0, 128)</td>
<td><font color="#000080">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>OldLace</td>
<td>#FDF5E6</td>
<td>rgb(253, 245, 230)</td>
<td><font color="#FDF5E6">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Olive</td>
<td>#808000</td>
<td>rgb(128, 128, 0)</td>
<td><font color="#808000">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>OliveDrab</td>
<td>#6B8E23</td>
<td>rgb(107, 142, 35)</td>
<td><font color="#6B8E23">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Orange</td>
<td>#FFA500</td>
<td>rgb(255, 165, 0)</td>
<td><font color="#FFA500">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>OrangeRed</td>
<td>#FF4500</td>
<td>rgb(255, 69, 0)</td>
<td><font color="#FF4500">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Orchid</td>
<td>#DA70D6</td>
<td>rgb(218, 112, 214)</td>
<td><font color="#DA70D6">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PaleGoldenRod</td>
<td>#EEE8AA</td>
<td>rgb(238, 232, 170)</td>
<td><font color="#EEE8AA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PaleGreen</td>
<td>#98FB98</td>
<td>rgb(152, 251, 152)</td>
<td><font color="#98FB98">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PaleTurquoise</td>
<td>#AFEEEE</td>
<td>rgb(175, 238, 238)</td>
<td><font color="#AFEEEE">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PaleVioletRed</td>
<td>#D87093</td>
<td>rgb(216, 112, 147)</td>
<td><font color="#D87093">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PapayaWhip</td>
<td>#FFEFD5</td>
<td>rgb(255, 239, 213)</td>
<td><font color="#FFEFD5">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PeachPuff</td>
<td>#FFDAB9</td>
<td>rgb(255, 218, 185)</td>
<td><font color="#FFDAB9">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Peru</td>
<td>#CD853F</td>
<td>rgb(205, 133, 63)</td>
<td><font color="#CD853F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Pink</td>
<td>#FFC0CB</td>
<td>rgb(255, 192, 203)</td>
<td><font color="#FFC0CB">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Plum</td>
<td>#DDA0DD</td>
<td>rgb(221, 160, 221)</td>
<td><font color="#DDA0DD">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>PowderBlue</td>
<td>#B0E0E6</td>
<td>rgb(176, 224, 230)</td>
<td><font color="#B0E0E6">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Purple</td>
<td>#800080</td>
<td>rgb(128, 0, 128)</td>
<td><font color="#800080">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Red</td>
<td>#FF0000</td>
<td>rgb(255, 0, 0)</td>
<td><font color="#FF0000">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>RosyBrown</td>
<td>#BC8F8F</td>
<td>rgb(188, 143, 143)</td>
<td><font color="#BC8F8F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>RoyalBlue</td>
<td>#4169E1</td>
<td>rgb(65, 105, 225)</td>
<td><font color="#4169E1">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SaddleBrown</td>
<td>#8B4513</td>
<td>rgb(139, 69, 19)</td>
<td><font color="#8B4513">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Salmon</td>
<td>#FA8072</td>
<td>rgb(250, 128, 114)</td>
<td><font color="#FA8072">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SandyBrown</td>
<td>#F4A460</td>
<td>rgb(244, 164, 96)</td>
<td><font color="#F4A460">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SeaGreen</td>
<td>#2E8B57</td>
<td>rgb(46, 139, 87)</td>
<td><font color="#2E8B57">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SeaShell</td>
<td>#FFF5EE</td>
<td>rgb(255, 245, 238)</td>
<td><font color="#FFF5EE">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Sienna</td>
<td>#A0522D</td>
<td>rgb(160, 82, 45)</td>
<td><font color="#A0522D">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Silver</td>
<td>#C0C0C0</td>
<td>rgb(192, 192, 192)</td>
<td><font color="#C0C0C0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SkyBlue</td>
<td>#87CEEB</td>
<td>rgb(135, 206, 235)</td>
<td><font color="#87CEEB">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SlateBlue</td>
<td>#6A5ACD</td>
<td>rgb(106, 90, 205)</td>
<td><font color="#6A5ACD">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SlateGray</td>
<td>#708090</td>
<td>rgb(112, 128, 144)</td>
<td><font color="#708090">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Snow</td>
<td>#FFFAFA</td>
<td>rgb(255, 250, 250)</td>
<td><font color="#FFFAFA">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SpringGreen</td>
<td>#00FF7F</td>
<td>rgb(0, 255, 127)</td>
<td><font color="#00FF7F">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>SteelBlue</td>
<td>#4682B4</td>
<td>rgb(70, 130, 180)</td>
<td><font color="#4682B4">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Tan</td>
<td>#D2B48C</td>
<td>rgb(210, 180, 140)</td>
<td><font color="#D2B48C">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Teal</td>
<td>#008080</td>
<td>rgb(0, 128, 128)</td>
<td><font color="#008080">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Thistle</td>
<td>#D8BFD8</td>
<td>rgb(216, 191, 216)</td>
<td><font color="#D8BFD8">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Tomato</td>
<td>#FF6347</td>
<td>rgb(255, 99, 71)</td>
<td><font color="#FF6347">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Turquoise</td>
<td>#40E0D0</td>
<td>rgb(64, 224, 208)</td>
<td><font color="#40E0D0">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Violet</td>
<td>#EE82EE</td>
<td>rgb(238, 130, 238)</td>
<td><font color="#EE82EE">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>VioletRed</td>
<td>#D02090</td>
<td>rgb(208, 32, 144)</td>
<td><font color="#D02090">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Wheat</td>
<td>#F5DEB3</td>
<td>rgb(245, 222, 179)</td>
<td><font color="#F5DEB3">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>White</td>
<td>#FFFFFF</td>
<td>rgb(255, 255, 255)</td>
<td><font color="#FFFFFF">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>WhiteSmoke</td>
<td>#F5F5F5</td>
<td>rgb(245, 245, 245)</td>
<td><font color="#F5F5F5">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>Yellow</td>
<td>#FFFF00</td>
<td>rgb(255, 255, 0)</td>
<td><font color="#FFFF00">LiXingze’s Blog</font></td>
</tr>
<tr>
<td>YellowGreen</td>
<td>#9ACD32</td>
<td>rgb(154, 205, 50)</td>
<td><font color="#9ACD32">LiXingze’s Blog</font></td>
</tr>
</tbody></table>
<a class="btn-beautify button--animated purple larger" href="https://lxz9.com" title="点击返回主页"><i class="far fa-hand-point-right"></i><span>点击返回主页</span></a>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Perl语言基础(一)</title>
    <url>/2021/10/01/Perl01/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/01/4TOxnH.png"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是Perl语言？"><a href="#什么是Perl语言？" class="headerlink" title="什么是Perl语言？"></a>什么是Perl语言？</h2><blockquote>
<p>Perl一般被称为“实用报表提取语言”( Practical Extraction and Report Language)<br>Perl最初的设计者为拉里沃尔(Larry Wall)他于1987年12月18日发表。<br>“Perl”,有大写的P，是指语言本身;”perl”,小写的p，是指程序运行的解释器。</p>
</blockquote>
<h2 id="Perl语言特点"><a href="#Perl语言特点" class="headerlink" title="Perl语言特点"></a>Perl语言特点</h2><div class="note pink no-icon flat"><p>1、开源免费</p>
<p>2、支持跨平台</p>
<p>3、直接运行，无需复杂编译</p>
<p>4、内部集成正则表达式</p>
<p>5、CPAN模块库</p>
</div>

<h2 id="为什么Perl语言适合处理生物数据"><a href="#为什么Perl语言适合处理生物数据" class="headerlink" title="为什么Perl语言适合处理生物数据"></a>为什么Perl语言适合处理生物数据</h2><div class="note pink no-icon flat"><p>1、正则表达是善于处理字符串</p>
<p>2、脚本语言，善于批量化和流程化</p>
<p>3、很多生物学软件用Perl语言编写</p>
<p>4、简单易学</p>
</div>

<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>Perl 程序有声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 (;) 结束。<br>Perl 语言没有严格的格式规范，你可以根据自己喜欢的风格来缩进。</p>
<h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Hello, world\n&quot;</span>;    <span class="comment"># 双引号</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;Hello, world\n&#x27;</span>;    <span class="comment"># 单引号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><code>Hello, world Hello, world\n</code><br>从结果中我们可以看出，双引号 \n 输出了换行，而单引号没有。<br><strong>Perl双引号和单引号的区别:</strong><br>（1）双中有双，单中有单都需要 \ 转义。</p>
<p>（2）双中有单或单中有双均不需要转义。</p>
<p>（3）单引号直接了当，引号内是什么就显示什么，双引号则需要考虑转义或变量替换等。双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。</p>
<h3 id="Perl-数据类型"><a href="#Perl-数据类型" class="headerlink" title="Perl 数据类型"></a>Perl 数据类型</h3><p>Perl语言中数组主要有 标量 数组 哈希</p>
<ol>
<li><p>标量<br>标量是 Perl 语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个 <code>$</code>，表示是标量。<br>例如：<br><code>$myfirst=123;　    #数字123　 $mysecond=&quot;123&quot;;   #字符串123　</code></p>
</li>
<li><p>数组<br>数组变量以字符 @ 开头，索引从 0 开始，如：<code>@arr=(1,2,3)</code></p>
</li>
<li><p>哈希<br>哈希是一个无序的 key/value 对集合。可以使用键作为下标获取值。哈希变量以字符 % 开头。<br>eg<code>%h=(&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2); </code></p>
</li>
</ol>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>系统响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0nn</td>
<td>创建八进制格式的数字</td>
</tr>
<tr>
<td>\xnn</td>
<td>创建十六进制格式的数字</td>
</tr>
<tr>
<td>\cX</td>
<td>控制字符，x可以是任何字符</td>
</tr>
<tr>
<td>\u</td>
<td>强制下一个字符为大写</td>
</tr>
<tr>
<td>\l</td>
<td>强制下一个字符为小写</td>
</tr>
<tr>
<td>\U</td>
<td>强制将所有字符转换为大写</td>
</tr>
<tr>
<td>\L</td>
<td>强制将所有的字符转换为小写</td>
</tr>
<tr>
<td>\Q</td>
<td>将到\E为止的非单词（non-word）字符加上反斜线</td>
</tr>
<tr>
<td>\E</td>
<td>结束\L、\U、\Q</td>
</tr>
</tbody></table>
<hr>
<h1 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h1><p>标量是一个简单的数据单元。</p>
<p>标量可以是一个整数，浮点数，字符，字符串，段落或者一个完整的网页。</p>
<p>以下实例演示了标量的简单应用：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">$age = <span class="number">20</span>;             <span class="comment"># 整数赋值</span></span><br><span class="line">$name = <span class="string">&quot;Runoob&quot;</span>;   <span class="comment"># 字符串</span></span><br><span class="line">$salary = <span class="number">130.50</span>;     <span class="comment"># 浮点数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Age = $age\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Name = $name\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Salary = $salary\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果为：</p>
<p><code>Age = 20 Name = Runoob Salary = 130.5</code></p>
<p>1、Perl中最基本的数据类型<br>2、可以是数字、字母<br>3、无需定义类型<br>4、“单数”为标量</p>
<h2 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h2><p>在程序中直接定义一个值，就叫做直接量。<br>1e-5<br>-40<br>“Hello,world”<br>print”2.4+3”<br>1 000 100</p>
<h2 id="数字操作符"><a href="#数字操作符" class="headerlink" title="数字操作符"></a>数字操作符</h2><p>加2+3<br>减5.1-2.4<br>乘3*12<br>除14/2(除数不能为0)<br>取模10%3<br>乘幂 <code>2**3</code></p>
<h2 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h2><p>1、所谓字符串就是一连串的字符组合，字符可以是字母，也可以是数字，包括标点等;<br>2、对DNA序列处理本质上就是处理字符串;3、字符串可以为空<br>4、需要“引号”</p>
<h3 id="”序列”字符串处理"><a href="#”序列”字符串处理" class="headerlink" title="”序列”字符串处理"></a>”序列”字符串处理</h3><p>序列也是字符串<br><code>ATGAATCCAAATCAGAAGATAACAGCAATTGGCTCTGTTTCTCTAATCATTGCGATAATATGTCTCCTCATGCAAATTGCCATCTTAACAACGACTATGACATTACAATTCTGGCAGAAAGAATGCAGTAACCCATCGAATAATCAAGTGATGCCATGTGAACCGATCATAATAGAA</code><br>计算长度反向<br>碱基互补配对替换<br>截取<br>翻译成氨基酸</p>
<h2 id="单引号与双引号字符串的差别"><a href="#单引号与双引号字符串的差别" class="headerlink" title="单引号与双引号字符串的差别"></a>单引号与双引号字符串的差别</h2><ol>
<li><p>单引号内的内容表示内容本身(单引号和反斜线除外);</p>
</li>
<li><p>单引号内表示单引号和反斜线需要转意;<br>Print ‘she said that:&#39; hello,world&#39;</p>
</li>
<li><p>双引号支持反斜线转意;<br>例:print’hello , world!\n’<br>print”hello , world !\n”</p>
</li>
</ol>
<h2 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h2><p>字符串连接<br>使用<code>.</code> : “hello “. “world”</p>
<p>使用<code>x</code> : “fred” x 3</p>
<p>5x4=20?或者5555?<br>5<em>4<br>“Z”. 5</em>7</p>
<h2 id="标量变量"><a href="#标量变量" class="headerlink" title="标量变量"></a>标量变量</h2><p>标量变量用美元$表示<br>变量的命名规范<br>1、<strong>不能</strong>以数字开头$100<br>2、可以以字母下划线开头，后面可以有数字<br>3、严格区分大小写<br>4、命名最好与变量用途相关，不要过短<br>5、不要采用内部保留变量名 (eg $NRGV;$ENV…)</p>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$dna=<span class="string">&quot;ATTTTTTGC&quot;</span>;</span><br><span class="line">$gene_num=<span class="number">3</span>;</span><br><span class="line">$gene_num=$gene_num+<span class="number">4</span>; </span><br><span class="line">$gene_num+=<span class="number">4</span>; <span class="comment">#为上一行的简写</span></span><br><span class="line">$dna.= <span class="string">&quot;ATTTCCGCTC”;  #.=用于字符串链接</span></span><br><span class="line"><span class="string">ATTTTTTGCATTTCCGCTC</span></span><br></pre></td></tr></table></figure>
<p>(注意：这里的<code>=</code>不代表数学意义上的等于，而是赋值的意思；<code>==</code>才代表数学意义上的等于)</p>
<h2 id="操作符（运算符）优先级"><a href="#操作符（运算符）优先级" class="headerlink" title="操作符（运算符）优先级"></a>操作符（运算符）优先级</h2><p>2+3*4结果等于14,<br>$gene_num=$gene_num+4;<br>(2+3)*4结果等于20,</p>
<hr>
<table>
<thead>
<tr>
<th>运算符符</th>
<th>结合性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>++, –</td>
<td>无</td>
<td>自增，自减</td>
</tr>
<tr>
<td>-, ~, !</td>
<td>从右到左</td>
<td>单目</td>
</tr>
<tr>
<td>**</td>
<td>从右到左</td>
<td>乘方</td>
</tr>
<tr>
<td>=<del>, !</del></td>
<td>从左到右</td>
<td>模式匹配</td>
</tr>
<tr>
<td>*, /, %, x</td>
<td>从左到右</td>
<td>乘，除，取余，重复</td>
</tr>
<tr>
<td>+, -, .</td>
<td>从左到右</td>
<td>加，减，联接</td>
</tr>
<tr>
<td>&lt;&lt;, &gt;&gt;</td>
<td>从左到右</td>
<td>移位</td>
</tr>
<tr>
<td>-e, -r,</td>
<td>无</td>
<td>文件状态</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=, lt, le, gt, ge</td>
<td>从左到右</td>
<td>不等比较</td>
</tr>
<tr>
<td>==, !=, &lt;=&gt;, eq, ne, cmp</td>
<td>从左到右</td>
<td>相等比较</td>
</tr>
<tr>
<td>&amp;</td>
<td>从左到右</td>
<td>位与</td>
</tr>
<tr>
<td></td>
<td>, ^</td>
<td>从左到右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左到右</td>
<td>逻辑与</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>..</td>
<td>从左到右</td>
<td>列表范围</td>
</tr>
<tr>
<td>? and :</td>
<td>从右到左</td>
<td>条件操作符</td>
</tr>
<tr>
<td>=, +=, -=, *=,</td>
<td>从右到左</td>
<td>赋值</td>
</tr>
<tr>
<td>其他</td>
<td></td>
<td></td>
</tr>
<tr>
<td>,</td>
<td>从左到右</td>
<td>逗号操作符</td>
</tr>
<tr>
<td>not</td>
<td>从左到右</td>
<td>Low-precedence logical NOT</td>
</tr>
<tr>
<td>and</td>
<td>从左到右</td>
<td>lLow-precedence logical AND</td>
</tr>
<tr>
<td>or, xor</td>
<td>从左到右</td>
<td>lLow-precedence logical OR and XOR</td>
</tr>
</tbody></table>
<hr>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>表格实例中设置变量 $a 为 10， $b 为 20。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>检查两个操作数的值是否相等，如果相等则条件为 true，否则为 false。</td>
<td>($a == $b) 为 false</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>检查两个操作数的值是否相等，如果不相等则条件为 true，否则为 false。</td>
<td>($a != $b) 为 true。</td>
</tr>
<tr>
<td><code>&lt;=&gt;</code></td>
<td>检查两个操作数的值是否相等, 如果左边的数小于右边的数返回 -1，如果相等返回 0, 如果左边的数大于右边的数返回 1 。</td>
<td>($a &lt;=&gt; $b) 返回 -1。</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为 true，否则为 false。</td>
<td>($a &gt; $b) 返回 false。</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为 true，否则返回 false。</td>
<td>($a &lt; $b) 返回 true。</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为 true，否则返回 false。</td>
<td>($a &gt;= $b) 返回 false。</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为 true，否则返回 false。。</td>
<td>($a &lt;= $b) 返回 true.</td>
</tr>
</tbody></table>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><h3 id="回车和换行"><a href="#回车和换行" class="headerlink" title="回车和换行"></a>回车和换行</h3><p>在linux系统下是换行\n;<br>在mac系统下是回车\r;<br>windows系统下回车加换行两个字符\r\n;</p>
<h3 id="不同系统之间换行符的转换"><a href="#不同系统之间换行符的转换" class="headerlink" title="不同系统之间换行符的转换"></a>不同系统之间换行符的转换</h3><p>dos2unixwindows转换为linux<br>unix2dos:linux转换为windows<br>unix2mac :linux转换为mac<br>mac2unix:mac转换为linux</p>
<h3 id="chomp函数"><a href="#chomp函数" class="headerlink" title="chomp函数"></a>chomp函数</h3><p>功能：去除换行符<br>$test= “hello,world\n’<br>chomp ($test);# “hello,world”<br>chomp ($test);# “hello,world”<br>chomp ($test);# “hello,world”<br>chomp ($test);# “hello,world”</p>
<h3 id="chop函数"><a href="#chop函数" class="headerlink" title="chop函数"></a>chop函数</h3><p>功能：每输入一次就会去掉后面一个字符</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$test= <span class="string">&quot;hello,world\n</span></span><br><span class="line"><span class="string">chop ($test); # &quot;</span>hello,world<span class="string">&quot;;</span></span><br><span class="line"><span class="string">chop ($test); # &quot;</span>hello,worl<span class="string">&quot;;</span></span><br><span class="line"><span class="string">chop ($test); # &quot;</span>hello,wor<span class="string">&quot;;</span></span><br><span class="line"><span class="string">chop ($test); # &quot;</span>hello,wo<span class="string">&quot;;</span></span><br><span class="line"><span class="string">chop ($test); # &quot;</span>hello,w<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>
<h1 id="列表和数组"><a href="#列表和数组" class="headerlink" title="列表和数组"></a>列表和数组</h1><p>列表(list)指的是标量的有序集合<br>数组(array)则是存储列表的变量。<br>@array=[1,2,3,4,5];<br>@array=[1, “hello”,undef, $dna,5];</p>
<h2 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h2><p>@array=[1,2,3,4,5];<br>$array[0]=1;<br>$array[1]=2;<br>$array[2]=3;<br>$array[3]=4;<br>$array[4]=5;<br>……<br>$array[99]=100;</p>
<h3 id="数组的元素个数"><a href="#数组的元素个数" class="headerlink" title="数组的元素个数"></a>数组的元素个数</h3><p>@array=[1,2,3,4,5];<br>数组最后一个元素角标$#array;<br>数组元素个数=$#array+1;</p>
<h3 id="构建列表"><a href="#构建列表" class="headerlink" title="构建列表"></a>构建列表</h3><ol>
<li><p>括号，元素之间用逗号隔开;<br>(1,2,3,4,5)</p>
</li>
<li><p>范围操作符(..)每次加一<br><code>@number=(1..100); print &quot;@number\n&quot;;</code></p>
</li>
<li><p>qw操作符，可以省略逗号<br><code>@strings=qw (fred barney betty wilma dino); @stringl=qw !fred barney betty wilma dino!; @string2= #fred barney betty wilma dino#; @string3=qw /fred barney betty wilma dino/; @string4=qw &#123;fred barney betty wilma dino&#125;; dstring5=qw &lt;fred barney betty wilma dino&gt;;</code></p>
</li>
</ol>
<h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><p>eg</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">(Sfred, Sbarney, Sdino)=(<span class="string">&quot;flintstone&quot;</span>,<span class="string">&quot;rubble&quot;</span>, <span class="keyword">undef</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Sfred\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$barney\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$dino\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>output:<br>flintstone<br>rubble</p>
<h3 id="split和join"><a href="#split和join" class="headerlink" title="split和join"></a>split和join</h3><p>split将字符串根据固定的分隔符进行切割，切割后得到一个数组;</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line">$scalar=<span class="string">&quot;abc:def:g:h&quot;</span>;</span><br><span class="line">@array=<span class="keyword">split</span> <span class="regexp">/:/</span>,$scalar;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@array\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">perl *.pl</span><br><span class="line">abc def g h</span><br></pre></td></tr></table></figure>
<p>join与split刚好相反，它的作用是将数组连接成一个标量</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$new_scalar=<span class="keyword">join</span> <span class="string">&quot;:&quot;</span>,@array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$new_scalar\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">perl *.perl</span><br><span class="line">abc:def:g:h</span><br></pre></td></tr></table></figure>
<h1 id="Perl帮助文档"><a href="#Perl帮助文档" class="headerlink" title="Perl帮助文档"></a>Perl帮助文档</h1><p>通过访问<a href="perl.org">perl官方文档</a><br>在linux系统下 输入 <code>perldoc</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perldoc -f chomp <span class="comment">#查找函数的功能</span></span><br><span class="line">perldoc -m Data::Dumper <span class="comment">#直接查看模块代码</span></span><br><span class="line">perlodc -q regex <span class="comment">#搜寻含此关键字的文档</span></span><br><span class="line">perldoc -v @ARGV <span class="comment">#查询内置变量</span></span><br><span class="line">perldoc -o LaTex -d texttrap.docs Text::Wrap <span class="comment"># 将Text::Wrap模块的帮助信息，以LaTex格式输出到文件中</span></span><br><span class="line">perldoc File::Basename <span class="comment">#直接进入到模块的详情页</span></span><br><span class="line">-l 查看perl模块安装路径</span><br><span class="line">-T 直接输出到屏幕</span><br><span class="line"><span class="comment">#帮助手册</span></span><br><span class="line">perldoc perlfaq</span><br><span class="line">perldoc perlfaq3</span><br><span class="line">perldoc perlsyn</span><br></pre></td></tr></table></figure>
<h2 id="语法手册"><a href="#语法手册" class="headerlink" title="语法手册"></a>语法手册</h2><hr>
<table>
<thead>
<tr>
<th>手册页</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>perl</td>
<td>有些什么 perl 手册页</td>
</tr>
<tr>
<td>perldata</td>
<td>数据类型</td>
</tr>
<tr>
<td>perlsyn</td>
<td>语法</td>
</tr>
<tr>
<td>perlop</td>
<td>操作符和优先级</td>
</tr>
<tr>
<td>perlre</td>
<td>正则表达式</td>
</tr>
<tr>
<td>perlvar</td>
<td>预定义变量</td>
</tr>
<tr>
<td>perlsub</td>
<td>子过程</td>
</tr>
<tr>
<td>prelfunc</td>
<td>内建函数</td>
</tr>
<tr>
<td>perlmod</td>
<td>如何令 Perl 模块工作</td>
</tr>
<tr>
<td>perlref</td>
<td>参考手册</td>
</tr>
<tr>
<td>perlobj</td>
<td>对象</td>
</tr>
<tr>
<td>perlipc</td>
<td>进程间通讯</td>
</tr>
<tr>
<td>perlrun</td>
<td>如何运行 Perl 命令，以及命令行开关</td>
</tr>
<tr>
<td>perldebug</td>
<td>调试</td>
</tr>
<tr>
<td>perldiag</td>
<td>诊断信息</td>
</tr>
</tbody></table>
<hr>
<h2 id="faq手册"><a href="#faq手册" class="headerlink" title="faq手册"></a>faq手册</h2><hr>
<table>
<thead>
<tr>
<th>手册页</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>perlfaq1</td>
<td>关于 Perl 的通用信息</td>
</tr>
<tr>
<td>perlfaq2</td>
<td>获取和学习 Perl</td>
</tr>
<tr>
<td>perlfaq3</td>
<td>编程工具</td>
</tr>
<tr>
<td>perlfaq4</td>
<td>数据操作</td>
</tr>
<tr>
<td>perlfaq5</td>
<td>文件和格式</td>
</tr>
<tr>
<td>perlfaq6</td>
<td>正则表达式</td>
</tr>
<tr>
<td>perlfaq7</td>
<td>通用 Perl 语言信息</td>
</tr>
<tr>
<td>perlfaq8</td>
<td>系统交互</td>
</tr>
<tr>
<td>perlfaq9</td>
<td>网络</td>
</tr>
</tbody></table>
<hr>
<h2 id="移植相关手册"><a href="#移植相关手册" class="headerlink" title="移植相关手册"></a>移植相关手册</h2><hr>
<table>
<thead>
<tr>
<th>手册页</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>perlamiga</td>
<td>Amiga 移植</td>
</tr>
<tr>
<td>perlcygwin</td>
<td>Cygwin 移植</td>
</tr>
<tr>
<td>perldos</td>
<td>MS-DOS 移植</td>
</tr>
<tr>
<td>perlhpux</td>
<td>HP-UX 移植</td>
</tr>
<tr>
<td>perlmachten</td>
<td>Power MachTen? 移植</td>
</tr>
<tr>
<td>perlos2</td>
<td>OS/2 移植</td>
</tr>
<tr>
<td>perlos390</td>
<td>OS/390 移植</td>
</tr>
<tr>
<td>perlvms</td>
<td>DEC VMS 移植</td>
</tr>
<tr>
<td>perlwin32</td>
<td>MS-Windows 移植</td>
</tr>
</tbody></table>
<hr>
<p>在平时编程中要熟练查看帮助文档</p>
<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p>open函数文件读写</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;gene.ffn&quot;</span>;</span><br><span class="line"><span class="keyword">open</span> OU,<span class="string">&quot;&gt;protein.faa&quot;</span>;</span><br><span class="line"><span class="keyword">open</span> OU,<span class="string">&quot;&gt;&gt;protein.faa&quot;</span>; <span class="comment"># 追加到文件内容后面，和linux重定向一个意思</span></span><br><span class="line"><span class="comment">#首先是open函数打开文件； </span></span><br><span class="line"><span class="comment">#IN或OU称为文件句柄，就是程序里代表Perl进程与外界之间IO联系的名字，也就是联系的名称（句柄可以理解成）</span></span><br><span class="line"><span class="comment">#逗号分隔</span></span><br><span class="line"><span class="comment"># &#x27;&gt;&#x27;,&#x27;&lt;&#x27;输入输出方向</span></span><br><span class="line"><span class="comment"># 文件路径</span></span><br></pre></td></tr></table></figure>
<h2 id="文件句柄"><a href="#文件句柄" class="headerlink" title="文件句柄"></a>文件句柄</h2><p>在文件I/O中，要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来打开文件。该函数取回一个顺序号，即Perl文件句柄（filehandle）<br>文件句柄用来对应要操作的文件系统中的文件，这么说不太严谨，但比较容易理解。首先为要打开的文件绑定文件句柄(称为打开文件句柄)，然后在后续的操作中都通过文件句柄来操作对应的文件，最后关闭文件句柄。</p>
<blockquote>
<p>perl保留文件句柄<br>STDIN, STDOUT, STDERR，DATA，ARGV和ARGVOUT<br>标准输入，标准输出，错误输出</p>
</blockquote>
<h3 id="ARGV"><a href="#ARGV" class="headerlink" title="@ARGV"></a>@ARGV</h3><p><code>perl cds2pep.pl gene.ffn protein.faa 1</code><br>cds2pep.pl $O<br>gene.ffn: $ARGV[0] 命令行第1个参数<br>protein.faa: $ARGV[1]命令行第二个参数<br>1: $ARGV[2]命令行第三个参数</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">!<span class="regexp">/usr/</span>bin/perl -w</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>,<span class="keyword">or</span> <span class="keyword">die</span><span class="string">&quot;can not open the file\n$!&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$0 is $0\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$ARGV[O] is $ARGV[0]\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$ARGV[1] is $ARGV[1]\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$ARGV[2] is $ARGV[2]\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>;</span><br><span class="line">$First=&lt;IN&gt;;</span><br><span class="line">$Second=&lt;IN&gt;;</span><br><span class="line">$Third=&lt;IN&gt;;</span><br><span class="line">$Forth=&lt;IN&gt;;</span><br><span class="line">$Fifth=&lt;IN&gt;;</span><br><span class="line"> <span class="keyword">print</span><span class="string">&quot;$First\n$Second\n$Third\n$Forth\n$Fifth\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>;</span><br><span class="line">$/=<span class="string">&quot;&gt;&quot;</span>; <span class="comment">#以&#x27;&gt;&#x27;进行分割</span></span><br><span class="line">&lt;IN&gt;;</span><br><span class="line">$First=&lt;IN&gt;;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$First\n&quot;</span>;</span><br><span class="line"><span class="comment"># 每次读取一个字段赋值给一个标量太麻烦，正常情况下将文件句柄使用在while循环中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># while循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">	<span class="keyword">print</span> <span class="string">&quot;$_&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者赋值给$line</span></span><br><span class="line"><span class="keyword">while</span> ($line=&lt;IN&gt;) &#123;</span><br><span class="line">	<span class="keyword">print</span> <span class="string">&quot;$line&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会输出到屏幕而是输入到创建的文件中</span></span><br><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>; <span class="comment">#&#x27;&lt;&#x27;符号可以省略</span></span><br><span class="line"><span class="keyword">open</span> OU,<span class="string">&quot;$ARGV[1]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">	<span class="keyword">print</span> <span class="string">&quot;$_&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"><span class="keyword">close</span> OU; <span class="comment"># close函数关闭文件句柄</span></span><br></pre></td></tr></table></figure>

<h1 id="格式转换程序"><a href="#格式转换程序" class="headerlink" title="格式转换程序"></a>格式转换程序</h1><h2 id="fastq转fasta"><a href="#fastq转fasta" class="headerlink" title="fastq转fasta"></a>fastq转fasta</h2><p>首先两个文件差别在于 fasta文件为四行，fastq为两行<br>fasta为&gt;开头，fastq为@开头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fastq格式文件</span></span><br><span class="line">@FCD056DACXX:3:1101:2163:1959<span class="comment">#TCGCCGTG/1</span></span><br><span class="line">TCCGATAACGCTCAACCAGAGGGCTGCCAGCTCCGATCGGCAGTTGCAACCCATTGGCCGTCTGAGCCAGCAACCCCGGA</span><br><span class="line">+</span><br><span class="line">gggiiiiiiiiiiiiiiiiiiiiiiiiiigggggeeecccccc^bcbcccccccbccccc]aaccbbccc^R^^acccc_</span><br><span class="line"></span><br><span class="line"><span class="comment">#fasta格式文件</span></span><br><span class="line">&gt;FCD056DACXX:3:1101:2163:1959<span class="comment">#TCGCCGTG/1</span></span><br><span class="line">TCCGATAACGCTCAACCAGAGGGCTGCCAGCTCCGATCGGCAGTTGCAACCCATTGGCCGTCTGAGCCAGCAACCCCGGA</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;zcat $ARGV[0] |&quot;</span>;</span><br><span class="line"><span class="keyword">open</span> OU,<span class="string">&quot;&gt;$ARGV[1]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($id=&lt;IN&gt;) &#123;</span><br><span class="line">	<span class="keyword">chomp</span> ($id);</span><br><span class="line">	<span class="keyword">chomp</span> ($seq=&lt;IN&gt;);</span><br><span class="line">	&lt;IN&gt;;</span><br><span class="line">	&lt;IN&gt;;</span><br><span class="line">	$id=~ <span class="keyword">tr</span> /@/&gt;<span class="regexp">/;</span></span><br><span class="line"><span class="regexp">	print OU &quot;$id\n&quot;;</span></span><br><span class="line"><span class="regexp">	print OU &quot;$seq\n&quot;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">close IN;</span></span><br><span class="line"><span class="regexp">close OU;</span></span><br></pre></td></tr></table></figure>
<p><code>=~将左边的值交给右边做匹配，并直接修改左边的值；相当于shell的-i &#39;s////g&#39;</code></p>
<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希是 key/value 对的集合。<br>Perl中哈希变量以百分号 (%) 标记开始。</p>
<h2 id="访问哈希元素"><a href="#访问哈希元素" class="headerlink" title="访问哈希元素"></a>访问哈希元素</h2><p>访问哈希元素格式：${key}。<br>以下是一个简单的哈希实例：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>, <span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$data&#123;&#x27;google&#x27;&#125; = $data&#123;&#x27;google&#x27;&#125;\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$data&#123;&#x27;runoob&#x27;&#125; = $data&#123;&#x27;runoob&#x27;&#125;\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\$data&#123;&#x27;taobao&#x27;&#125; = $data&#123;&#x27;taobao&#x27;&#125;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="创建哈希"><a href="#创建哈希" class="headerlink" title="创建哈希"></a>创建哈希</h2><p>创建哈希可以通过以下两种方式：</p>
<ol>
<li>为每个 key 设置 value<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$data&#123;<span class="string">&#x27;google&#x27;</span>&#125; = <span class="string">&#x27;google.com&#x27;</span>;</span><br><span class="line">$data&#123;<span class="string">&#x27;runoob&#x27;</span>&#125; = <span class="string">&#x27;runoob.com&#x27;</span>;</span><br><span class="line">$data&#123;<span class="string">&#x27;taobao&#x27;</span>&#125; = <span class="string">&#x27;taobao.com&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>通过列表设置<br>列表中第一个元素为 key，第二个为 value。<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>, <span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用 =&gt; 符号来设置 key/value:</span></span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下实例是上面实例的变种，使用 - 来代替引号：</span></span><br><span class="line">%data = (</span><br><span class="line">	<span class="string">-google=&gt;</span><span class="string">&#x27;google.com&#x27;</span>, </span><br><span class="line">	<span class="string">-runoob=&gt;</span><span class="string">&#x27;runoob.com&#x27;</span>, </span><br><span class="line">	<span class="string">-taobao=&gt;</span><span class="string">&#x27;taobao.com&#x27;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用这种方式 key 不能出现空格，读取元素方式为：</span></span><br><span class="line">$val = $data&#123;-google&#125;</span><br><span class="line">$val = $data&#123;-runoob&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取哈希值"><a href="#读取哈希值" class="headerlink" title="读取哈希值"></a>读取哈希值</h2>哈希值提取到数组语法格式：@{key1,key2}。</li>
</ol>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/uer/bin/perl</span></span><br><span class="line"></span><br><span class="line">%data = (<span class="string">-taobao =&gt;</span> <span class="number">45</span>, <span class="string">-google =&gt;</span> <span class="number">30</span>, <span class="string">-runoob =&gt;</span> <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">@array = @data&#123;-taobao, -runoob&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Array : @array\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果为：<code>Array : 45 40</code></p>
<h2 id="读取哈希的-key-和-value"><a href="#读取哈希的-key-和-value" class="headerlink" title="读取哈希的 key 和 value"></a>读取哈希的 key 和 value</h2><h3 id="读取所有key"><a href="#读取所有key" class="headerlink" title="读取所有key"></a>读取所有key</h3><p>可以使用 keys 函数读取哈希所有的键，语法格式如下：<code>keys %HASH</code></p>
<p>eg</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">@names = <span class="keyword">keys</span> %data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$names[0]\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$names[1]\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$names[2]\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google</span><br><span class="line">runoob</span><br><span class="line">taobao</span><br></pre></td></tr></table></figure>

<p>类似的可以使用 values 函数来读取哈希所有的值,语法格式如下：<code>values %HASH</code><br>该函数返回所有哈希的所有 value 的数组。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">@urls = <span class="keyword">values</span> %data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$urls[0]\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$urls[1]\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$urls[2]\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google.com</span><br><span class="line">runoob.com</span><br><span class="line">taobao.com</span><br></pre></td></tr></table></figure>
<h2 id="检测元素是否存在"><a href="#检测元素是否存在" class="headerlink" title="检测元素是否存在"></a>检测元素是否存在</h2><p>在哈希中读取不存在的 key/value 对 ，会返回 undefined 值，且在执行时会有警告提醒。<br>为了避免这种情况，可以使用 exists 函数来判断key是否存在，存在的时候读取：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">exists</span>($data&#123;<span class="string">&#x27;facebook&#x27;</span>&#125; ) )&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;facebook 的网址为 $data&#123;&#x27;facebook&#x27;&#125; \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;facebook 键不存在\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取哈希大小"><a href="#获取哈希大小" class="headerlink" title="获取哈希大小"></a>获取哈希大小</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">@keys = <span class="keyword">keys</span> %data;</span><br><span class="line">$size = @keys;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;1 - 哈希大小: $size\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">@values = <span class="keyword">values</span> %data;</span><br><span class="line">$size = @values;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;2 - 哈希大小: $size\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><code>1 - 哈希大小: 3 2 - 哈希大小: 3</code></p>
<h2 id="哈希中添加或删除元素"><a href="#哈希中添加或删除元素" class="headerlink" title="哈希中添加或删除元素"></a>哈希中添加或删除元素</h2><p>添加 key/value 对可以通过简单的赋值来完成。但是删除哈希元素你需要使用 delete 函数：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line">@keys = <span class="keyword">keys</span> %data;</span><br><span class="line">$size = @keys;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;1 - 哈希大小: $size\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">$data&#123;<span class="string">&#x27;facebook&#x27;</span>&#125; = <span class="string">&#x27;facebook.com&#x27;</span>;</span><br><span class="line">@keys = <span class="keyword">keys</span> %data;</span><br><span class="line">$size = @keys;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;2 - 哈希大小: $size\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除哈希中的元素</span></span><br><span class="line"><span class="keyword">delete</span> $data&#123;<span class="string">&#x27;taobao&#x27;</span>&#125;;</span><br><span class="line">@keys = <span class="keyword">keys</span> %data;</span><br><span class="line">$size = @keys;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;3 - 哈希大小: $size\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><code>1 - 哈希大小: 3 2 - 哈希大小: 4 3 - 哈希大小: 3 </code></p>
<h2 id="迭代哈希"><a href="#迭代哈希" class="headerlink" title="迭代哈希"></a>迭代哈希</h2><p>可以使用 foreach 和 while 来迭代哈希：</p>
<h3 id="使用-foreach"><a href="#使用-foreach" class="headerlink" title="使用 foreach"></a>使用 foreach</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"><span class="keyword">foreach</span> $key (<span class="keyword">keys</span> %data)&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$data&#123;$key&#125;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-while"><a href="#使用-while" class="headerlink" title="使用 while"></a>使用 while</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">%data = (<span class="string">&#x27;google&#x27;</span>=&gt;<span class="string">&#x27;google.com&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>=&gt;<span class="string">&#x27;runoob.com&#x27;</span>, <span class="string">&#x27;taobao&#x27;</span>=&gt;<span class="string">&#x27;taobao.com&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(($key, $value) = <span class="keyword">each</span>(%data))&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$data&#123;$key&#125;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google.com</span><br><span class="line">runoob.com</span><br><span class="line">taobao.com</span><br></pre></td></tr></table></figure>
<h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><blockquote>
<p>数据<br>Heilongjiang Haerbin<br>Jilin   Changchun<br>Liaoning    Shenyang<br>Hebei   Shijiazhuang<br>Beijing Beijing<br>Tianjin Tianjin<br>Shanxi  Taiyuan<br>Shandong    Jinan<br>Anhui   Hefei<br>Jiangsu Nanjing</p>
</blockquote>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/uer/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> Data::Dumper;</span><br><span class="line">%hash=();</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(&lt;IN&gt;) &#123;</span><br><span class="line">	<span class="keyword">chomp</span>; <span class="comment">#标量</span></span><br><span class="line">	@line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_; <span class="comment">#数组，s+是匹配任意空白符，至少一次</span></span><br><span class="line">	$hash&#123;$line[<span class="number">0</span>]&#125;=$line[<span class="number">1</span>]; <span class="comment">#哈希</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">&quot;@line\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"></span><br><span class="line"><span class="comment"># print Dumper (\%hash);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">chomp</span> ($province=&lt;STDIN&gt;);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">exists</span> $hash&#123;$province&#125;) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;The captial of $province is :\t&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$hash&#123;$province&#125;\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;there is no data in the hash\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="序列提取"><a href="#序列提取" class="headerlink" title="序列提取"></a>序列提取</h1><blockquote>
<p>哈希，在生物数据分析中最常用的一个方式，序列提取。根据固定的ID从另一个文件或者数据库中将数据提取出来，也就是根据一个小数据从一个大数据中提取数据。<br>处理方式：将小的数据集存储到一个哈希中，然后在遍历大的数据集查看哈希是否存在，如果 存在即输出，不存在不输出任何东西，循环继续进行</p>
</blockquote>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> Data::Dumper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">scalar</span> @ARGV==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span> <span class="string">&quot;Usage: This program is used to get seqence by a list</span></span><br><span class="line"><span class="string">        perl $0 &lt;name list&gt; &lt;fasta sequence&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> %hash=(); <span class="comment">#my是用来定义一个变量</span></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;$ARGV[0]&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;</span><br><span class="line">    $hash&#123;$line[<span class="number">0</span>]&#125;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> FA,<span class="string">&quot;&lt;$ARGV[1]&quot;</span>;</span><br><span class="line">$/=<span class="string">&quot;&gt;&quot;</span>;&lt;FA&gt;;</span><br><span class="line"><span class="keyword">while</span> (&lt;FA&gt;) &#123;</span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">my</span> $temp=(<span class="keyword">split</span> <span class="regexp">/\n/</span>,$_,<span class="number">2</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">my</span> $id=(<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">exists</span> $hash&#123;$id&#125;) &#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;&gt;$_&quot;</span>; <span class="comment">#因为前面开头少了一个&gt;,所以这里加上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> FA;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h1><p>Perl 子程序也就是用户定义的函数。</p>
<p>Perl 子程序即执行一个特殊任务的一段分离的代码，它可以使减少重复代码且使程序易读。</p>
<p>Perl 子程序可以出现在程序的任何地方，语法格式如下：</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">subroutine</span></span>&#123;</span><br><span class="line">   statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用子程序语法格式：</span></span><br><span class="line"></span><br><span class="line">subroutine( 参数列表 );</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 Perl 5.0 以下版本调用子程序方法如下：</span></span><br><span class="line">&amp;subroutine( 参数列表 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">	<span class="keyword">print</span> <span class="string">&quot;Hello, world\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">hello();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果为：<br><code>Hello, world!</code></p>
<h2 id="向子程序传递参数"><a href="#向子程序传递参数" class="headerlink" title="向子程序传递参数"></a>向子程序传递参数</h2><p>Perl 子程序可以和其他编程一样接受多个参数，子程序参数使用特殊数组 @_ 标明。</p>
<p>因此子程序第一个参数为 $<em>[0], 第二个参数为 $</em>[1], 以此类推。</p>
<p>不论参数是标量型还是数组型的，用户把参数传给子程序时，perl默认按引用的方式调用它们。</p>
<h3 id="定义求和函数"><a href="#定义求和函数" class="headerlink" title="定义求和函数"></a>定义求和函数</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">sum</span> </span>&#123;</span><br><span class="line">	<span class="keyword">my</span> $num1=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">my</span> $num2=<span class="number">8</span>;</span><br><span class="line">	<span class="keyword">my</span> $total=$num1+$num2;</span><br><span class="line">	<span class="keyword">return</span> $total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $total=&amp;sum;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$total\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定义求平均值函数"><a href="#定义求平均值函数" class="headerlink" title="定义求平均值函数"></a>定义求平均值函数</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义求平均值函数</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">Average</span></span>&#123;</span><br><span class="line">   <span class="comment"># 获取所有传入的参数</span></span><br><span class="line">   $n = <span class="keyword">scalar</span>(@_);</span><br><span class="line">   $sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">foreach</span> $item (@_)&#123;</span><br><span class="line">      $sum += $item;</span><br><span class="line">   &#125;</span><br><span class="line">   $average = $sum / $n;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&#x27;传入的参数为 : &#x27;</span>,<span class="string">&quot;@_\n&quot;</span>;           <span class="comment"># 打印整个数组</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;第一个参数值为 : $_[0]\n&quot;</span>;         <span class="comment"># 打印第一个参数</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;传入参数的平均值为 : $average\n&quot;</span>;  <span class="comment"># 打印平均值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">Average(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果为：</p>
<p><code>传入的参数为 : 10 20 30 第一个参数值为 : 10 传入参数的平均值为 : 20</code></p>
<h2 id="向子程序传递列表"><a href="#向子程序传递列表" class="headerlink" title="向子程序传递列表"></a>向子程序传递列表</h2><p>由于 @_ 变量是一个数组，所以它可以向子程序中传递列表。</p>
<p>但如果我们需要传入标量和数组参数时，需要把列表放在最后一个参数上，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">PrintList</span></span>&#123;</span><br><span class="line">   <span class="keyword">my</span> @list = @_;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;列表为 : @list\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="number">10</span>;</span><br><span class="line">@b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 列表参数</span></span><br><span class="line">PrintList($a, @b);</span><br></pre></td></tr></table></figure>
<p>以上程序将标量和数组合并了，输出结果为：</p>
<p><code>列表为 : 10 1 2 3 4</code></p>
<h1 id="Perl-正则表达式"><a href="#Perl-正则表达式" class="headerlink" title="Perl 正则表达式"></a>Perl 正则表达式</h1><p>Perl的正则表达式的三种形式，分别是匹配，替换和转化:</p>
<p>匹配：m//（还可以简写为//，略去m）</p>
<p>替换：s///</p>
<p>转化：tr///</p>
<p>这三种形式一般都和 =~ 或 !~ 搭配使用， =~ 表示相匹配，!~ 表示不匹配。</p>
<h2 id="匹配操作符"><a href="#匹配操作符" class="headerlink" title="匹配操作符"></a>匹配操作符</h2><p>匹配操作符 m// 用于匹配一个字符串语句或者一个正则表达式，例如，要匹配 标量 $bar 中的 “run”,代码如下所示：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Do u like perl？\n&quot;</span>;</span><br><span class="line"><span class="keyword">my</span> $choice=&lt;STDIN&gt;;</span><br><span class="line"><span class="keyword">if</span> ($choice=~ <span class="regexp">/y e s/ix</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;Yes，So you need to work hard\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;No，So you need to work harder\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配修饰符"><a href="#模式匹配修饰符" class="headerlink" title="模式匹配修饰符"></a>模式匹配修饰符</h3><p>模式匹配有一些常用的修饰符，如下表所示：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>忽略模式中的大小写</td>
</tr>
<tr>
<td>m</td>
<td>多行模式</td>
</tr>
<tr>
<td>o</td>
<td>仅赋值一次</td>
</tr>
<tr>
<td>s</td>
<td>单行模式，”.”匹配”\n”（默认不匹配）</td>
</tr>
<tr>
<td>x</td>
<td>忽略模式中的空白</td>
</tr>
<tr>
<td>g</td>
<td>全局匹配</td>
</tr>
<tr>
<td>cg</td>
<td>全局匹配失败后，允许再次查找匹配串</td>
</tr>
</tbody></table>
<h3 id="示例-提取以ATG开头-TAA结尾的序列"><a href="#示例-提取以ATG开头-TAA结尾的序列" class="headerlink" title="示例 - 提取以ATG开头-TAA结尾的序列"></a>示例 - 提取以ATG开头-TAA结尾的序列</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;&lt;$ARGV[0]&quot;</span>,<span class="keyword">or</span> <span class="keyword">die</span> <span class="string">&quot;can not open the file\n$!&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^ATG.*TAA$/i</span>) &#123;    <span class="comment">#如果‘！/^ATG.*TAA$/i’ 则表示匹配除此之外的序列。</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;$_\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单词锚定"><a href="#单词锚定" class="headerlink" title="单词锚定"></a>单词锚定</h3><p>search、searches ，searcher，searched，<br>searching、researching</p>
<ol>
<li><p>只匹配search<br>/<strong>\b</strong>search<strong>\b</strong>/</p>
</li>
<li><p>匹配search、searches、 searcher、searched、searching<br>/<strong>\b</strong>search/</p>
</li>
<li><p>只匹配search、 research<br>/search<strong>\b</strong>/</p>
</li>
<li><p>不匹配search<br>/<strong>\B</strong>search<strong>\B</strong>/</p>
</li>
</ol>
<h2 id="正则表达式变量"><a href="#正则表达式变量" class="headerlink" title="正则表达式变量"></a>正则表达式变量</h2><p>perl处理完后会给匹配到的值存在三个特殊变量名:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$`: 匹配部分的前一部分字符串</span><br><span class="line">$&amp;: 匹配的字符串</span><br><span class="line">$<span class="string">&#x27;: 还没有匹配的剩余字符串</span></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">$string = <span class="string">&quot;welcome to lxz9.com&quot;</span>;</span><br><span class="line">$string =~ <span class="regexp">m/lxz/</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;匹配前的字符串: $`\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;匹配的字符串: $&amp;\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;匹配后的字符串: $&#x27;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<p>匹配前的字符串: welcome to<br>匹配的字符串: lxz<br>匹配后的字符串: 9.com</p>
<h2 id="替换操作符"><a href="#替换操作符" class="headerlink" title="替换操作符"></a>替换操作符</h2><p>基本格式：<code>s/PATTERN/REPLACEMENT/;</code></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">$string = <span class="string">&quot;welcome to google site.&quot;</span>;</span><br><span class="line">$string =~ <span class="regexp">s/google/lxz/</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$string\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<p>welcome to lxz site.</p>
<h3 id="替换操作修饰符"><a href="#替换操作修饰符" class="headerlink" title="替换操作修饰符"></a>替换操作修饰符</h3><p>替换操作修饰符如下表所示：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>如果在修饰符中加上”i”，则正则将会取消大小写敏感性，即”a”和”A” 是一样的。</td>
</tr>
<tr>
<td>m</td>
<td>默认的正则开始”^”和结束”$”只是对于正则字符串如果在修饰符中加上”m”，那么开始和结束将会指字符串的每一行：每一行的开头就是”^”，结尾就是”$”。</td>
</tr>
<tr>
<td>o</td>
<td>表达式只执行一次。</td>
</tr>
<tr>
<td>s</td>
<td>如果在修饰符中加入”s”，那么默认的”.”代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！</td>
</tr>
<tr>
<td>x</td>
<td>如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。</td>
</tr>
<tr>
<td>g</td>
<td>替换所有匹配的字符串。</td>
</tr>
<tr>
<td>e</td>
<td>替换字符串作为表达式</td>
</tr>
</tbody></table>
<h2 id="转化操作符"><a href="#转化操作符" class="headerlink" title="转化操作符"></a>转化操作符</h2><p>以下是转化操作符相关的修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>转化所有未指定字符</td>
</tr>
<tr>
<td>d</td>
<td>删除所有指定字符</td>
</tr>
<tr>
<td>s</td>
<td>把多个相同的输出字符缩成一个</td>
</tr>
</tbody></table>
<p>以下实例将变量 $string 中的所有小写字母转化为大写字母：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl </span></span><br><span class="line"></span><br><span class="line">$string = <span class="string">&#x27;welcome to lxz site.&#x27;</span>;</span><br><span class="line">$string =~ <span class="regexp">tr/a-z/A-z/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$string\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<p>WELCOME TO LXZ SITE.</p>
<p>以下实例使用 /s 将变量 $string 重复的字符删除：</p>
<p>实例</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"> </span><br><span class="line">$string = <span class="string">&#x27;lxzz&#x27;</span>;</span><br><span class="line">$string =~ <span class="regexp">tr/a-z/a-z/s</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$string\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：<br>lxz</p>
<p>更多实例：</p>
<p>$string =~ tr/\d/ /c;     # 把所有非数字字符替换为空格<br>$string =~ tr/\t //d;     # 删除tab和空格<br>$string =~ tr/0-9/ /cs    # 把数字间的其它字符替换为一个空格。</p>
<h2 id="更多正则表达式规则"><a href="#更多正则表达式规则" class="headerlink" title="更多正则表达式规则"></a>更多正则表达式规则</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的所有字符</td>
</tr>
<tr>
<td>x?</td>
<td>匹配 0 次或一次 x 字符串</td>
</tr>
<tr>
<td>x*</td>
<td>匹配 0 次或多次 x 字符串,但匹配可能的最少次数</td>
</tr>
<tr>
<td>x+</td>
<td>匹配 1 次或多次 x 字符串,但匹配可能的最少次数</td>
</tr>
<tr>
<td>.*</td>
<td>匹配 0 次或多次的任何字符</td>
</tr>
<tr>
<td>.+</td>
<td>匹配 1 次或多次的任何字符</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配刚好是 m 个 的指定字符串</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配在 m个 以上 n个 以下 的指定字符串</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配 m个 以上 的指定字符串</td>
</tr>
<tr>
<td>[]</td>
<td>匹配符合 [] 内的字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不符合 [] 内的字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配所有数字字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配所有小写字母字符</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配所有非数字字符</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>匹配所有非小写字母字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符开头的字符</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符结尾的字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字的字符,和 [0-9] 语法一样</td>
</tr>
<tr>
<td>\d+</td>
<td>匹配多个数字字符串,和 [0-9]+ 语法一样</td>
</tr>
<tr>
<td>\D</td>
<td>非数字,其他同 \d</td>
</tr>
<tr>
<td>\D+</td>
<td>非数字,其他同 \d+</td>
</tr>
<tr>
<td>\w</td>
<td>英文字母或数字的字符串,和 [a-zA-Z0-9_] 语法一样</td>
</tr>
<tr>
<td>\w+</td>
<td>和 [a-zA-Z0-9_]+ 语法一样</td>
</tr>
<tr>
<td>\W</td>
<td>非英文字母或数字的字符串,和 [^a-zA-Z0-9_] 语法一样</td>
</tr>
<tr>
<td>\W+</td>
<td>和 [^a-zA-Z0-9_]+ 语法一样</td>
</tr>
<tr>
<td>\s</td>
<td>空格,和 [\n\t\r\f] 语法一样</td>
</tr>
<tr>
<td>\s+</td>
<td>和 [\n\t\r\f]+ 一样</td>
</tr>
<tr>
<td>\S</td>
<td>非空格,和 [^\n\t\r\f] 语法一样</td>
</tr>
<tr>
<td>\S+</td>
<td>和 [^\n\t\r\f]+ 语法一样</td>
</tr>
<tr>
<td>\b</td>
<td>匹配以英文字母,数字为边界的字符串</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不以英文字母,数值为边界的字符串</td>
</tr>
<tr>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>abc</td>
<td>匹配含有 abc 的字符串 (pattern) () 这个符号会记住所找寻到的字符串,是一个很实用的语法.第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量,第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量,以此类推下去.</td>
</tr>
<tr>
<td>/pattern/i</td>
<td>i 这个参数表示忽略英文大小写,也就是在匹配字符串的时候,不考虑英文的大小写问题. \ 如果要在 pattern 模式中找寻一个特殊字符,如 “*”,则要在这个字符前加上 \ 符号,这样才会让特殊字符失效</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Perl</category>
      </categories>
      <tags>
        <tag>Perl</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>WGDI 分析全基因组复制事件完整流程</title>
    <url>/2021/09/06/wgdi/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>WGDI（全基因组重复识别），一种基于 Python 的命令行工具，可让研究人员深入了解递归多倍化并进行跨物种基因组比对分析。</p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/09/06/h47UxJ.png"></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.使用conda安装</span></span><br><span class="line">conda install -c bioconda  wgdi</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.使用pip安装</span></span><br><span class="line">pip install wgdi</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.本地安装</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/SunPengChuan/wgdi.git</span><br><span class="line"><span class="built_in">cd</span> wgdi</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h1 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h1><p><a href="http://abacus.gene.ucl.ac.uk/software/paml.html">PAML</a> | <a href="https://mafft.cbrc.jp/alignment/software/">MAFFT</a> | <a href="http://www.drive5.com/muscle/downloads.htm">MUSCLE</a> | <a href="http://www.bork.embl.de/pal2nal/#Download">PAL2NAL</a> | <a href="http://www.iqtree.org/#download">IQTREE</a></p>
<blockquote>
<p>使用pip下载完成 需要配置文件目录<br><code>wgdi -conf /？ &gt;conf.ini</code><br>里面是默认的文件路径，如果不对应打开修改即可<br>再次输入 <code>wgdi -conf conf.ini</code><br>就将配置环境导入到程序中了</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><blockquote>
<p>数据处理是很有必要的，如果格式不正确，后面的分析很有可能会报错，大家可以自行处理数据得到gff文件以及基因组len文件</p>
</blockquote>
<div class="note purple no-icon flat"><p>下面提供wgdi作者以及写的处理脚本,具体脚本内容将放到本文末尾</p>
<p>01.getgff.py<br>02.gff_lens.py<br>03.seq_newname.py<br>generate_conf.py  # 脚本由<a href="https://xuzhougeng.top/">徐洲更</a>制作。<a href="https://github.com/xuzhougeng/myscripts/blob/master/comparative/generate_conf.py">下载链接</a></p>
</div>

<h2 id="序列比对"><a href="#序列比对" class="headerlink" title="序列比对"></a>序列比对</h2><blockquote>
<p>通过blastp或者diamond进行蛋白之间比对。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">makeblastdb -<span class="keyword">in</span> ath.pep.fa -dbtype prot</span><br><span class="line">blastp -num_threads 50 -db ath.pep.fa -query ath.pep.fa -outfmt 6 -evalue 1e-5 -num_alignments 20  -out ath.blastp.txt &amp; </span><br></pre></td></tr></table></figure>
<h2 id="点图"><a href="#点图" class="headerlink" title="点图"></a>点图</h2><blockquote>
<p>使用命令进入文件夹取出参数文件，主要是通过前面的[] 去识别程序所以可以将下列所有步骤放到一个文本文件中。</p>
</blockquote>
<p><code>wgdi -d help &gt;&gt; total.conf</code></p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dotplot]</span><br><span class="line">blast = blast file <span class="comment"># blast</span></span><br><span class="line">blast_reverse = <span class="literal">false</span></span><br><span class="line">gff1 =  gff1 file <span class="comment"># gff和len使用python程序可以提取，格式有要求</span></span><br><span class="line">gff2 =  gff2 file</span><br><span class="line">lens1 = lens1 file</span><br><span class="line">lens2 = lens2 file</span><br><span class="line">genome1_name =  Genome1 name</span><br><span class="line">genome2_name =  Genome2 name</span><br><span class="line">multiple  = 1 <span class="comment"># 最好同源的个数(用红色表示)，不清楚就写1</span></span><br><span class="line">score = 100</span><br><span class="line">evalue = 1e-5</span><br><span class="line">repeat_number = 10 <span class="comment"># 基因相对另一个基因组同源基因的数量限制</span></span><br><span class="line">position = order <span class="comment"># 与end相比，end的点图相对比较集中。</span></span><br><span class="line">blast_reverse = <span class="literal">false</span> <span class="comment"># 比对中基因对顺序是否翻转,</span></span><br><span class="line">ancestor_left = none <span class="comment"># 点图左侧物种的祖先染色体区域</span></span><br><span class="line">ancestor_top = none <span class="comment"># 点图顶部物种的祖先染色体区域</span></span><br><span class="line">markersize = 0.5 <span class="comment"># 调整图中点的大小</span></span><br><span class="line">figsize = 10,10 <span class="comment"># 保存图片大小比例</span></span><br><span class="line">savefig = savefile(.svg,.png,.pdf) <span class="comment"># 类型： 默认： *.PNG保存图片支持png、pdf、svg格式</span></span><br></pre></td></tr></table></figure>
<p>运行命令 <code>wgdi -d total.conf</code></p>
<blockquote>
<p>任意修改lens1 和lens2的染色体的数量和顺序，可以得到任意染色体间的点图。<br>如果想修改图片中染色体的位置，则可以改动len文件进行操作。<br>也可以单独选择几条染色体做点图观察，都是通过改动len文件进行的</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/09/06/h5uEPP.png" alt="dotpot"></p>
<p><img src="https://z3.ax1x.com/2021/09/06/h5uZ28.png" alt="dotpot2"></p>
<blockquote>
<p>点图解读：<br>点图规则：点图是根据左边基因组的基因，最好同源的点为红色，次好的四个基因为蓝色，剩余部分（同源基因有限制个数）为灰色，是根据打分结果进行排序的。<br>（1）点图需要横向看和纵向看：这个点图是物种自身比对，所以只需横向看。片段深度应该为2，但最好同源个数为1，即红色点没有集中分布在某个片段上。常常可以认两个片段很相似，再加上自身。所以，认定为最近发生的加倍为三倍化。除此之外，蓝色或灰色的片段很少有，表明更古老的加倍很不明显。<br>（2）对角线上，本不应该出现片段。自身比自身显然是最好匹配，这些点已经去掉了。而剩余的这些由于串联重复造成的。即该基因临近的位置同源性很高，打在了对角线附近。可以计算这些串联重复的ks值，估算重复片段的爆发时间。<br>（3）这个点图是后续跑共线性的基石。所以，score， evalue， repeat_number判定的同源点的数量是共线性打分矩阵的来源。</p>
</blockquote>
<blockquote>
<p>可以看到点图的结果中，共线性片段，按照blast进行排序，红色，蓝色  ，灰色是最后剩下的，左边相对上面的义工只有十个同源基因对应<br>看到点图中共线性片段大多是由红色和蓝色构成的。</p>
</blockquote>
<h2 id="共线性"><a href="#共线性" class="headerlink" title="共线性"></a>共线性</h2><p>使用命令进入文件夹取出参数文件。<code>wgdi -icl ? &gt;&gt; total.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[collinearity]</span><br><span class="line">gff1 = gff1 file</span><br><span class="line">gff2 = gff2 file</span><br><span class="line">lens1 = lens1 file</span><br><span class="line">lens2 = lens2 file</span><br><span class="line">blast = blast file</span><br><span class="line">blast_reverse = <span class="literal">false</span></span><br><span class="line">multiple  = 1 <span class="comment"># 用红点显示的同源基因的最佳数量</span></span><br><span class="line">process = 8 <span class="comment"># 根据点图中的颜色分配不同的分数，红色默认为 50，蓝色为 40，灰色为 25。</span></span><br><span class="line">evalue = 1e-5</span><br><span class="line">score = 100 <span class="comment"># 和点图保持一致</span></span><br><span class="line">grading = 50,40,25 <span class="comment"># 红，蓝，灰的不同分值,按照分值会优先连红色的点，蓝色点次之</span></span><br><span class="line">mg = 40,40 <span class="comment"># 两个基因对被认为能连起来的最大距离（罚分）</span></span><br><span class="line">pvalue = 0.2 <span class="comment"># 评估共线性的指标，如果想全部提取可以选1，共线块的compactness and uniqueness，范围为0-1，较好的共线范围为0-0.2</span></span><br><span class="line">repeat_number = 10 <span class="comment"># 和点图保持一致 </span></span><br><span class="line">positon = order <span class="comment">#唯一选项</span></span><br><span class="line">savefile = collinearity file <span class="comment"># 输出文件</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>wgdi -icl total.conf</code></p>
<h2 id="Ks值计算"><a href="#Ks值计算" class="headerlink" title="Ks值计算"></a>Ks值计算</h2><p><code>wgdi -ks ? &gt;&gt; total.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[ks]</span><br><span class="line">cds_file =      cds file <span class="comment"># 两个物种或物种自身的cds序列，如果要计算多个物种，可以将它们文件cat到一起</span></span><br><span class="line">pep_file =      pep file <span class="comment"># 两个物种或物种自身的pep序列</span></span><br><span class="line">align_software = muscle <span class="comment"># 选择mafft or muscle</span></span><br><span class="line">pairs_file = gene pairs file <span class="comment">#代表其中一种: colinearscan输出结果 / mcscanx输出结果 / collinearity输出结果 / tab分割的基因对</span></span><br><span class="line">ks_file = ks result <span class="comment"># 输出文件，格式有要求</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>wgdi -ks total.conf</code></p>
<blockquote>
<p>输出的ks结果，基因对算不出来的ks值，默认为-1。</p>
</blockquote>
<h2 id="Blockinfo"><a href="#Blockinfo" class="headerlink" title="Blockinfo"></a>Blockinfo</h2><p>因为共线性和ks值结果不容易展示，而且，常常需要对共线性结果筛选，因此，将这些信息汇总到一个表中，方便删选。<br>这一步主要是将前面跑的共线性和ks值统一到一个文件当中。</p>
<p>首先将参数保存到文件当中<br><code>wgdi -bi ? &gt;&gt; total.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blockinfo]</span><br><span class="line">blast = blast file</span><br><span class="line">gff1 =  gff1 file</span><br><span class="line">gff2 =  gff2 file</span><br><span class="line">lens1 = lens1 file</span><br><span class="line">lens2 = lens2 file</span><br><span class="line">collinearity = collinearity file</span><br><span class="line">score = 100 <span class="comment"># 和之前设置的保持一致</span></span><br><span class="line">evalue = 1e-5 <span class="comment"># 和点图、共线性计算的配置文件保持一致</span></span><br><span class="line">repeat_number = 20 <span class="comment"># 和点图、共线性计算的配置文件保持一致</span></span><br><span class="line">position = order <span class="comment"># 仅有order选项</span></span><br><span class="line">ks = ks file</span><br><span class="line">ks_col = ks_NG86 <span class="comment"># 根据之前ks得出的列表选择，软件会生成ks_NG86或ks_YN00，也可以用其他方式计算的结果单独一列</span></span><br><span class="line">savefile = block_information.csv <span class="comment"># 将共线性和ks值汇总到一起</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>wgdi -bi total.conf</code></p>
<p>结果生成一个表block_information.csv<br><img src="https://z3.ax1x.com/2021/09/06/h4WMRI.png"></p>
<blockquote>
<p>第1列: id  共线性的结果的唯一标识<br>第2.4.5列: chr1,start1,end1 参考基因组（点图的左边）的共线性范围<br>第3.6.7列: chr2,start2,end2 参考基因组（点图的上边）的共线性范围<br>第8列: pvalue 评估共线性的结果，常常认为小于0.01的更合理些<br>第9列: length 共线性片段长度<br>ks_median 共线性片段上所有基因对ks的中位数（主要用来评判ks分布的）<br>ks_average 共线性片段上所有基因对ks的平均值<br>homo1   homo2   homo3   homo4   homo5 与multiple参数有关，即homo+multiple<br>主要规则是：基因对如果在点图中为红色，赋值为1，蓝色赋值为0，灰色赋值为-1。共线性片段上所有基因对赋值后求平均值，这样就赋予该共线性一个-1,1的值。如果共线性的点大部分为红色，那么该值接近于1。可以作为共线性片段的筛选。<br>block1,block2 分别为共线性片段上基因order的位置。<br>ks 共线性片段的上基因对的ks值<br>density1, density2 共线性片段的基因分布密集程度。值越小表示稀疏;如何计算的呢？就是length 除以对应的srart1 end1 差值</p>
</blockquote>
<h2 id="Correspondence"><a href="#Correspondence" class="headerlink" title="Correspondence"></a>Correspondence</h2><p><code>wgdi -c ? &gt;&gt; total.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[correspondence]</span><br><span class="line">blockinfo =  block_information.csv <span class="comment">#上一步blockinfo的输出csv文件作为输入文件</span></span><br><span class="line">lens1 = lens1 file</span><br><span class="line">lens2 = lens2 file</span><br><span class="line">tandem = (<span class="literal">true</span>/<span class="literal">false</span>) <span class="comment">#前一步展示过了不需要分析改为false</span></span><br><span class="line">tandem_length = 200 <span class="comment">#看对角线有没有加倍造成的片段，如果对角线上的ks值趋于0，那就不属于。</span></span><br><span class="line">pvalue = 0.05 <span class="comment">#要提取好的共线性 作者设置为了0.2</span></span><br><span class="line">block_length = 5</span><br><span class="line">multiple  = 1</span><br><span class="line">homo = 0,1</span><br><span class="line">savefile = block_information.new.csv <span class="comment"># 名称自定义(*.csv即可)</span></span><br></pre></td></tr></table></figure>
<p><code>wgd -c total.conf</code></p>
<p>筛选完的结果，是将对角线上的片段去除，剩余一些需要的片段。<br>得出筛选完之后的结果会发现新的csv文件会比之前的文件要小，主要就是将对角线上的片段给去除了。</p>
<h2 id="blockks"><a href="#blockks" class="headerlink" title="blockks"></a>blockks</h2><p><code>wgdi -bk ? &gt; blockks.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blockks]</span><br><span class="line">lens1 = lens1 file</span><br><span class="line">lens2 = lens2 file</span><br><span class="line">genome1_name =  Genome1 name</span><br><span class="line">genome2_name =  Genome2 name</span><br><span class="line">blockinfo = block_information.new.csv</span><br><span class="line">pvalue = 0.05</span><br><span class="line">tandem = <span class="literal">true</span></span><br><span class="line">tandem_length = 200</span><br><span class="line">markersize = 1 <span class="comment">#点的大小</span></span><br><span class="line">area = 0,2 <span class="comment">#显示范围</span></span><br><span class="line">block_length =  minimum length</span><br><span class="line">figsize = 8,8 <span class="comment">#点图大小的比例值</span></span><br><span class="line">savefig = save image <span class="comment">#保存图片，默认： *.PNG保存图片支持png、pdf、svg格式</span></span><br></pre></td></tr></table></figure>
<p><code>wgdi -bk total.conf</code></p>
<p>最终得到的结果会发现对角线上的点被去除，但是还是会有一些点会没有去除。但是也可以继续进行后续操作。</p>
<h2 id="KsPeaks"><a href="#KsPeaks" class="headerlink" title="KsPeaks"></a>KsPeaks</h2><p>计算Ks峰值</p>
<p><code>wgdi -kp ? &gt;&gt; total.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kspeaks]</span><br><span class="line"></span><br><span class="line"> blockinfo = block_information.new.csv</span><br><span class="line"> pvalue = 0.05 <span class="comment">#设置可自行调整</span></span><br><span class="line"> tandem = <span class="literal">true</span></span><br><span class="line"> block_ length = int number</span><br><span class="line"> ks_area = 0,10</span><br><span class="line"> multiple = 1</span><br><span class="line"> homo = 0,1 <span class="comment">#结合最开始的点图，红色点代表1，查看共线性片段如果红色居多，整个共线性片段的值就接近于1，可以写成0.3/0.5,1</span></span><br><span class="line"> fontsize = 9</span><br><span class="line"> area = 0,3 </span><br><span class="line"> figsize = 10,6.18</span><br><span class="line"> savefig = saving image</span><br><span class="line"> savefile = ks_median.distri.csv</span><br></pre></td></tr></table></figure>
<p><code>wgdi -kp total.conf</code></p>
<p><img src="https://z3.ax1x.com/2021/09/06/h5uV8f.png" alt="KsPeaks"></p>
<p>结果图片如果发现前面趋于0 的值比较多，查看前面得出的点图，原因是由于Correspondence这一步设置的tandom值长度偏小，<br>可以继续拟合或者直接在ks_median.distri.csv文件中进行筛选，将ks_median和ks_average进行从小到大排序，将数值过低的去除，它们还有一个特性就是<br>chr1以及chr2 都是自己对自己。<br>将修改结果重新输入[kspeaks] blockinfo = 修改后的(<code>*.csv</code>)</p>
<h2 id="PeaksFit"><a href="#PeaksFit" class="headerlink" title="PeaksFit"></a>PeaksFit</h2><p>峰拟合，需要结合KsPeaks和blockks的结果看峰为一个还是多个，<code>mode = median</code>建议用每个block的中位数的ks值去做拟合。</p>
<p><code>wgdi -pf ? &gt;&gt; total.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[peaksfit] </span><br><span class="line">blockinfo = block information  <span class="comment">#经过kspeaks处理的单个峰的输出文件(*.csv)</span></span><br><span class="line">mode = median  <span class="comment">#分为，对应Ks峰图的三块median，average，total</span></span><br><span class="line">bins_number = 200  <span class="comment">#柱状图的bins</span></span><br><span class="line">ks_area = 0,10  <span class="comment">#ks值的范围，可以去掉一些奇异的ks值</span></span><br><span class="line">fontsize = 9 </span><br><span class="line">area = 0,3  <span class="comment">#横轴的范围</span></span><br><span class="line">figsize = 10,6.18 </span><br><span class="line">savefig = saving image</span><br></pre></td></tr></table></figure>
<p><code>wgdi -pf total.conf</code></p>
<blockquote>
<p>跑完得到 拟合优度以及对应的曲线<br>R-square: 0.9618516780863838<br>The gaussian fitting curve parameters are :<br>1.305477901404146  |  2.1185082504069626  |  0.41222580475422466<br>其中：<br>中间的第二个值就是峰值的大小，数据保存到单独文件中，就可以绘制多个物种种内和种间的ks峰值了。</p>
</blockquote>
<p>关于一个物种发生多次加倍事件如何获取Ks峰值的策略:<br>每次加倍保留的共线性片段是一定的，是某一次产生的。可以通过Ks值进行区分。<br>应该对其分开处理，对共线性片段筛选（去除对角线的Ks峰或者有多次加倍的颜色发生变化的需要去除之后在进行拟合）</p>
<p><img src="https://z3.ax1x.com/2021/09/06/h5uk5t.png" alt="PeaksFit"></p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="getgff-py"><a href="#getgff-py" class="headerlink" title="getgff.py"></a>getgff.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(sys.argv[<span class="number">1</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>,skiprows=<span class="number">0</span>)</span><br><span class="line">data = data[data[<span class="number">2</span>] == <span class="string">&#x27;mRNA&#x27;</span>]</span><br><span class="line">data = data.loc[:, [<span class="number">0</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]]</span><br><span class="line">data[<span class="number">8</span>] = data[<span class="number">8</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;:|=|;|\|&#x27;</span>,expand=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># data.drop_duplicates(subset=[8], keep=&#x27;first&#x27;, inplace=True)</span></span><br><span class="line">data[<span class="number">0</span>] = data[<span class="number">0</span>].<span class="built_in">str</span>.replace(<span class="string">&#x27;At&#x27;</span>,<span class="string">&#x27;&#x27;</span>,regex=<span class="literal">True</span>)</span><br><span class="line">data.to_csv(sys.argv[<span class="number">2</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="gff-lens-py"><a href="#gff-lens-py" class="headerlink" title="gff_lens.py"></a>gff_lens.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment"># conding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(sys.argv[<span class="number">1</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">new = data[<span class="number">1</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;.&#x27;</span>).<span class="built_in">str</span></span><br><span class="line">data[<span class="string">&#x27;id&#x27;</span>] = new[<span class="number">0</span>].values</span><br><span class="line">data[<span class="string">&#x27;cha&#x27;</span>] = data[<span class="number">3</span>]-data[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> data.groupby([<span class="string">&#x27;id&#x27;</span>]):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(group) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ind = group.sort_values(by=<span class="string">&#x27;cha&#x27;</span>, ascending=<span class="literal">False</span>).index[<span class="number">1</span>:].values</span><br><span class="line">    data.drop(index=ind, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data[2] =data[2].astype(int)</span></span><br><span class="line"><span class="comment"># data[3] =data[3].astype(int)</span></span><br><span class="line"><span class="comment"># for name, group in data.groupby(0):</span></span><br><span class="line"><span class="comment">#     if len(group) == 1:</span></span><br><span class="line"><span class="comment">#         continue</span></span><br><span class="line"><span class="comment">#     start=0</span></span><br><span class="line"><span class="comment">#     # print(group.head())</span></span><br><span class="line"><span class="comment">#     group = group.sort_values(by=[2,3],ascending=[True,False])</span></span><br><span class="line"><span class="comment">#     for index, row in group.iterrows():</span></span><br><span class="line"><span class="comment">#         # print(row)</span></span><br><span class="line"><span class="comment">#         if row[3]&gt;start or row[2]&gt;start:</span></span><br><span class="line"><span class="comment">#             start=max([row[3],row[2]])</span></span><br><span class="line"><span class="comment">#             continue</span></span><br><span class="line"><span class="comment">#         data.drop(index=index, inplace=True)</span></span><br><span class="line">    <span class="comment"># ind = group.sort_values(by=&#x27;cha&#x27;, ascending=False).index[1:].values</span></span><br><span class="line">    <span class="comment">#print(name)</span></span><br><span class="line">    <span class="comment"># print(group.sort_values(by=&#x27;cha&#x27;,ascending=False))</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># data = data[data[1].str.contains(&#x27;\.mRNA1$&#x27;)]</span></span><br><span class="line">data[<span class="string">&#x27;order&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;newname&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">print(data.head())</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> data.groupby([<span class="number">0</span>]):</span><br><span class="line">    number = <span class="built_in">len</span>(group)</span><br><span class="line">    group = group.sort_values(by=[<span class="number">2</span>])</span><br><span class="line">    data.loc[group.index, <span class="string">&#x27;order&#x27;</span>] = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(group)+<span class="number">1</span>))</span><br><span class="line">    data.loc[group.index, <span class="string">&#x27;newname&#x27;</span>] = <span class="built_in">list</span>(</span><br><span class="line">        [<span class="string">&#x27;ath2s&#x27;</span>+<span class="built_in">str</span>(name)+<span class="string">&#x27;g&#x27;</span>+<span class="built_in">str</span>(i).zfill(<span class="number">5</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(group)+<span class="number">1</span>)])</span><br><span class="line">data[<span class="string">&#x27;order&#x27;</span>] = data[<span class="string">&#x27;order&#x27;</span>].astype(<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">data = data[[<span class="number">0</span>, <span class="string">&#x27;newname&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;order&#x27;</span>, <span class="number">1</span>]]</span><br><span class="line">print(data.head())</span><br><span class="line">data = data.sort_values(by=[<span class="number">0</span>, <span class="string">&#x27;order&#x27;</span>])</span><br><span class="line">data.to_csv(sys.argv[<span class="number">2</span>], sep=<span class="string">&quot;\t&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">None</span>)</span><br><span class="line">lens = data.groupby(<span class="number">0</span>).<span class="built_in">max</span>()[[<span class="number">3</span>, <span class="string">&#x27;order&#x27;</span>]]</span><br><span class="line">lens.to_csv(sys.argv[<span class="number">3</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="seq-newname-py"><a href="#seq-newname-py" class="headerlink" title="seq_newname.py"></a>seq_newname.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(sys.argv[<span class="number">1</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>, index_col=<span class="number">6</span>)</span><br><span class="line">data.index = data.index.<span class="built_in">str</span>[:-<span class="number">3</span>]</span><br><span class="line">id_dict = data[<span class="number">1</span>].to_dict()</span><br><span class="line">print(data.head())</span><br><span class="line">seqs = []</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(sys.argv[<span class="number">2</span>], <span class="string">&quot;fasta&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> seq_record.<span class="built_in">id</span> <span class="keyword">in</span> id_dict:</span><br><span class="line">        seq_record.<span class="built_in">id</span> = id_dict[seq_record.<span class="built_in">id</span>]</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    seqs.append(seq_record)</span><br><span class="line">SeqIO.write(seqs, sys.argv[<span class="number">3</span>], <span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>
<h2 id="generate-conf-py"><a href="#generate-conf-py" class="headerlink" title="generate_conf.py"></a>generate_conf.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GFF must have CDS feature</span></span><br><span class="line"><span class="comment"># GFF must have ID and Parent in column 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get options&quot;&quot;&quot;</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;fasta&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;fasta file name&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;gff&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;gff file name&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-p&#x27;</span>,<span class="string">&#x27;--prefix&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;output&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;prefix for ouput &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get the fasta  len</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fasta_len</span>(<span class="params">fasta</span>):</span></span><br><span class="line">    fasta_dict = OrderedDict()</span><br><span class="line">    handle = <span class="built_in">open</span>(fasta, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    active_sequence_name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> handle:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;&gt;&quot;</span>): </span><br><span class="line">            active_sequence_name = line[<span class="number">1</span>:]</span><br><span class="line">            active_sequence_name = active_sequence_name.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> active_sequence_name <span class="keyword">not</span> <span class="keyword">in</span> fasta_dict:</span><br><span class="line">            fasta_dict[active_sequence_name] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sequence = line</span><br><span class="line">        fasta_dict[active_sequence_name] += <span class="built_in">len</span>(sequence)</span><br><span class="line">    handle.close()</span><br><span class="line">    <span class="keyword">return</span> fasta_dict</span><br><span class="line"></span><br><span class="line"><span class="comment"># parse the gff </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_gff</span>(<span class="params">gff</span>):</span></span><br><span class="line"></span><br><span class="line">    gene_dict = OrderedDict()</span><br><span class="line">    tx_pos_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    CDS_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    handle = <span class="built_in">open</span>(gff, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> handle:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        content = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(content) &lt;= <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment">#print(content)</span></span><br><span class="line">        <span class="keyword">if</span> content[<span class="number">2</span>] == <span class="string">&quot;transcript&quot;</span> <span class="keyword">or</span> content[<span class="number">2</span>] == <span class="string">&quot;mRNA&quot;</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># use regual expression to extract the gene ID</span></span><br><span class="line">            <span class="comment"># match the pattern ID=xxxxx; or ID=xxxxx</span></span><br><span class="line"></span><br><span class="line">            tx_id = re.search(<span class="string">r&#x27;ID=(.*?)[;\n]&#x27;</span>,content[<span class="number">8</span>]).group(<span class="number">1</span>)</span><br><span class="line">            tx_parent = re.search(<span class="string">r&#x27;Parent=(.*?)[;\n]&#x27;</span>,content[<span class="number">8</span>]).group(<span class="number">1</span>)</span><br><span class="line">            tx_parent = tx_parent.strip() <span class="comment"># remove the &#x27;r&#x27; and &#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if the parent of transcript is not in the gene_dict, create it rather than append</span></span><br><span class="line">            <span class="keyword">if</span> tx_parent <span class="keyword">in</span> gene_dict:</span><br><span class="line">                gene_dict[tx_parent].append(tx_id)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                gene_dict[tx_parent] = [tx_id]</span><br><span class="line">            tx_pos_dict[tx_id] = [content[<span class="number">0</span>],content[<span class="number">3</span>], content[<span class="number">4</span>], content[<span class="number">6</span>] ]</span><br><span class="line">        <span class="comment"># GFF must have CDS feature</span></span><br><span class="line">        <span class="keyword">if</span> content[<span class="number">2</span>] == <span class="string">&#x27;CDS&#x27;</span>:</span><br><span class="line">            width = <span class="built_in">int</span>(content[<span class="number">4</span>]) - <span class="built_in">int</span>(content[<span class="number">3</span>])</span><br><span class="line">            CDS_parent = re.search(<span class="string">r&#x27;Parent=(.*?)[;\n]&#x27;</span>,content[<span class="number">8</span>]).group(<span class="number">1</span>)</span><br><span class="line">            CDS_parent = CDS_parent.strip() <span class="comment"># strip the &#x27;\r&#x27; and &#x27;\n&#x27;</span></span><br><span class="line">            CDS_dict[CDS_parent].append(width)</span><br><span class="line">    handle.close()</span><br><span class="line">    <span class="keyword">return</span> [gene_dict, tx_pos_dict, CDS_dict]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = get_parser()</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    fa_dict = get_fasta_len( args.fasta)</span><br><span class="line">    gene_dict, tx_pos_dict, CDS_dict= parse_gff( args.gff )</span><br><span class="line">    gene_count = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># outfile</span></span><br><span class="line">    len_file = <span class="built_in">open</span>(args.prefix + <span class="string">&quot;.len&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    gff_file = <span class="built_in">open</span>(args.prefix + <span class="string">&quot;.gff&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gene, txs <span class="keyword">in</span> gene_dict.items():</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> tx <span class="keyword">in</span> txs:</span><br><span class="line">            tx_len = <span class="built_in">sum</span>(CDS_dict[tx])</span><br><span class="line">            <span class="keyword">if</span> tx_len &gt; tmp:</span><br><span class="line">                lst_tx = tx</span><br><span class="line">                tmp = tx_len</span><br><span class="line">        tx_chrom = tx_pos_dict[lst_tx][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> tx_chrom <span class="keyword">not</span> <span class="keyword">in</span> gene_count:</span><br><span class="line">            gene_count[tx_chrom] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gene_count[tx_chrom] += <span class="number">1</span></span><br><span class="line">        tx_start = tx_pos_dict[lst_tx][<span class="number">1</span>]</span><br><span class="line">        tx_end   = tx_pos_dict[lst_tx][<span class="number">2</span>]</span><br><span class="line">        tx_strand = tx_pos_dict[lst_tx][<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;&#123;chrom&#125;\t&#123;gene&#125;\t&#123;start&#125;\t&#123;end&#125;\t&#123;strand&#125;\t&#123;order&#125;\t&#123;tx&#125;&quot;</span>.<span class="built_in">format</span>(\</span><br><span class="line">                chrom=tx_chrom,gene=gene,start=tx_start,end=tx_end,strand=tx_strand,order=gene_count[tx_chrom],tx=lst_tx), file=gff_file )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> chrom,lens <span class="keyword">in</span> fa_dict.items():</span><br><span class="line">        print(<span class="string">&quot;&#123;chrom&#125;\t&#123;lens&#125;\t&#123;count&#125;&quot;</span>.<span class="built_in">format</span>(\</span><br><span class="line">                chrom=chrom,lens=lens,count=gene_count[chrom]), file=len_file)</span><br><span class="line">    len_file.close()</span><br><span class="line">    gff_file.close()</span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>Sun P, Jiao B, Yang Y, et al. WGDI: A user-friendly toolkit for evolutionary analyses of whole-genome duplications and ancestral karyotypes[J]. bioRxiv, 2021.</p>
]]></content>
      <categories>
        <category>比较基因组学</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>WGD</tag>
        <tag>WGDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux三剑客grep、sed、awk的使用</title>
    <url>/2021/04/22/linux01/</url>
    <content><![CDATA[<h1 id="Linux正则表达式"><a href="#Linux正则表达式" class="headerlink" title="Linux正则表达式"></a>Linux正则表达式</h1><div class="note orange no-icon flat"><p>正则表达式：Regual Expression, REGEXP<br>由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配的功能；<br>分两类：<br>基本正则表达式：BRE<br>扩展正则表达式：ERE</p>
</div>

<h2 id="正则表达式的意义"><a href="#正则表达式的意义" class="headerlink" title="正则表达式的意义"></a>正则表达式的意义</h2><ol>
<li>处理大量的字符串</li>
<li>处理文本</li>
<li>通过特殊符号的辅助，可以让linux管理员快速过滤、替换、处理所需要的字符串、文本，让工作高效。</li>
</ol>
<blockquote>
<p>通常Linux运维工作，都是面临大量带有字符串的内容，如：<br>配置文件<br>程序代码<br>命令输出结果<br>日志文件<br>且此类字符串内容，我们常会有特定的需要，查找出符合工作需要的特定的字符串，因此正则表达式就出现了</p>
</blockquote>
<blockquote>
<p>正则表达式是一套规则和方法<br>正则工作时以单位进行，一次处理一行<br>正则表达式化繁为简，提高工作效率<br>linux仅受三剑客（sed、awk、grep）支持，其他命令无法使用<br>正则表达式应用非常广泛，应用在如Python、Java、Perl等，Linux下普通命令无法使用正则表达式的，只能使用三剑客。</p>
</blockquote>
<h2 id="Linux三剑客"><a href="#Linux三剑客" class="headerlink" title="Linux三剑客"></a>Linux三剑客</h2><div class="note orange no-icon flat"><p>文本处理工具，均支持正则表达式引擎</p>
<p>grep：文本过滤工具，（模式：pattern）工具,<font color="#FF0000">擅长单纯的查找或匹配文本内容</font><br>sed：stream editor，流编辑器；文本编辑工具，<font color="#FF0000">更适合编辑、处理匹配到的文本内容</font><br>awk：Linux的文本报告生成器（格式化文本），Linux上是gawk，<font color="#FF0000">更适合格式化文本内容，对文本进行复杂处理</font></p>
</div>

<h2 id="基本正则表达式BRE集合"><a href="#基本正则表达式BRE集合" class="headerlink" title="基本正则表达式BRE集合"></a>基本正则表达式BRE集合</h2><ul>
<li>匹配字符</li>
<li>匹配次数</li>
<li>位置锚定</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>尖角号，用于模式的最左侧，如 “^li”，匹配以li单词开头的行</td>
</tr>
<tr>
<td><code>$</code></td>
<td>美元符，用于模式的最右侧，如”li$”，表示以li单词结尾的行</td>
</tr>
<tr>
<td><code>^$</code></td>
<td>组合符，表示空行</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意一个且只有一个字符，不能匹配空行</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符，让特殊含义的字符，现出原形，还原本意，例如.代表小数点</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配前一个字符（连续出现）0次或1次以上 ，重复0次代表空，即匹配所有内容</td>
</tr>
<tr>
<td><code>.*</code></td>
<td>组合符，匹配任意长度的任意字符</td>
</tr>
<tr>
<td><code>^.*</code></td>
<td>组合符，匹配任意多个字符开头的内容</td>
</tr>
<tr>
<td><code>.*$</code></td>
<td>组合符，匹配以任意多个字符结尾的内容</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配[]集合内的任意一个字符，a或b或c，可以写[a-c]</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>匹配除了^后面的任意字符，a或b或c，^表示对[abc]的取反</td>
</tr>
<tr>
<td><code>&lt;pattern&gt;</code></td>
<td>匹配完整的内容</td>
</tr>
<tr>
<td><code>&lt;或&gt;</code></td>
<td>定位单词的左侧，和右侧，如<b>可以找出”a b c”，找不出”d”</b></td>
</tr>
</tbody></table>
<blockquote>
<p>扩展正则表达式ERE集合<br>扩展正则必须用 grep -E 才能生效</p>
</blockquote>
<hr>
<table>
<thead>
<tr>
<th>字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>匹配前一个字符1次或多次，前面字符至少出现1次</td>
</tr>
<tr>
<td><code>[:/]+</code></td>
<td>匹配括号内的”:”或者”/“字符1次或多次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前一个字符0次或1次，前面字符可有可无</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>()</code></td>
<td>分组过滤，被括起来的内容表示一个整体</td>
</tr>
<tr>
<td><code>a&#123;n,m&#125;</code></td>
<td>匹配前一个字符最少n次，最多m次</td>
</tr>
<tr>
<td><code>a&#123;n,&#125;</code></td>
<td>匹配前一个字符最少n次</td>
</tr>
<tr>
<td><code>a&#123;n&#125;</code></td>
<td>匹配前一个字符正好n次</td>
</tr>
<tr>
<td><code>a&#123;,m&#125;</code></td>
<td>匹配前一个字符最多m次</td>
</tr>
</tbody></table>
<hr>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><strong>全拼</strong>：Global search REgular expression and Print out the line.<br><strong>作用</strong>：文本搜索工具，根据用户指定的“模式（过滤条件）”对目标文本逐行进行匹配检查，打印匹配到的行<br><strong>模式</strong>：由正则表达式的<code>元字符</code>及<code>文本字符</code>所编写出的<code>过滤条件</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">grep [options] [pattern]  file </span><br><span class="line">命令  参数   匹配模式   文件数据</span><br><span class="line"></span><br><span class="line"> -A&lt;显示行数&gt;：除了显示符合范本样式的那一列之外，并显示该行之后的内容。</span><br><span class="line"> -B&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前的内容。</span><br><span class="line"> -C&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前后的内容。</span><br><span class="line"> -c：统计匹配的行数</span><br><span class="line"> -e ：实现多个选项间的逻辑or 关系</span><br><span class="line"> -E：扩展的正则表达式</span><br><span class="line"> -f FILE：从FILE获取PATTERN匹配</span><br><span class="line"> -F ：相当于fgrep</span><br><span class="line"> -i --ignore-case <span class="comment">#忽略字符大小写的差别。</span></span><br><span class="line"> -n：显示匹配的行号</span><br><span class="line"> -o：仅显示匹配到的字符串</span><br><span class="line"> -q： 静默模式，不输出任何信息</span><br><span class="line"> -s：不显示错误信息。</span><br><span class="line"> -v：显示不被pattern 匹配到的行，相当于[^] 反向匹配</span><br><span class="line"> -w ：匹配 整个单词</span><br></pre></td></tr></table></figure>
<hr>
<table>
<thead>
<tr>
<th>参数选项</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>排除匹配结果,相当于[^] 反向匹配</td>
</tr>
<tr>
<td>-n</td>
<td>显示匹配行与行号</td>
</tr>
<tr>
<td>-i</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>-c</td>
<td>只统计匹配的行数</td>
</tr>
<tr>
<td>-E</td>
<td>使用egrep命令</td>
</tr>
<tr>
<td>–color=auto</td>
<td>为grep过滤结果添加颜色</td>
</tr>
<tr>
<td>-w</td>
<td>只匹配过滤的单词</td>
</tr>
<tr>
<td>-o</td>
<td>只输出匹配的内容</td>
</tr>
</tbody></table>
<h2 id="正则表达式grep实践"><a href="#正则表达式grep实践" class="headerlink" title="正则表达式grep实践"></a>正则表达式grep实践</h2><p>准备测试文件</p>
<p><img src="https://z3.ax1x.com/2021/04/22/cLWS5q.png" alt="测试文件"></p>
<h3 id="符号"><a href="#符号" class="headerlink" title="^符号"></a><code>^</code>符号</h3><ul>
<li><strong>输出所有以i开头的行</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -i  -n &quot;^i&quot; lxz        # -i忽略大小写  -n 显示仪行号</span><br><span class="line">1:I study linux.</span><br><span class="line">2:I want be better</span><br><span class="line">9:In order to learn Linux better</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出所有以t开头的行</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -i  -n &quot;^t&quot; lxz</span><br><span class="line">8:This is a test file</span><br></pre></td></tr></table></figure>
<h3 id="符"><a href="#符" class="headerlink" title="$符"></a><code>$</code>符</h3><ul>
<li><strong>输出所有以r结尾的行</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -i -n &quot;r$&quot; lxz</span><br><span class="line">2:I want be better</span><br><span class="line">9:In order to learn Linux better</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出所以以m结尾的行</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -i -n &quot;m$&quot; lxz</span><br><span class="line">4:My website is https:&#x2F;&#x2F;lxz9.com</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出所有以”.”结尾的行，注意用转义符</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.注意不加转义符的结果，正则里&quot;.&quot;是匹配任意1个字符，grep把.当做正则处理了，因此把有数据的行找出来了，</span><br><span class="line">$ grep -i -n &quot;.$&quot; lxz</span><br><span class="line">1:I study linux.</span><br><span class="line">2:I want be better</span><br><span class="line">4:My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">6:My name is li</span><br><span class="line">8:This is a test file</span><br><span class="line">9:In order to learn Linux better</span><br><span class="line"></span><br><span class="line">2.加上转义符，当做普通的小数点过滤</span><br><span class="line">$ grep -i -n &quot;\.$&quot; lxz </span><br><span class="line">1:I study linux.</span><br></pre></td></tr></table></figure>
<h3 id="组合符"><a href="#组合符" class="headerlink" title="^$组合符"></a><code>^$</code>组合符</h3><ul>
<li>找出文件的空行，以及行号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep &quot;^$&quot; -n lxz </span><br><span class="line">3:</span><br><span class="line">5:</span><br><span class="line">7:</span><br><span class="line">10:</span><br><span class="line">11:</span><br><span class="line">12:</span><br></pre></td></tr></table></figure>
<h3 id="点符号"><a href="#点符号" class="headerlink" title=".点符号"></a><code>.</code>点符号</h3><p><code>.</code>点表示任意一个字符，有且只有一个，不包含空行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -i -n &quot;.&quot; lxz</span><br><span class="line">1:I study linux.</span><br><span class="line">2:I want be better</span><br><span class="line">4:My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">6:My name is li</span><br><span class="line">8:This is a test file</span><br><span class="line">9:In order to learn Linux better</span><br></pre></td></tr></table></figure>
<p>匹配出 <code>.li</code>，找出任意一个三位字符，包含li</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -i -n &quot;.li&quot; lxz</span><br><span class="line">1:I study linux.</span><br><span class="line">6:My name is li</span><br><span class="line">9:In order to learn Linux better</span><br></pre></td></tr></table></figure>
<h3 id="转义符"><a href="#转义符" class="headerlink" title="\转义符"></a><code>\</code>转义符</h3><p>找出文中所有的点”.”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep &quot;\.&quot; lxz</span><br><span class="line">I study linux.</span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br></pre></td></tr></table></figure>
<h3 id="符号-1"><a href="#符号-1" class="headerlink" title="*符号"></a><code>*</code>符号</h3><p>找出前一个字符0次或多次，找出文中出现”i”的0次或多次</p>
<p><img src="https://z3.ax1x.com/2021/04/22/cLRzan.png" alt="cLRzan.png"></p>
<h3 id="组合符-1"><a href="#组合符-1" class="headerlink" title="组合符"></a>组合符</h3><ul>
<li><strong><code>.*</code>符号</strong></li>
</ul>
<p><code>.</code>表示任意一个字符，<code>*</code>表示匹配前一个字符0次或多次，因此放一起，代表匹配所有内容，以及空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;.*&#39; lxz</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>^.*o</code>符</strong></li>
</ul>
<p><code>^</code>以某字符为开头<br><code>.</code>任意0或多个字符<br><code>.*</code>代表匹配所有内容<br><code>o</code>普通字符，一直到字母o结束<br>这种匹配相同字符到最后一个字符的特点，称为贪婪匹配</p>
<h3 id="abc-中括号"><a href="#abc-中括号" class="headerlink" title="[abc]中括号"></a><code>[abc]</code>中括号</h3><div class="note orange no-icon flat"><p>中括号表达式，[abc]表示匹配中括号中任意一个字符，a或b或c，常见形式如下<br>[a-z]匹配所有小写单个字母<br>[A-Z]匹配所有单个大写字母<br>[a-zA-Z]匹配所有的单个大小写字母<br>[0-9]匹配所有单个数字<br>[a-zA-Z0-9]匹配所有数字和字母</p>
</div>

<h3 id="abc-中括号中取反"><a href="#abc-中括号中取反" class="headerlink" title="[^abc]中括号中取反"></a><code>[^abc]</code>中括号中取反</h3><div class="note blue no-icon flat"><p><code>[^abc]</code>或<code>[^a-c]</code>这样的命令，<code>^</code>符号在中括号中第一位表示排除，就是排除字母a或b或c</p>
</div>

<h2 id="grep参数-o"><a href="#grep参数-o" class="headerlink" title="grep参数 -o"></a>grep参数 <code>-o</code></h2><blockquote>
<p>使用”-o”选项，可以只显示被匹配到的关键字，而不是讲整行的内容都输出。<br>显示文件中有多少个字符a</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -o  &#39;a&#39; lxz | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="扩展正则表达式实践"><a href="#扩展正则表达式实践" class="headerlink" title="扩展正则表达式实践"></a>扩展正则表达式实践</h2><p>使用<code>grep -E</code>进行实践扩展正则</p>
<h3 id="号"><a href="#号" class="headerlink" title="+号"></a><code>+</code>号</h3><p>+号表示匹配前一个字符1次或多次，必须使用grep -E 扩展正则<br><code>grep -E  &#39;l+&#39;  lxz   #匹配lxz文件中l字符一次或多次</code></p>
<h3 id="符-1"><a href="#符-1" class="headerlink" title="?符"></a><code>?</code>符</h3><p>匹配前一个字符0次或1次</p>
<ol>
<li>找出文件中包含ab或aob的行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E &#39;ao?b&#39; luffycity.txt</span><br><span class="line">aob            #字母o出现了一次</span><br><span class="line">ab          #字母o出现了0次</span><br></pre></td></tr></table></figure>
<h3 id="符-2"><a href="#符-2" class="headerlink" title="|符"></a><code>|</code>符</h3><p>竖线在正则中是<code>或者</code>的意思</p>
<ol start="2">
<li>找出系统中的txt文件，且名字里包含a或b的字符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home&#x2F;lixingze -maxdepth 3  -name &quot;*.txt&quot; |grep -i -E &quot;a|b&quot;</span><br><span class="line">&#x2F;home&#x2F;lixingze&#x2F;.conda&#x2F;environments.txt</span><br><span class="line">&#x2F;home&#x2F;lixingze&#x2F;Database&#x2F;data&#x2F;go_tmp.txt</span><br><span class="line">&#x2F;home&#x2F;lixingze&#x2F;Database&#x2F;data&#x2F;go_rich.significant.txt</span><br><span class="line">&#x2F;home&#x2F;lixingze&#x2F;Database&#x2F;go_R&#x2F;go_tmp.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="小括号"><a href="#小括号" class="headerlink" title="()小括号"></a><code>()</code>小括号</h3><p><strong>将一个或多个字符捆绑在一起，当作一个整体进行处理；</strong></p>
<p>小括号功能之一是<code>分组过滤被括起来的内容</code>，<code>括号内的内容表示一个整体</code><br>括号()内的内容可以<code>后面的&quot;\n&quot;正则引用</code>，<code>n为数字</code>，表示<code>引用第几个括号的内容</code></p>
<ul>
<li><code>\1</code>：表示从左侧起，第一个括号中的模式所匹配到的字符</li>
<li><code>\2</code>：从左侧期，第二个括号中的模式所匹配到的字符</li>
</ul>
<h2 id="分组解释"><a href="#分组解释" class="headerlink" title="分组解释"></a>分组解释</h2><p>分组案例:<br><strong>找出，用户名，shell名相同的行</strong></p>
<p><img src="https://z3.ax1x.com/2021/04/22/cLWixU.png" alt="grep3"></p>
<hr>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><div class="note pink no-icon flat"><p>sed是Stream Editor（字符流编辑器）的缩写，简称流编辑器。<br>sed是操作、过滤和转换文本内容的强大工具。</p>
<p>常用功能包括结合正则表达式对文件实现快速增删改查，其中查询的功能中最常用的两大功能是过滤（过滤指定字符串）、取行（取出指定行）。</p>
</div>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [选项] [sed内置命令字符] [输入文件]</span><br><span class="line"></span><br><span class="line"> -n：不输出模式空间内容到屏幕，即不自动打印，只打印匹配到的行</span><br><span class="line"> -e：多点编辑，对每行处理时，可以有多个Script</span><br><span class="line"> -f：把Script写到文件当中，在执行sed时-f 指定文件路径，如果是多个Script，换行写</span><br><span class="line"> -r：支持扩展的正则表达式</span><br><span class="line"> -i：直接将处理的结果写入文件</span><br><span class="line"> -i.bak：在将处理的结果写入文件之前备份一份</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><table>
<thead>
<tr>
<th>参数选项</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>取消默认sed的输出，常与sed内置命令p一起用</td>
</tr>
<tr>
<td>-i</td>
<td>直接将修改结果写入文件，不用-i，sed修改的是内存数据</td>
</tr>
<tr>
<td>-e</td>
<td>多次编辑,不需要管道符了</td>
</tr>
<tr>
<td>-r</td>
<td>支持正则扩展</td>
</tr>
</tbody></table>
<p><strong><font color="#0000FF">sed的内置命令字符用于对文件进行不同的操作功能，如对文件增删改查</font></strong></p>
<h2 id="sed常用内置命令字符"><a href="#sed常用内置命令字符" class="headerlink" title="sed常用内置命令字符"></a>sed常用内置命令字符</h2><table>
<thead>
<tr>
<th>sed的内置命令字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>append，对文本追加，在指定行后面添加一行/多行文本</td>
</tr>
<tr>
<td>d</td>
<td>Delete，删除匹配行</td>
</tr>
<tr>
<td>i</td>
<td>insert，表示插入文本，在指定行前添加一行/多行文本</td>
</tr>
<tr>
<td>p</td>
<td>Print ，打印匹配行的内容，通常p与-n一起用</td>
</tr>
<tr>
<td>s/正则/替换内容/g</td>
<td>匹配正则内容，然后替换内容（支持正则），结尾g代表全局匹配</td>
</tr>
</tbody></table>
<h2 id="sed匹配范围"><a href="#sed匹配范围" class="headerlink" title="sed匹配范围"></a>sed匹配范围</h2><table>
<thead>
<tr>
<th>范围</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>空地址</td>
<td>全文处理</td>
</tr>
<tr>
<td>单地址</td>
<td>指定文件某一行</td>
</tr>
<tr>
<td>/pattern/</td>
<td>被模式匹配到的每一行</td>
</tr>
<tr>
<td>范围区间</td>
<td>10,20 十到二十行，10,+5第10行向下5行，/pattern1/,/pattern2/</td>
</tr>
<tr>
<td>步长</td>
<td><code>1~2</code>，表示1、3、5、7、9行，<code>2~2</code>两个步长，表示2、4、6、8、10、偶数行</td>
</tr>
</tbody></table>
<h2 id="sed案例"><a href="#sed案例" class="headerlink" title="sed案例"></a>sed案例</h2><p><strong><font color="#0000FF">准备测试数据</font></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat lxz</span><br><span class="line">I study linux.</span><br><span class="line">I want be better</span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">My name is li</span><br><span class="line">This is a test file</span><br><span class="line">In order to learn Linux better</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>输出文件第2，3行的内容</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &#39;2,3p&#39; lxz</span><br><span class="line">I want be better</span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>过滤出含有lxz9.com的字符串行</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &#39;&#x2F;lxz9.com&#x2F;p&#39; lxz </span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除含有linux的行</strong></li>
</ul>
<blockquote>
<p>注：sed想要修改文件内容，使用-i参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;&#x2F;linux&#x2F;d&#39; lxz</span><br><span class="line">I want be better</span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">My name is li</span><br><span class="line">This is a test file</span><br><span class="line">In order to learn Linux better</span><br><span class="line"></span><br><span class="line">#含有linux的第一行被删除掉了</span><br></pre></td></tr></table></figure>
<p>修改结果写入到文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed  -i &#39;&#x2F;linux&#x2F;d&#39; lxz #不会输出结果，直接写入文件</span><br></pre></td></tr></table></figure>
<p>删掉2，3两行<br><code>sed &#39;2,3d&#39; lxz</code></p>
<p>删除第5行到结尾<br><code>sed &#39;5,$d&#39; lxz</code></p>
<ul>
<li><strong>将文件中的My全部替换为Her</strong></li>
</ul>
<blockquote>
<p>s内置符配合g，代表全局替换，中间的”/“可以替换为”#@/“等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;s&#x2F;My&#x2F;Her&#x2F;g&#39; lxz</span><br><span class="line">I want be better</span><br><span class="line">Her website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">Her name is li</span><br><span class="line">This is a test file</span><br><span class="line">In order to learn Linux better</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>替换所有My为Her，同时换掉lxz9为baidu</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -e &#39;s&#x2F;My&#x2F;Her&#x2F;g&#39; -e &#39;s&#x2F;lxz9&#x2F;baidu&#x2F;g&#39; lxz</span><br><span class="line">I want be better</span><br><span class="line">Her website is https:&#x2F;&#x2F;baidu.com</span><br><span class="line">Her name is li</span><br><span class="line">This is a test file</span><br><span class="line">In order to learn Linux better</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在文件第二行追加内容 a字符功能，写入到文件，还得添加 -i</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -i &#39;2a I am useing sed command&#39; lxz</span><br><span class="line"></span><br><span class="line">$ cat lxz   #在第二行下面添加了内容</span><br><span class="line">I want be better</span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">I am useing sed command</span><br><span class="line">My name is li</span><br><span class="line">This is a test file</span><br><span class="line">In order to learn Linux better</span><br></pre></td></tr></table></figure>
<p>添加多行信息，用换行符<code>\n</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -i &quot;2a abc.\nbcd.&quot; lxz</span><br><span class="line"></span><br><span class="line">$ cat -n lxz</span><br><span class="line">     1	I want be better</span><br><span class="line">     2	My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">     3	abc.</span><br><span class="line">     4	bcd.</span><br><span class="line">     5	I am useing sed command</span><br><span class="line">     6	My name is li</span><br><span class="line">     7	This is a test file</span><br><span class="line">     8	In order to learn Linux better</span><br></pre></td></tr></table></figure>
<p>在每一行下面插入新内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &quot;a ---&quot; lxz</span><br><span class="line">I want be better</span><br><span class="line">---</span><br><span class="line">My website is https:&#x2F;&#x2F;lxz9.com</span><br><span class="line">---</span><br><span class="line">abc.</span><br><span class="line">---</span><br><span class="line">bcd.</span><br><span class="line">---</span><br><span class="line">I am useing sed command</span><br><span class="line">---</span><br><span class="line">My name is li</span><br><span class="line">---</span><br><span class="line">This is a test file</span><br><span class="line">---</span><br><span class="line">In order to learn Linux better</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在第二行上面插入内容</strong></li>
</ul>
<p><code>sed &#39;2i I am useing sed command&#39; lxz</code></p>
<h2 id="sed配合正则表达式案例"><a href="#sed配合正则表达式案例" class="headerlink" title="sed配合正则表达式案例"></a>sed配合正则表达式案例</h2><h3 id="取出linux的IP地址"><a href="#取出linux的IP地址" class="headerlink" title="取出linux的IP地址"></a>取出linux的IP地址</h3><ul>
<li><strong>删除网卡信息</strong></li>
</ul>
<p><img src="https://z3.ax1x.com/2021/04/22/cLWkMF.png" alt="sed1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先取出第二行</span><br><span class="line"># ifconfig | sed -n &#39;2p&#39;</span><br><span class="line">        inet 10.141.32.137  netmask 255.255.192.0  broadcast 10.141.63.255</span><br><span class="line"></span><br><span class="line">2.找到第二行后，去掉ip之前的内容 </span><br><span class="line"># ifconfig eth0|sed -n &#39;2s#^.*inet##gp&#39;</span><br><span class="line"> 10.141.32.137  netmask 255.255.192.0  broadcast 10.141.63.255</span><br><span class="line"> 解释： </span><br><span class="line"> -n是取消默认输出  </span><br><span class="line"> 2s是处理第二行内容</span><br><span class="line"> #^.*inet##  是匹配inet前所有的内容</span><br><span class="line"> gp代表全局替换且打印替换结果</span><br><span class="line"></span><br><span class="line">3.再次处理，去掉ip后面的内容</span><br><span class="line"># sed -n &#39;2s&#x2F;^.*inet&#x2F;&#x2F;gp&#39; ip.txt | sed -n &#39;s&#x2F;net.*$&#x2F;&#x2F;gp&#39;</span><br><span class="line"> 10.141.32.137</span><br><span class="line"></span><br><span class="line"> 解释：</span><br><span class="line"> net.*$  匹配net到结尾的内容</span><br><span class="line"> s&#x2F;net.*$&#x2F;&#x2F;gp   #把匹配到的内容替换为空</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-e参数多次编辑</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ifconfig eth0  | sed -ne &#39;2s&#x2F;^.*inet&#x2F;&#x2F;g&#39;  -e &#39;2s&#x2F;net.*$&#x2F;&#x2F;gp&#39;</span><br><span class="line"> 10.141.32.137</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><div class="note purple no-icon flat"><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p>
<p>awk是一个强大的linux命令，有强大的文本格式化的能力，好比将一些文本数据格式化成专业的excel表的样式</p>
</div>


<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [option] <span class="string">&#x27;pattern[action]&#x27;</span>  file ...</span><br><span class="line"><span class="comment"># awk 参数   &#x27;条件动作&#x27;  文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">awk [选项参数] <span class="string">&#x27;script&#x27;</span> var=value file(s)</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="awk使用"><a href="#awk使用" class="headerlink" title="awk使用"></a>awk使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#示例文件内容如下</span><br><span class="line">cat awk_test</span><br><span class="line">lxz1  lxz11  lxz21  lxz31  lxz41</span><br><span class="line">lxz2  lxz12  lxz22  lxz32  lxz42</span><br><span class="line">lxz3  lxz13  lxz23  lxz33  lxz43</span><br><span class="line">lxz4  lxz14  lxz24  lxz34  lxz44</span><br><span class="line">lxz5  lxz15  lxz25  lxz35  lxz45</span><br><span class="line">lxz6  lxz16  lxz26  lxz36  lxz46</span><br><span class="line">lxz7  lxz17  lxz27  lxz37  lxz47</span><br><span class="line">lxz8  lxz18  lxz28  lxz38  lxz48</span><br><span class="line">lxz9  lxz19  lxz29  lxz39  lxz49</span><br><span class="line">lxz10  lxz20  lxz30  lxz40  lxz50</span><br><span class="line"></span><br><span class="line">cat awk_test | awk &#39;&#123;print $5&#125;&#39;</span><br><span class="line">lxz41</span><br><span class="line">lxz42</span><br><span class="line">lxz43</span><br><span class="line">lxz44</span><br><span class="line">lxz45</span><br><span class="line">lxz46</span><br><span class="line">lxz47</span><br><span class="line">lxz48</span><br><span class="line">lxz49</span><br><span class="line">lxz50</span><br></pre></td></tr></table></figure>
<p>执行的命令是<code>awk &#39;&#123;print $5&#125;&#39;</code>，没有使用参数和模式，<code>$5</code>表示输出文本的<code>第五列</code>信息<br>awk默认以空格为分隔符，且多个空格也识别为一个空格，作为分隔符<br>awk是按行处理文件，一行处理完毕，处理下一行，根据用户指定的分割符去工作，没有指定则默认空格</p>
<p><code>$0表示整行 $NF表示当前分割后的最后一列 倒数第二列可以写成$(NF-1)</code></p>
<h2 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h2><table>
<thead>
<tr>
<th>内置变量</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>指定分隔符后，当前记录的第n个字段</td>
</tr>
<tr>
<td>$0</td>
<td>完整的输入记录</td>
</tr>
<tr>
<td>FS</td>
<td>字段分隔符，默认是空格</td>
</tr>
<tr>
<td>NF(Number of fields)</td>
<td>分割后，当前行一共有多少个字段</td>
</tr>
<tr>
<td>NR(Number of records)</td>
<td>当前记录数，行数</td>
</tr>
<tr>
<td>更多内置变量可以man手册查看</td>
<td>man awk</td>
</tr>
</tbody></table>
<h2 id="一次性输出多列"><a href="#一次性输出多列" class="headerlink" title="一次性输出多列"></a>一次性输出多列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1,$2&#125;&#39; awk_test</span><br><span class="line">lxz1 lxz11</span><br><span class="line">lxz2 lxz12</span><br><span class="line">lxz3 lxz13</span><br><span class="line">lxz4 lxz14</span><br><span class="line">lxz5 lxz15</span><br><span class="line">lxz6 lxz16</span><br><span class="line">lxz7 lxz17</span><br><span class="line">lxz8 lxz18</span><br><span class="line">lxz9 lxz19</span><br><span class="line">lxz10 lxz20</span><br></pre></td></tr></table></figure>
<h2 id="自动定义输出内容"><a href="#自动定义输出内容" class="headerlink" title="自动定义输出内容"></a>自动定义输出内容</h2><p>awk，必须外层单引号，内层双引号<br>内置变量<code>$1、$2</code>都不得添加双引号，否则会识别为文本，尽量别加引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;print &quot;第一列&quot;,$1,&quot;第二列&quot;,$2,&quot;第五列&quot;,$5&#125;&#39; awk_test </span><br><span class="line">第一列 lxz1 第二列 lxz11 第五列 lxz41</span><br><span class="line">第一列 lxz2 第二列 lxz12 第五列 lxz42</span><br><span class="line">第一列 lxz3 第二列 lxz13 第五列 lxz43</span><br><span class="line">第一列 lxz4 第二列 lxz14 第五列 lxz44</span><br><span class="line">第一列 lxz5 第二列 lxz15 第五列 lxz45</span><br><span class="line">第一列 lxz6 第二列 lxz16 第五列 lxz46</span><br><span class="line">第一列 lxz7 第二列 lxz17 第五列 lxz47</span><br><span class="line">第一列 lxz8 第二列 lxz18 第五列 lxz48</span><br><span class="line">第一列 lxz9 第二列 lxz19 第五列 lxz49</span><br><span class="line">第一列 lxz10 第二列 lxz20 第五列 lxz50</span><br></pre></td></tr></table></figure>
<h2 id="输出整行信息"><a href="#输出整行信息" class="headerlink" title="输出整行信息"></a>输出整行信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;print&#125;&#39; awk_test</span><br><span class="line">awk &#39;&#123;print $0&#125;&#39; awk_test</span><br></pre></td></tr></table></figure>
<h2 id="awk选项参数说明"><a href="#awk选项参数说明" class="headerlink" title="awk选项参数说明"></a>awk选项参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定分割字段符</td>
</tr>
<tr>
<td>-v</td>
<td>定义或修改一个awk内部的变量</td>
</tr>
<tr>
<td>-f</td>
<td>从脚本文件中读取awk命令</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-F fs or --field-separator fs</span><br><span class="line">指定分割字段符，fs是一个字符串或者是一个正则表达式，如-F:。</span><br><span class="line"></span><br><span class="line">-v var=value or --asign var=value</span><br><span class="line">定义或修改一个awk内部的变量</span><br><span class="line"></span><br><span class="line">-f scripfile or --file scriptfile</span><br><span class="line">从脚本文件中读取awk命令。</span><br><span class="line"></span><br><span class="line">-mf nnn and -mr nnn</span><br><span class="line">对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</span><br><span class="line"></span><br><span class="line">-W compact or --compat, -W traditional or --traditional</span><br><span class="line">在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</span><br><span class="line"></span><br><span class="line">-W copyleft or --copyleft, -W copyright or --copyright</span><br><span class="line">打印简短的版权信息。</span><br><span class="line"></span><br><span class="line">-W <span class="built_in">help</span> or --<span class="built_in">help</span>, -W usage or --usage</span><br><span class="line">打印全部awk选项和每个选项的简短说明。</span><br><span class="line"></span><br><span class="line">-W lint or --lint</span><br><span class="line">打印不能向传统unix平台移植的结构的警告。</span><br><span class="line"></span><br><span class="line">-W lint-old or --lint-old</span><br><span class="line">打印关于不能向传统unix平台移植的结构的警告。</span><br><span class="line"></span><br><span class="line">-W posix</span><br><span class="line">打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。</span><br><span class="line"></span><br><span class="line">-W re-interval or --re-inerval</span><br><span class="line">允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</span><br><span class="line"></span><br><span class="line">-W <span class="built_in">source</span> program-text or --<span class="built_in">source</span> program-text</span><br><span class="line">使用program-text作为源代码，可与-f命令混用。</span><br><span class="line"></span><br><span class="line">-W version or --version</span><br><span class="line">打印bug报告信息的版本。</span><br></pre></td></tr></table></figure>
<h3 id="显示文件第三行"><a href="#显示文件第三行" class="headerlink" title="显示文件第三行"></a>显示文件第三行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#NR在awk中表示行号，NR&#x3D;&#x3D;3表示行号是3的那一行</span><br><span class="line">#注意一个等于号，是修改变量值的意思，两个等于号是关系运算符，是&quot;等于&quot;的意思</span><br><span class="line"></span><br><span class="line">$ awk &#39;NR&#x3D;&#x3D;3&#39; awk_test </span><br><span class="line">lxz3  lxz13  lxz23  lxz33  lxz43</span><br></pre></td></tr></table></figure>
<h3 id="显示文件2-5行"><a href="#显示文件2-5行" class="headerlink" title="显示文件2-5行"></a>显示文件2-5行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;NR&#x3D;&#x3D;2,NR&#x3D;&#x3D;5&#39; awk_test </span><br><span class="line">lxz2  lxz12  lxz22  lxz32  lxz42</span><br><span class="line">lxz3  lxz13  lxz23  lxz33  lxz43</span><br><span class="line">lxz4  lxz14  lxz24  lxz34  lxz44</span><br><span class="line">lxz5  lxz15  lxz25  lxz35  lxz45</span><br></pre></td></tr></table></figure>
<h3 id="给每一行的内容添加行号"><a href="#给每一行的内容添加行号" class="headerlink" title="给每一行的内容添加行号"></a>给每一行的内容添加行号</h3><p><strong>添加变量，NR等于行号，$0表示一整行的内容</strong></p>
<p>{print }是awk的动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk  &#39;&#123;print NR,$0&#125;&#39; awk_test </span><br><span class="line">1 lxz1  lxz11  lxz21  lxz31  lxz41</span><br><span class="line">2 lxz2  lxz12  lxz22  lxz32  lxz42</span><br><span class="line">3 lxz3  lxz13  lxz23  lxz33  lxz43</span><br><span class="line">4 lxz4  lxz14  lxz24  lxz34  lxz44</span><br><span class="line">5 lxz5  lxz15  lxz25  lxz35  lxz45</span><br><span class="line">6 lxz6  lxz16  lxz26  lxz36  lxz46</span><br><span class="line">7 lxz7  lxz17  lxz27  lxz37  lxz47</span><br><span class="line">8 lxz8  lxz18  lxz28  lxz38  lxz48</span><br><span class="line">9 lxz9  lxz19  lxz29  lxz39  lxz49</span><br><span class="line">10 lxz10  lxz20  lxz30  lxz40  lxz50</span><br></pre></td></tr></table></figure>
<h3 id="显示文件3-5行且输出行号"><a href="#显示文件3-5行且输出行号" class="headerlink" title="显示文件3-5行且输出行号"></a>显示文件3-5行且输出行号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;NR&#x3D;&#x3D;3,NR&#x3D;&#x3D;5  &#123;print NR,$0&#125;&#39; awk_test </span><br><span class="line">3 lxz3  lxz13  lxz23  lxz33  lxz43</span><br><span class="line">4 lxz4  lxz14  lxz24  lxz34  lxz44</span><br><span class="line">5 lxz5  lxz15  lxz25  lxz35  lxz45</span><br></pre></td></tr></table></figure>
<h3 id="显示文件的第一列，倒数第二和最后一列"><a href="#显示文件的第一列，倒数第二和最后一列" class="headerlink" title="显示文件的第一列，倒数第二和最后一列"></a>显示文件的第一列，倒数第二和最后一列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F &#39; &#39; &#39;&#123;print $1,$(NF-1),$NF&#125;&#39; pwd.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/04/22/cLWtII.png" alt="awk1"></p>
<h2 id="awk分隔符"><a href="#awk分隔符" class="headerlink" title="awk分隔符"></a>awk分隔符</h2><div class="note orange no-icon flat"><p>awk的分隔符有两种</p>
<ol>
<li>输入分隔符，awk默认是空格，空白字符，英文是field separator，变量名是FS</li>
<li>输出分隔符，output field separator，简称OFS</li>
</ol>
</div>

<h3 id="FS输入分隔符"><a href="#FS输入分隔符" class="headerlink" title="FS输入分隔符"></a>FS输入分隔符</h3><p>awk逐行处理文本的时候，以输入分割符为准，把文本切成多个片段，默认符号是空格<br>当我们处理特殊文件，没有空格的时候，可以自由指定分隔符特点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备示例文件，把之前的空格全部替换为任意符号，这里使用逗号</span></span><br><span class="line"><span class="comment"># sed -i &#x27;s/ /,/g&#x27; awk_test </span></span><br><span class="line">$ cat awk_test </span><br><span class="line">lxz1,lxz11,lxz21,lxz31,lxz41</span><br><span class="line">lxz2,lxz12,lxz22,lxz32,lxz42</span><br><span class="line">lxz3,lxz13,lxz23,lxz33,lxz43</span><br><span class="line">lxz4,lxz14,lxz24,lxz34,lxz44</span><br><span class="line">lxz5,lxz15,lxz25,lxz35,lxz45</span><br><span class="line">lxz6,lxz16,lxz26,lxz36,lxz46</span><br><span class="line">lxz7,lxz17,lxz27,lxz37,lxz47</span><br><span class="line">lxz8,lxz18,lxz28,lxz38,lxz48</span><br><span class="line">lxz9,lxz19,lxz29,lxz39,lxz49</span><br><span class="line">lxz10,lxz20,lxz30,lxz40,lxz50</span><br><span class="line"></span><br><span class="line">$ awk -F <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> awk_test</span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了使用-F选项，还可以使用变量的形式，指定分隔符，使用-v选项搭配，修改FS变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -v FS&#x3D;&#39;,&#39; &#39;&#123;print $1&#125;&#39; awk_test</span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br></pre></td></tr></table></figure>
<h3 id="OFS输出分割符"><a href="#OFS输出分割符" class="headerlink" title="OFS输出分割符"></a>OFS输出分割符</h3><blockquote>
<p>awk执行完命令，默认用空格隔开每一列，这个空格就是awk的默认输出符，例如</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat awk_test </span><br><span class="line">lxz1,lxz11,lxz21,lxz31,lxz41</span><br><span class="line">lxz2,lxz12,lxz22,lxz32,lxz42</span><br><span class="line">lxz3,lxz13,lxz23,lxz33,lxz43</span><br><span class="line">lxz4,lxz14,lxz24,lxz34,lxz44</span><br><span class="line">lxz5,lxz15,lxz25,lxz35,lxz45</span><br><span class="line">lxz6,lxz16,lxz26,lxz36,lxz46</span><br><span class="line">lxz7,lxz17,lxz27,lxz37,lxz47</span><br><span class="line">lxz8,lxz18,lxz28,lxz38,lxz48</span><br><span class="line">lxz9,lxz19,lxz29,lxz39,lxz49</span><br><span class="line">lxz10,lxz20,lxz30,lxz40,lxz50</span><br><span class="line"></span><br><span class="line">$ awk -v FS&#x3D;&#39;,&#39; &#39;&#123;print $1,$3&#125;&#39; awk_test</span><br><span class="line">lxz1 lxz21</span><br><span class="line">lxz2 lxz22</span><br><span class="line">lxz3 lxz23</span><br><span class="line">lxz4 lxz24</span><br><span class="line">lxz5 lxz25</span><br><span class="line">lxz6 lxz26</span><br><span class="line">lxz7 lxz27</span><br><span class="line">lxz8 lxz28</span><br><span class="line">lxz9 lxz29</span><br><span class="line">lxz10 lxz30</span><br><span class="line"></span><br><span class="line">通过OFS设置输出分割符，修改变量必须搭配选项 -v</span><br><span class="line">$ awk -v FS&#x3D;&#39;,&#39; -v OFS&#x3D;&#39;-~-&#39; &#39;&#123;print $1,$3 &#125;&#39; awk_test</span><br><span class="line">lxz1-~-lxz21</span><br><span class="line">lxz2-~-lxz22</span><br><span class="line">lxz3-~-lxz23</span><br><span class="line">lxz4-~-lxz24</span><br><span class="line">lxz5-~-lxz25</span><br><span class="line">lxz6-~-lxz26</span><br><span class="line">lxz7-~-lxz27</span><br><span class="line">lxz8-~-lxz28</span><br><span class="line">lxz9-~-lxz29</span><br><span class="line">lxz10-~-lxz30</span><br></pre></td></tr></table></figure>
<h3 id="输出分隔符与逗号"><a href="#输出分隔符与逗号" class="headerlink" title="输出分隔符与逗号"></a>输出分隔符与逗号</h3><blockquote>
<p>awk是否存在输出分隔符，特点在于<code>&#39;&#123;print $1,$3 &#125;</code>逗号的区别</p>
</blockquote>
<ul>
<li>添加逗号，默认是空格分隔符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -v FS&#x3D;&#39;,&#39; &#39;&#123;print $1,$3&#125;&#39; awk_test</span><br><span class="line">lxz1 lxz21</span><br><span class="line">lxz2 lxz22</span><br><span class="line">lxz3 lxz23</span><br><span class="line">lxz4 lxz24</span><br><span class="line">lxz5 lxz25</span><br><span class="line">lxz6 lxz26</span><br><span class="line">lxz7 lxz27</span><br><span class="line">lxz8 lxz28</span><br><span class="line">lxz9 lxz29</span><br><span class="line">lxz10 lxz30</span><br></pre></td></tr></table></figure>
<ul>
<li>不加逗号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -v FS&#x3D;&#39;,&#39; &#39;&#123;print $1$3&#125;&#39; awk_test</span><br><span class="line">lxz1lxz21</span><br><span class="line">lxz2lxz22</span><br><span class="line">lxz3lxz23</span><br><span class="line">lxz4lxz24</span><br><span class="line">lxz5lxz25</span><br><span class="line">lxz6lxz26</span><br><span class="line">lxz7lxz27</span><br><span class="line">lxz8lxz28</span><br><span class="line">lxz9lxz29</span><br><span class="line">lxz10lxz30</span><br></pre></td></tr></table></figure>
<ul>
<li>修改分割符，改为\t(制表符，四个空格)或者任意字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -v FS&#x3D;&#39;,&#39; -v OFS&#x3D;&#39;\t&#39; &#39;&#123;print $1,$3 &#125;&#39; awk_test</span><br><span class="line">lxz1    lxz21</span><br><span class="line">lxz2    lxz22</span><br><span class="line">lxz3    lxz23</span><br><span class="line">lxz4    lxz24</span><br><span class="line">lxz5    lxz25</span><br><span class="line">lxz6    lxz26</span><br><span class="line">lxz7    lxz27</span><br><span class="line">lxz8    lxz28</span><br><span class="line">lxz9    lxz29</span><br><span class="line">lxz10   lxz30</span><br></pre></td></tr></table></figure>
<h2 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h2><div class="note purple no-icon flat"><p>对于awk而言，变量分为:<br>内置变量<br>自定义变量</p>
</div>

<hr>
<table>
<thead>
<tr>
<th>内置变量</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>FS</td>
<td>输入字段分隔符， 默认为空白字符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符， 默认为空白字符</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符(输入换行符)， 指定输入时的换行符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符（输出换行符），输出时用指定符号代替换行符</td>
</tr>
<tr>
<td>NF</td>
<td>NF：number of Field，当前行的字段的个数(即当前行被分割成了几列)，字段数量</td>
</tr>
<tr>
<td>NR</td>
<td>NR：行号，当前处理的文本行的行号。</td>
</tr>
<tr>
<td>FNR</td>
<td>FNR：各文件分别计数的行号</td>
</tr>
<tr>
<td>FILENAME</td>
<td>FILENAME：当前文件名</td>
</tr>
<tr>
<td>ARGC</td>
<td>ARGC：命令行参数的个数</td>
</tr>
<tr>
<td>ARGV</td>
<td>ARGV：数组，保存的是命令行所给定的各参数</td>
</tr>
</tbody></table>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><h4 id="NR，NF、FNR"><a href="#NR，NF、FNR" class="headerlink" title="NR，NF、FNR"></a>NR，NF、FNR</h4><div class="note purple no-icon flat"><p>awk的内置变量NR、NF是不用添加$符号的<br>而$0 $1 $2 $3 … 是需要添加$符号的</p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sed将逗号替换为空格</span><br><span class="line">$ sed -i &#39;s&#x2F;,&#x2F; &#x2F;g&#39; awk_test</span><br><span class="line"></span><br><span class="line">$ cat awk_test </span><br><span class="line">lxz1 lxz11 lxz21 lxz31 lxz41</span><br><span class="line">lxz2 lxz12 lxz22 lxz32 lxz42</span><br><span class="line">lxz3 lxz13 lxz23 lxz33 lxz43</span><br><span class="line">lxz4 lxz14 lxz24 lxz34 lxz44</span><br><span class="line">lxz5 lxz15 lxz25 lxz35 lxz45</span><br><span class="line">lxz6 lxz16 lxz26 lxz36 lxz46</span><br><span class="line">lxz7 lxz17 lxz27 lxz37 lxz47</span><br><span class="line">lxz8 lxz18 lxz28 lxz38 lxz48</span><br><span class="line">lxz9 lxz19 lxz29 lxz39 lxz49</span><br><span class="line">lxz10 lxz20 lxz30 lxz40 lxz50</span><br><span class="line"></span><br><span class="line">$ awk &#39;&#123;print NR,NF&#125;&#39; awk_test </span><br><span class="line">1 5</span><br><span class="line">2 5</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">5 5</span><br><span class="line">6 5</span><br><span class="line">7 5</span><br><span class="line">8 5</span><br><span class="line">9 5</span><br><span class="line">10 5</span><br></pre></td></tr></table></figure>
<p><strong>输出每行行号，以及指定的列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;print NR,$1,$5&#125;&#39; awk_test </span><br><span class="line">1 lxz1 lxz41</span><br><span class="line">2 lxz2 lxz42</span><br><span class="line">3 lxz3 lxz43</span><br><span class="line">4 lxz4 lxz44</span><br><span class="line">5 lxz5 lxz45</span><br><span class="line">6 lxz6 lxz46</span><br><span class="line">7 lxz7 lxz47</span><br><span class="line">8 lxz8 lxz48</span><br><span class="line">9 lxz9 lxz49</span><br><span class="line">10 lxz10 lxz50</span><br></pre></td></tr></table></figure>
<h4 id="处理多个文件显示行号"><a href="#处理多个文件显示行号" class="headerlink" title="处理多个文件显示行号"></a>处理多个文件显示行号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  普通的NR变量，会将多个文件按照顺序排序</span><br><span class="line">awk &#39;&#123;print NR,$0&#125;&#39; a.txt  b.txt</span><br><span class="line">#  使用FNR变量，可以分别对文件行数计数</span><br><span class="line">awk &#39;&#123;print FNR,$0&#125;&#39; a.txt  b.txt</span><br></pre></td></tr></table></figure>
<h3 id="内置变量ORS"><a href="#内置变量ORS" class="headerlink" title="内置变量ORS"></a>内置变量ORS</h3><div class="note purple no-icon flat"><p>ORS是输出分隔符的意思，awk默认认为，每一行结束了，就得添加回车换行符<br>ORS变量可以更改输出符</p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -v ORS&#x3D;&#39;;;;&#39; &#39;&#123;print NR,$0&#125;&#39; awk_test </span><br><span class="line">1 lxz1 lxz11 lxz21 lxz31 lxz41;;;2 lxz2 lxz12 lxz22 lxz32 lxz42;;;3 lxz3 lxz13 lxz23 lxz33 lxz43;;;4 lxz4 lxz14 lxz24 lxz34 lxz44;;;5 lxz5 lxz15 lxz25 lxz35 lxz45;;;6 lxz6 lxz16 lxz26 lxz36 lxz46;;;7 lxz7 lxz17 lxz27 lxz37 lxz47;;;8 lxz8 lxz18 lxz28 lxz38 lxz48;;;9 lxz9 lxz19 lxz29 lxz39 lxz49;;;10 lxz10 lxz20 lxz30 lxz40 lxz50;;;</span><br></pre></td></tr></table></figure>
<h3 id="内置变量FILENAME"><a href="#内置变量FILENAME" class="headerlink" title="内置变量FILENAME"></a>内置变量FILENAME</h3><p><strong>显示awk正在处理文件的名字</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;print FILENAME,FNR,$0&#125;&#39; awk_test test1 test2</span><br><span class="line">awk_test 1 lxz1 lxz11 lxz21 lxz31 lxz41</span><br><span class="line">awk_test 2 lxz2 lxz12 lxz22 lxz32 lxz42</span><br><span class="line">awk_test 3 lxz3 lxz13 lxz23 lxz33 lxz43</span><br><span class="line">awk_test 4 lxz4 lxz14 lxz24 lxz34 lxz44</span><br><span class="line">awk_test 5 lxz5 lxz15 lxz25 lxz35 lxz45</span><br><span class="line">awk_test 6 lxz6 lxz16 lxz26 lxz36 lxz46</span><br><span class="line">awk_test 7 lxz7 lxz17 lxz27 lxz37 lxz47</span><br><span class="line">awk_test 8 lxz8 lxz18 lxz28 lxz38 lxz48</span><br><span class="line">awk_test 9 lxz9 lxz19 lxz29 lxz39 lxz49</span><br><span class="line">awk_test 10 lxz10 lxz20 lxz30 lxz40 lxz50</span><br><span class="line">test1 1 文件一</span><br><span class="line">test2 1 文件二</span><br></pre></td></tr></table></figure>
<h3 id="变量ARGC、ARGV"><a href="#变量ARGC、ARGV" class="headerlink" title="变量ARGC、ARGV"></a>变量ARGC、ARGV</h3><div class="note purple no-icon flat"><p>ARGV表示的是一个数组，数组中保存的是命令行所给的参数<br>数组是一种数据类型，如同一个盒子<br>盒子有它的名字，且内部有N个小格子，标号从0开始<br>给一个盒子起名字叫做months，月份是1~12，那就如图所示:</p>
</div>


<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><blockquote>
<p>方法一: <code>-v</code> varName=value</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -v lxz9com&#x3D;&quot;我的网址lxz9.com&quot; &#39;BEGIN&#123;print lxz9com&#125;&#39; </span><br><span class="line">我的网址lxz9.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法二：在程序中直接定义</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123;abc&#x3D;&quot;字母abc&quot;;def&#x3D;&quot;字母def&quot;;print abc,def&#125;&#39;</span><br><span class="line">字母abc 字母def</span><br></pre></td></tr></table></figure>
<h2 id="awk格式化"><a href="#awk格式化" class="headerlink" title="awk格式化"></a>awk格式化</h2><h3 id="printf和print的区别"><a href="#printf和print的区别" class="headerlink" title="printf和print的区别"></a>printf和print的区别</h3><div class="note blue no-icon flat"><p>format的使用</p>
<p>要点：<br>1、其与print命令的最大不同是，printf需要指定format；<br>2、format用于指定后面的每个item的输出格式；<br>3、printf语句不会自动打印换行符；\n</p>
<p><strong>format格式的指示符都以%开头，后跟一个字符；如下：<br>%c: 显示字符的ASCII码；<br>%d, %i：十进制整数；<br>%e, %E：科学计数法显示数值；<br>%f: 显示浮点数；<br>%g, %G: 以科学计数法的格式或浮点数的格式显示数值；<br>%s: 显示字符串；<br>%u: 无符号整数；<br>%%: 显示%自身；</strong></p>
<p>printf修饰符：<br>-: 左对齐；默认右对齐,<br>+：显示数值符号；  printf “%+d”</p>
</div>

<ul>
<li><strong>printf动作默认不会添加换行符</strong></li>
<li><strong>print默认添加空格换行符</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; awk_test </span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br><span class="line"></span><br><span class="line">$ awk &#39;&#123;printf $1&#125;&#39; awk_test </span><br><span class="line">lxz1lxz2lxz3lxz4lxz5lxz6lxz7lxz8lxz9lxz10</span><br></pre></td></tr></table></figure>
<h3 id="给printf添加格式"><a href="#给printf添加格式" class="headerlink" title="给printf添加格式"></a>给printf添加格式</h3><ul>
<li><strong>格式化字符串 %s 代表字符串的意思</strong></li>
<li><strong>\n 换行符</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;printf &quot;%s\n&quot;,$1&#125;&#39; awk_test </span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br></pre></td></tr></table></figure>
<h3 id="对多个变量进行格式化"><a href="#对多个变量进行格式化" class="headerlink" title="对多个变量进行格式化"></a>对多个变量进行格式化</h3><ul>
<li><strong>使用linux命令printf时，是这样的，一个%s格式替换符，可以对多个参数进行重复格式化</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ printf  &quot;%s\n&quot;  a b c d</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>awk的格式替换符想要修改多个变量，必须传入多个</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123;printf &quot;%d\n%d\n%d\n%d\n%d\n&quot;,1,2,3,4,5&#125;&#39;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"># %D 代表是十进制数字</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note blue no-icon flat"><p>printf对输出的文本不会换行，必须添加对应的格式替换符和\n</p>
<p>使用printf动作，<code>&#39;{printf &quot;%s\n&quot;,$1}&#39;</code>，替换的格式和变量之间得有逗号,</p>
<p>使用printf动作，%s %d 等格式化替换符 必须 和被格式化的数据一一对应</p>
</div>


<h2 id="awk模式"><a href="#awk模式" class="headerlink" title="awk模式"></a>awk模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [option] &#39;pattern[action]&#39;  file </span><br></pre></td></tr></table></figure>
<p>awk是按行处理文本</p>
<ul>
<li>BEGIN模式是处理文本之前需要执行的操作</li>
<li>END模式是处理完所有行之后执行的操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123;print &quot;lxz9.com&quot;&#125;&#123;print $1&#125;&#39; awk_test </span><br><span class="line">lxz9.com</span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br><span class="line"></span><br><span class="line">$ awk &#39;END&#123;print &quot;lxz9.com&quot;&#125;&#123;print $1&#125;&#39; awk_test</span><br><span class="line">$ awk &#39;END&#123;print &quot;lxz9.com&quot;&#125;&#123;print $1&#125;&#39; awk_test </span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br><span class="line">lxz9.com</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>关系运算符</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>x&lt;y</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>x&lt;=y</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>x==y</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>x!=y</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>x&gt;=y</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>x&gt;y</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>匹配正则</td>
<td><code>x~/正则/</code></td>
</tr>
<tr>
<td><code>!~</code></td>
<td>不匹配正则</td>
<td><code>x!~/正则/</code></td>
</tr>
</tbody></table>
<h2 id="awk总结"><a href="#awk总结" class="headerlink" title="awk总结"></a>awk总结</h2><h3 id="空模式"><a href="#空模式" class="headerlink" title="空模式"></a>空模式</h3><p><strong>没有指定任何的模式（条件），因此每一行都执行了对应的动作，空模式会匹配文档的每一行，每一行都满足了（空模式）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;print $1&#125;&#39; awk_test </span><br><span class="line">lxz1</span><br><span class="line">lxz2</span><br><span class="line">lxz3</span><br><span class="line">lxz4</span><br><span class="line">lxz5</span><br><span class="line">lxz6</span><br><span class="line">lxz7</span><br><span class="line">lxz8</span><br><span class="line">lxz9</span><br><span class="line">lxz10</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符模式"><a href="#关系运算符模式" class="headerlink" title="关系运算符模式"></a>关系运算符模式</h3><p><strong>awk默认执行打印输出动作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;NR&#x3D;&#x3D;2,NR&#x3D;&#x3D;5&#39; awk_test</span><br><span class="line">lxz2 lxz12 lxz22 lxz32 lxz42</span><br><span class="line">lxz3 lxz13 lxz23 lxz33 lxz43</span><br><span class="line">lxz4 lxz14 lxz24 lxz34 lxz44</span><br><span class="line">lxz5 lxz15 lxz25 lxz35 lxz45</span><br></pre></td></tr></table></figure>
<h3 id="BEGIN-END模式（条件设置）"><a href="#BEGIN-END模式（条件设置）" class="headerlink" title="BEGIN/END模式（条件设置）"></a>BEGIN/END模式（条件设置）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123;print &quot;我在开头位置&quot;&#125;&#123;print $1,$2&#125;END&#123;print &quot;我在结尾处&quot;&#125;&#39; awk_test </span><br><span class="line">我在开头位置</span><br><span class="line">lxz1 lxz11</span><br><span class="line">lxz2 lxz12</span><br><span class="line">lxz3 lxz13</span><br><span class="line">lxz4 lxz14</span><br><span class="line">lxz5 lxz15</span><br><span class="line">lxz6 lxz16</span><br><span class="line">lxz7 lxz17</span><br><span class="line">lxz8 lxz18</span><br><span class="line">lxz9 lxz19</span><br><span class="line">lxz10 lxz20</span><br><span class="line">我在结尾处</span><br></pre></td></tr></table></figure>
<h2 id="awk与正则表达式"><a href="#awk与正则表达式" class="headerlink" title="awk与正则表达式"></a>awk与正则表达式</h2><div class="note pink no-icon flat"><p>正则表达式主要与awk的pattern模式（条件）结合使用</p>
<p>不指定模式，awk每一行都会执行对应的动作<br>指定了模式，只有被模式匹配到的、符合条件的行才会执行动作</p>
</div>

<h3 id="找出a文件中有以export开头的行"><a href="#找出a文件中有以export开头的行" class="headerlink" title="找出a文件中有以export开头的行"></a>找出a文件中有以export开头的行</h3><ol>
<li>用grep过滤</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep &#39;^export&#39; a</span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;samtools-1.11&#x2F;bin:$PATH&quot; </span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;species-0.3.1$PATH&quot; </span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;matplotlib-3.3.2:$PATH&quot; </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>awk</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#x2F;^export&#x2F;&#123;print $0&#125;&#39;  a</span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;samtools-1.11&#x2F;bin:$PATH&quot; </span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;species-0.3.1$PATH&quot; </span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;matplotlib-3.3.2:$PATH&quot; </span><br><span class="line"></span><br><span class="line">#省略写法</span><br><span class="line">$ awk &#39;&#x2F;^export&#x2F;&#39;  a</span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;samtools-1.11&#x2F;bin:$PATH&quot; </span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;species-0.3.1$PATH&quot; </span><br><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;lixingze&#x2F;software&#x2F;matplotlib-3.3.2:$PATH&quot; </span><br></pre></td></tr></table></figure>
<h3 id="awk使用正则语法"><a href="#awk使用正则语法" class="headerlink" title="awk使用正则语法"></a>awk使用正则语法</h3><div class="note pink no-icon flat"><p>grep ‘正则表达式’ a.txt<br>awk ‘/正则表达式/动作’ a.txt<br>(下面内容以/etc/passwd文件为例)</p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat -n passwd </span><br><span class="line">     1	root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">     2	bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin</span><br><span class="line">     3	daemon:x:2:2:daemon:&#x2F;sbin:&#x2F;sbin&#x2F;nologin</span><br><span class="line">     4	adm:x:3:4:adm:&#x2F;var&#x2F;adm:&#x2F;sbin&#x2F;nologin</span><br><span class="line">     5	lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">     6	sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">     7	shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line">     8	halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt</span><br><span class="line">     9	mail:x:8:12:mail:&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    10	operator:x:11:0:operator:&#x2F;root:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    11	games:x:12:100:games:&#x2F;usr&#x2F;games:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    12	ftp:x:14:50:FTP User:&#x2F;var&#x2F;ftp:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    13	nobody:x:65534:65534:Kernel Overflow User:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    14	dbus:x:81:81:System message bus:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    15	systemd-coredump:x:999:997:systemd Core Dumper:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    16	systemd-resolve:x:193:193:systemd Resolver:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    17	tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:&#x2F;dev&#x2F;null:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    18	polkitd:x:998:996:User for polkitd:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    19	grafana:x:997:995:grafana user account:&#x2F;usr&#x2F;share&#x2F;grafana:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    20	unbound:x:996:993:Unbound DNS resolver:&#x2F;etc&#x2F;unbound:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    21	gluster:x:995:992:GlusterFS daemons:&#x2F;run&#x2F;gluster:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    22	geoclue:x:994:991:User for geoclue:&#x2F;var&#x2F;lib&#x2F;geoclue:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    23	rtkit:x:172:172:RealtimeKit:&#x2F;proc:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    24	pipewire:x:993:990:PipeWire System Daemon:&#x2F;var&#x2F;run&#x2F;pipewire:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    25	pulse:x:171:171:PulseAudio System Daemon:&#x2F;var&#x2F;run&#x2F;pulse:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    26	qemu:x:107:107:qemu user:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    27	apache:x:48:48:Apache:&#x2F;usr&#x2F;share&#x2F;httpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    28	cockpit-ws:x:992:986:User for cockpit-ws:&#x2F;nonexisting:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    29	usbmuxd:x:113:113:usbmuxd user:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    30	rpc:x:32:32:Rpcbind Daemon:&#x2F;var&#x2F;lib&#x2F;rpcbind:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    31	saslauth:x:988:76:Saslauthd user:&#x2F;run&#x2F;saslauthd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    32	sssd:x:976:976:User for sssd:&#x2F;:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    33	pcp:x:991:985:Performance Co-Pilot:&#x2F;var&#x2F;lib&#x2F;pcp:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    34	chrony:x:990:984::&#x2F;var&#x2F;lib&#x2F;chrony:&#x2F;sbin&#x2F;nologin</span><br><span class="line">    35	libstoragemgmt:x:989:982:daemon account for libstoragemgmt:&#x2F;var&#x2F;run&#x2F;lsm:&#x2F;sbin&#x2F;nologin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ awk -F &quot;:&quot;  &#39;BEGIN&#123;printf &quot;%-10s\t%-10s\n&quot;,&quot;用户名&quot;,&quot;用户id&quot;&#125; &#x2F;^d&#x2F; &#123;printf &quot;%-10s\t%-10s\n&quot;,$1,$3&#125;&#39; passwd </span><br><span class="line">用户名       	用户id      </span><br><span class="line">daemon    	2         </span><br><span class="line">dbus      	81  </span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/04/22/cLW9P0.png" alt="awk2"></p>
<h3 id="找出passwd文件中禁止登录的用户（-sbin-nologin）"><a href="#找出passwd文件中禁止登录的用户（-sbin-nologin）" class="headerlink" title="找出passwd文件中禁止登录的用户（/sbin/nologin）"></a>找出passwd文件中禁止登录的用户（/sbin/nologin）</h3><div class="note pink no-icon flat"><p>正则表达式中如果出现了 <code>&quot;/&quot;</code>则需要进行转义</p>
<p>找出pwd.txt文件中禁止登录的用户<code>（/sbin/nologin）</code></p>
</div>

<ol>
<li><p>用grep找出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;&#x2F;sbin&#x2F;nologin$&#39; passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/04/22/cLWCGV.png" alt="awk3"></p>
</li>
<li><p>awk用正则得用双斜杠<code>/正则表达式/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#x2F;\&#x2F;sbin\&#x2F;nologin$&#x2F;&#123;print $0&#125;&#39; passwd </span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/04/22/cLWP2T.png" alt="awk4"></p>
</li>
</ol>
<h3 id="找出文件的区间内容"><a href="#找出文件的区间内容" class="headerlink" title="找出文件的区间内容"></a>找出文件的区间内容</h3><h4 id="找出adm用户到mail用户之间的内容"><a href="#找出adm用户到mail用户之间的内容" class="headerlink" title="找出adm用户到mail用户之间的内容"></a>找出adm用户到mail用户之间的内容</h4><div class="note pink no-icon flat"><p>正则模式<br><code>awk &#39;/正则表达式/{动作}&#39; file</code></p>
<p>行范围模式<br><code>awk &#39;/正则1/,/正则2/{动作}&#39; file</code></p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#x2F;^adm&#x2F;,&#x2F;^mail&#x2F; &#123;print $0&#125;&#39; passwd </span><br><span class="line">adm:x:3:4:adm:&#x2F;var&#x2F;adm:&#x2F;sbin&#x2F;nologin</span><br><span class="line">lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line">halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt</span><br><span class="line">mail:x:8:12:mail:&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure>
<h4 id="关系表达式模式"><a href="#关系表达式模式" class="headerlink" title="关系表达式模式"></a>关系表达式模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;NR&gt;&#x3D;4 &amp;&amp; NR&lt;&#x3D;9 &#123;print $0&#125;&#39; passwd </span><br><span class="line">adm:x:3:4:adm:&#x2F;var&#x2F;adm:&#x2F;sbin&#x2F;nologin</span><br><span class="line">lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line">halt:x:7:0:halt:&#x2F;sbin:&#x2F;sbin&#x2F;halt</span><br><span class="line">mail:x:8:12:mail:&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐学习相关计算机网课 <code>路飞学城</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Linux</tag>
        <tag>awk</tag>
        <tag>grep</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-mdbg 一款用于基因组组装的高效率软件</title>
    <url>/2021/10/31/mdBG/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong><em>rust-mdbg</em></strong> 是一种超快的<strong>minimizer-space de Bruijn graphs (mdBG)</strong> 实现，适用于组装长而准确的读数，例如PacBio HiFi。</p>
<p>随着18年以来Pacbio HiFi reads的出现，让一些复杂基因组的组装不再复杂，而且有越来越多的课题组也加入到了基因组学的研究中，正是因为有了高精度长读长的reads，目前也产生了很多专门用于HiFi组装的软件，如Hifiasm，当然这篇文章的软件的算法，可以用超短时间，低内存去组装。我相信随着不断的发展，以后做组装的时候甚至都不需要服务器，在个人电脑也可以实现。</p>
<p><strong>内容写了很多，考虑到阅读体验，做了删减。</strong><br><strong>下面是正文～</strong></p>
<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>DNA测序技术发展的很快，尤其是以<strong>Pacbio HiFi数据</strong>为代表的<em>Long reads</em>兼顾了长读长以及高准确度。</p>
<p>在这里，研究者定义了一种算法方法mdBG，它利用最小空间德布莱英图(de Bruijn graph)实现long reads基因组组装。</p>
<blockquote>
<p><strong>这里插入一个视频，让大家了解一下以前的组装软件用到的 de Bruijn graph的原理</strong></p>
</blockquote>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=378836402&bvid=BV1Qf4y1M7DW&cid=430213976&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>


<p><strong>与现有方法相比，mdBG 在速度和内存使用方面都实现了几个数量级的改进，而不会影响准确性。</strong><br>实战使用<strong>8个核心</strong>和<strong>10 GB RAM</strong>在<strong>10分钟内组装人类基因组</strong>，使用<strong>1 GB RAM</strong>在<strong>4分钟内</strong>组装<strong>60 GB</strong>的宏基因组数据。</p>
<p>此外，研究者构建了<strong>661405个细菌基因组</strong>的最小空间de Bruijn graph，包括1600万个节点和4500万条边，并在<strong>12分钟</strong>内成功搜索了抗微生物耐药性（AMR）基因。</p>
<p>鉴于基因组学、宏基因组学和泛基因组学中长读长测序的兴起，预计这一进步对序列分析至关重要！</p>
<p>构建mdBGs的代码可免费下载，网址为<br><em><a href="https://github.com/ekimb/rust-mdbg/">https://github.com/ekimb/rust-mdbg/</a></em></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>DNA测序数据持续改善，</p>
<ul>
<li> 从最开始低质量的长reads，用于组装第一批人类基因组</li>
<li> 再到Illumina低误差率(%1%)的短reads，</li>
<li> 目前低误差率的长reads。例如，Pacbio HiFi 1%的错误率产生10-25kbp长(HiFi)reads 进行测序；Nanopore的R10.3孔在~5%的错误率。</li>
</ul>
<p>未来DNA测序最终将产生长的、近乎完美的reads。</p>
<p>这些新技术要求算法对基因组组装等重要序列分析任务既有效又准确。</p>
<p>在这里，作者为<strong>低错误长读长数据</strong>提供了一种高效的基因组组装工具(详见后面进展和潜力)。作者引入了最小化空间 de Bruijn 图，mdBGs。</p>
<p>具体来说，每个reads最初都被转换为其最小值(minimizers)的有序序列。minimizers的顺序很重要，因为作者的目标是将整个基因组重建为一个有序列表。</p>
<p>作者的方法<strong>不同于经典的MinHash技术</strong>，后者将序列转换为无序的最小化集合以检测它们之间的成对相似性。为了帮助组装更高错误率的数据，作者还引入了<strong>偏序比对 (POA) 算法的一种变体</strong>，该算法在最小化空间(minimizer space)而不是基础空间(base space)中运行，<strong>并有效地纠正与reads中最小空间相对应的碱基</strong>。发生在minimizers之外的排序错误不会影响表示。minimizers中的那些会导致最小化空间中的替换或插入（图 4），可以使用 POA 识别并随后在minimizer space中矫正（图 1C）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a02eabe8871fface72d770aae7e18585.png" alt="Fig 1 A"><br><strong>Fig 1A 一种用于基因组测序的高效组装方法（例如，PacBio HiFi数据）</strong></p>
<blockquote>
<p>minimizer-space de Bruijn graph(mdBG，<strong>底部</strong>)与通常用于基因组组装的原始de Bruijn graph(<strong>顶部</strong>)相比的图示<br><strong>中间水平部分</strong>显示了一个参考基因组，以及测序reads。<br>从这幅图可以看出来，传统的Base-space方法是基于k-mers(k=4) 最终输入大小是52 nt 作者给出的 <strong>Minimizer-space</strong>方法，选择以核苷酸“A”开头的(AA, AG, AC, AT)作为最小值分别用m1, m2, m3, m4来表示。k’-min-mers(这里使用了k’=3，作为区分)，从图中可以看出输入大小减少到18 nt。最小空间加快了de <strong>Bruijn图的构造和遍历，同时减少了内存消耗</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/67f7d97c2202f5e7f4c9596f37c27c86.png"><br><strong>Fig 1B 使用mdBG的组装pipeline概述</strong></p>
<blockquote>
<p>两种方法虚线分开，上方按照顺序<br><strong>虚线上方（下方)</strong> 的图形区域对应于在 <strong>基本空间(最小空间)</strong> 中进行的分析。<br>输入reads按顺序扫描，并识别所有属于预先选择的universe minimizers 的 δ-mers。 然后将每个reads表示为所选最小值的有序列表，并使用长度为 <em>k</em> 的滑动窗口从reads的最小空间表示中收集 <em>k-min-mer</em>。 然后从所有 <em>k-min-mer</em>  的集合构建最小空间 de Bruijn 图 (mdBG) 并进行简化，以减少歧义并消除错误。 然后通过连接由 mdBG 中的最小化器跨越的基空间序列，将 mdBG 转换回基空间，并报告一组contigs</p>
</blockquote>
<p>通过使用mdBG执行组装，<strong>大大减少了向组装程序输入的数据量，保持了准确性，减少了运行时间</strong>，与当前的汇编程序相比，内存使用量减少了<strong>1到2个数量级</strong>。为de Bruijn图的阶数和最小化方案的密度设置适当的参数能够以与传统碱基空间组装类似的方式克服测序深度和read长度的随机变化。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/da1aafa96da19b36837580e22bc37063.png"><br><strong>Fig 1C 具有 4 个reads的 toy 数据集的最小化空间偏序对齐 (POA) 过程概述</strong></p>
<blockquote>
<p><strong>(1)</strong> 显示了容易出错的reads及其minimizers (δ = 2)的有序列表，带有排序错误和因错误而创建的最小化器以颜色表示（插入为红色，删除为橙色，替换为蓝色，绿色则表示没有错误)<br><strong>(2)</strong> 在最小化空间纠错之前， minimizers的有序列表使用它们的 n-tuples (n = 1) 进行分组。<br><strong>(3)</strong> 对于一个查询有序列表（图中read集合中的第一个read），得到所有与查询共享一个n-tuple的有序列表，通过启发式确定得到查询邻居的最终列表距离过滤器 $d_j$ （Jaccard 距离阈值 φ = 0.5）<br><strong>(4)</strong> 最小化空间中的 POA 图是通过用查询初始化图并将通过过滤器的每个有序列表迭代地对齐到graph来构建（不太确定的边的权重显示为红色）<br><strong>(5)</strong> 通过 graph 的共识路径，纠正查询中的错误。 </p>
</blockquote>
<p>为了处理更高的排序错误率，作者通过引入<strong>最小空间偏序对齐（POA)</strong> 的概念来纠正基本错误。</p>
<p>对于容易出错的数据，<strong>作者研究了两种情况：</strong></p>
<p>果蝇和人类的PacBio HiFi reads数据（&lt;1%错误率），由于率非常低，因此几乎不需要对错误进行调整;以及合成了错误率在1-10%的数据，对应于Nanopore数据的一个错误率范围。</p>
<p>作者还证明，尽管数据减少，但在合成的无错误数据和4%错误率数据上运行<em>rust-mdbg</em>软件可以实现近乎完美的基因组组装，后者(4%错误率)完全是因为在最小空间中应用了POA矫正的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6988c7a67f48a3638e4911dd6f398e41.png"><br><strong>Fig 2 最小空间POA能够以更高的顺序错误率校正reads</strong></p>
<blockquote>
<p>作者引入最小空间偏序对齐（POA）来解决排序错误。为了确定最小空间POA的有效性以及具有较高read错误率的最小空间de Bruijn图组装的限制，作者在较小的数据集上进行了实验。<br>简言之，作者模拟了不同错误率下单个果蝇染色体的reads，并在有/无POA的情况下进行了mdBG组装。<br><strong>图2A（左）显示</strong>，没有POA的原始实现只能将完整染色体重建为单个contig，错误率高达1%，之后染色体被组装成R2 contigs。使用POA，可以获得单个contig的精确重建，错误率高达4%。作者进一步验证，在3%的错误率下，除了reads中的基本错误外，重建的重叠群在结构上与参考完全对应。在错误率为4%的情况下，最小空间中的单个未修正索引会在组件中引入1 Kbp的人工插入。<br><strong>图2A（右）表明</strong>，原始reads的最小空间随着错误率的增加而线性降低。使用POA，可以实现接近完美的校正，最高矫正误差率高达4%，误差率在&gt;5%时急剧下降，但与未校正的reads相比，识别率仍然有所提高。<br>这突出了准确POA校正的重要性：从长远来看，mdBG似乎适用于没有POA的高保真数据（&lt;1%错误率），作者的POA矫正几乎（但还不是完全）能够处理ONT数据的错误率（5%）。</p>
</blockquote>
<p>使用POA时，实现运行时间约为<strong>45秒</strong>，内存为<strong>0.4 GB</strong>，而不使用POA时，运行时间<strong>小于1秒</strong>，内存<strong>小于30 MB</strong>。注意，作者没有使用优化的POA实现；因此，作者预计下一步的工作将显著降低运行时间，并可能提高校正质量。</p>
<p>为了进一步展示<strong>rust-mdbg</strong>的功能，作者使用它组装了两个PacBio HiFi宏基因组，实现了几分钟运行时间，以及使用较低的占用内存。比当前最先进的 hifiasm-meta 低两个数量级，组装完整性相当，但连续性较低。</p>
<p>作为最小空间分析的一个通用用例，作者构建了迄今为止661K细菌基因组中最大的泛基因组图，并在此图中对抗微生物耐药性（AMR）基因进行最小空间查询，识别出几乎所有与原始细菌基因组具有高度序列相似性的基因。</p>
<p>构建了迄今为止最大的 661K 细菌基因组泛基因组图，并在该图中执行对抗微生物耐药性 (AMR) 基因的最小化空间查询，鉴定几乎所有与原始细菌基因组具有高度序列相似性的基因。在大量样本中快速检测 AMR 基因将有助于实时 AMR 监测（Ellington 等，2017），而 mdBG 为索引 k-mer 搜索提供了一种节省空间的替代方案。值得注意的是，作者的方法相当于检查数据中输入碱基的可调比例（例如，只有 1%），并且应该推广到新兴的测序技术。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/af6313ca07419230f5cb9866913c1c4b.png"></p>
<p><strong>Fig 3 661405个细菌基因组的泛基因组mdBG和抗微生物耐药基因的检索</strong></p>
<blockquote>
<p><strong>顶部面板</strong>：为整个661405细菌收集构建完整的 δ=0.001 泛基因组mdBG，并在此处显示前五个连接组件（使用Gephi软件）。每个节点是一个<em>k-min-mer</em>，边是<em>k-min-mer</em>之间 k - 1 最小值的精确重叠。<br><strong>中间面板</strong>：将一组抗微生物抗性基因靶点转换为最小空间，然后在661405细菌泛基因组图（δ=0.01）中查询每个<em>k-min-mer</em>，产生基因检索的双峰分布：找到与泛基因组中的基因高度一致（99%+）的基因。柱状图由每个基因的最小序列趋异(sequence divergence)进行注释，该差异通过minimap2与其长度超过90%的泛基因组对齐得到。<br><strong>底部面板</strong>：δ=0.01用于图形构造和查询的运行时和内存使用情况。注意，在预处理步骤中，该图只需构造一次。</p>
</blockquote>
<h1 id="实战结果比较"><a href="#实战结果比较" class="headerlink" title="实战结果比较"></a>实战结果比较</h1><h2 id="使用-rust-mdbg-对HiFi-reads进行超快速、高效内存和高度连续的组装"><a href="#使用-rust-mdbg-对HiFi-reads进行超快速、高效内存和高度连续的组装" class="headerlink" title="使用 rust-mdbg 对HiFi reads进行超快速、高效内存和高度连续的组装"></a>使用 rust-mdbg 对HiFi reads进行超快速、高效内存和高度连续的组装</h2><p>作者在来自黑腹果蝇的PacBio HiFi reads上评估了作者的软件 rust-mdbg，覆盖率为 1003X，人类（HG002）的 HiFi reads为 503X，两者均取自HiCanu.</p>
<p>由于作者的方法<strong>不能解决二倍体生物体中的两种单倍型</strong>，作者与 HiCanu 和 hifiasm 的主要contigs进行了比较。在作者对黑腹果蝇的测试中，参考基因组由来自  <em>RefSeq accession(GenBank：GCA_000001215.4)</em> 的所有核染色体组成。使用 <em>QUAST v5.0.2</em> 进行组装评估，并使用 HiCanu 的文章中推荐的参数运行。 QUAST 将重叠群与参考基因组对齐，允许计算针对错误组装进行校正的连续性和完整性统计数据（表 3 中分别为 <em>NGA 50</em>和基因组分数指标）。程序集全部使用 8 个线程在 <em>Xeon 2.60 GHz CPU</em> 上运行。<br>对于 rust-mdbg 程序集，过滤掉短于 <strong>50 Kbp</strong> 的重叠群。没有报告基本空间转换步骤和图形简化的运行时间，因为它们不到运行 CPU 时间的 15% 并且在单个线程上运行，占用的内存不超过最终程序集大小，也比mdBG更少内存。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KxKjiVBj-1635608738024)(<a href="https://z3.ax1x.com/2021/10/30/5ztD7n.png)]">https://z3.ax1x.com/2021/10/30/5ztD7n.png)]</a></p>
<blockquote>
<p><strong>表 1（最左侧）</strong> 显示了黑腹果蝇 HiFi 读取的组装统计数据。作者的软件 rust-mdbg 使用的时间比所有其他汇编程序少。在装配质量方面，所有工具都产生了高质量的结果。<br><strong>表 1（最右侧）</strong> 显示了 Human HiFi (HG002) 读取的组装统计数据。<br>这突出表明 mdBG 允许在最小空间中对初始装配图进行非常有效的存储和简化操作。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/151d60ea592a24b87a021acd722d8c0a.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5dce4b96e92d9f3074c9b61ee49198ab.png"></p>
<p>从表中可以看出运行时间以及运行内存都大大降低<br>但是要实事求是的讲，它的组装结果来说是<strong>没有其他结果的Complete(%)高</strong>，但是我觉得作者是<strong>从算法上的突破，让基因组的组装不在拘束于时间、内存、高配置服务器的限制</strong>，对于目前主流的组装软件来讲，当然不是一个很好的结果，但是也是一个突破。随着不断的完善进步，我相信可以既兼顾时间又兼顾组装的准确度。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ed993c0b436597e32108cc57e8c2459.png"></p>
<p><strong>Fig 4 base space到minimizer space的测序误差</strong></p>
<blockquote>
<p>作者考虑一个序列连同它的最小化器（图片的左边）。盒子里的每个面板描绘了不同突变对该序列的影响。<br><strong>左上</strong>：G到C（紫色）导致最小空间表示没有变化，因为突变没有改变或产生任何最小空间。<br><strong>左下</strong>：A到G导致m2消失。<br><strong>右上</strong>：C到A使m3最小值出现。<br><strong>右下</strong>：T到受影响的两个最小值：m4替换m1，插入m3。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之所以分享这一篇文章，我想总结自从18年 Pacbio HiFi 测序技术出来之后，出现了很多hifi组装的软件，目前我认为结果较好的还是hifiasm软件，并且在多次的项目实践中证实了我的这一认为，当然还有很多优秀的组装软件比如:Canu、Falcon、Nextdenovo… 以及这次我介绍的这款软件，分享这款软件是因为它的算法进行了一个改变，使得组装时间大大缩短，并且也有一个不错的结果，<strong>作者目前更新的版本是v 1.0.1 ，可能有一些存在bug，等版本不断更新迭代肯定会更完善。</strong> 我相信，在不久的以后会有更多更好的算法以及软件会出现，降低了门槛，可以从基因组水平上对物种的生长、发育、进化、起源等重大问题进行研究，加深我们对物种的认识。</p>
]]></content>
      <categories>
        <category>基因组组装</category>
      </categories>
      <tags>
        <tag>rust-mdbg</tag>
        <tag>算法介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/map/index.html</url>
    <content><![CDATA[
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>地图</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <style>
    body,
    html,
    #container {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        font-family: "微软雅黑";
    }
    .info {
        z-index: 999;
        width: auto;
        min-width: 22rem;
        padding: .75rem 1.25rem;
        margin-left: 1.25rem;
        position: fixed;
        top: 1rem;
        background-color: #fff;
        border-radius: .25rem;
        font-size: 14px;
        color: #666;
        box-shadow: 0 2px 6px 0 rgba(27, 142, 236, 0.5);
    }
    </style>
    <script src="//api.map.baidu.com/api?type=webgl&v=1.0&ak=4Q4lo7RAxIPqvmq3HvSwmwxOU8RNPky9"></script>
</head>
<body>
    <div id="container"></div>

    <title>定位相关控件</title>

<body>
    <div id="container"></div>
    <script>
        var map = new BMapGL.Map('container');
        map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 11);

        // 创建定位控件
        var locationControl = new BMapGL.LocationControl({
            // 控件的停靠位置（可选，默认左上角）
            anchor: BMAP_ANCHOR_TOP_RIGHT,
            // 控件基于停靠位置的偏移量（可选）
            offset: new BMapGL.Size(20, 20)
        });
        // 将控件添加到地图上
        map.addControl(locationControl);

        // 添加定位事件
        locationControl.addEventListener("locationSuccess", function(e){
            var address = '';
            address += e.addressComponent.province;
            address += e.addressComponent.city;
            address += e.addressComponent.district;
            address += e.addressComponent.street;
            address += e.addressComponent.streetNumber;
            alert("当前定位地址为：" + address);
        });
        locationControl.addEventListener("locationError",function(e){
            alert(e.message);
        });

    </script>

    <title>城市选择列表控件</title>

<body>
    <div id="container"></div>
    <script>
        var map = new BMapGL.Map('container');
        map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 11);
        // 创建城市选择控件
        var cityControl = new BMapGL.CityListControl({
            // 控件的停靠位置（可选，默认左上角）
            anchor: BMAP_ANCHOR_TOP_LEFT,
            // 控件基于停靠位置的偏移量（可选）
            offset: new BMapGL.Size(10, 5)
        });
        // 将控件添加到地图上
        map.addControl(cityControl);
    </script>

    <title>根据关键字本地搜索</title>
    <style>
        body,
        html,
        #container {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            font-family: "微软雅黑";
        }
        .info {
        z-index: 999;
        width: auto;
        min-width: 22rem;
        padding: .75rem 1.25rem;
        margin-left: 1.25rem;
        position: fixed;
        top: 1rem;
        background-color: #fff;
        border-radius: .25rem;
        font-size: 14px;
        color: #666;
        box-shadow: 0 2px 6px 0 rgba(27, 142, 236, 0.5);
    }
    </style>

<body>


</body>
</body></body></body></html>

<script>
var map = new BMapGL.Map('container'); // 创建Map实例
map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 12); // 初始化地图,设置中心点坐标和地图级别
map.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放
var opts = {
    position: new BMapGL.Point(116.2787, 40.0492), // 指定文本标注所在的地理位置
    offset: new BMapGL.Size(30, -30) // 设置文本偏移量
};
// 创建文本标注对象
var label = new BMapGL.Label('欢迎在lxz9.com使用百度地图JSAPI GL版本', opts);
// 自定义文本标注样式
label.setStyle({
    color: 'blue',
    borderRadius: '5px',
    borderColor: '#ccc',
    padding: '10px',
    fontSize: '16px',
    height: '30px',
    lineHeight: '30px',
    fontFamily: '微软雅黑'
});
map.addOverlay(label);

<script type="text/javascript">
    // 百度地图API功能
    var map = new BMapGL.Map("container");          
    map.centerAndZoom(new BMapGL.Point(116.404, 39.915), 11);
    var local = new BMapGL.LocalSearch(map, {
        renderOptions:{map: map}
    });
    local.search("景点");
</script>
]]></content>
  </entry>
  <entry>
    <title>电影</title>
    <url>/movies/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>音乐</title>
    <url>/music/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
